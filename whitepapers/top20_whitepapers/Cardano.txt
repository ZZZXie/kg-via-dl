Ouroboros: A Provably Secure Proof-of-Stake Blockchain Protocol
Aggelos Kiayias∗ Alexander Russell† Bernardo David‡ Roman Oliynykov§
July 20, 2019
Abstract
We present “Ouroboros,” the ﬁrst blockchain protocol based on proof of stake with rig-
orous security guarantees. We establish security properties for the protocol comparable to
those achieved by the bitcoin blockchain protocol. As the protocol provides a “proof of stake”
blockchain discipline, it oﬀers qualitative eﬃciency advantages over blockchains based on proof
of physical resources (e.g., proof of work). We also present a novel reward mechanism for in-
centivizing proof of stake protocols and we prove that, given this mechanism, honest behavior
is an approximate Nash equilibrium, thus neutralizing attacks such as selﬁsh mining. We also
present initial evidence of the practicality of our protocol in real world settings by providing
experimental results on transaction conﬁrmation and processing.
1 Introduction
A primary consideration regarding the operation of blockchain protocols based on proof of work
(PoW)—such as bitcoin [34]—is the energy required for their execution. At the time of this writ-
ing, generating a single block on the bitcoin blockchain requires a number of hashing operations
exceeding 260, which results in striking energy demands. Indeed, early calculations indicated that
the energy requirements of the protocol were comparable to that of a small country [36].
This state of aﬀairs has motivated the investigation of alternative blockchain protocols that
would obviate the need for proof of work by substituting it with another, more energy eﬃcient,
mechanism that can provide similar guarantees. Fundamentally, the proof of work mechanism of
bitcoinfacilitatesatypeofrobustrandomized“leaderelection”processthatelectsoneoftheminers
to issue the next block. Furthermore—provided that all miners follow the protocol—this selection
is performed in a randomized fashion proportionally to the computational power of each miner.
(Deviations from the protocol may distort this proportionality as exempliﬁed by “selﬁsh mining”
strategies [25, 43].)
A natural alternative mechanism relies on the notion of “proof of stake” (PoS). Rather than
miners investing computational resources in order to participate in the leader election process, they
instead run a process that randomly selects one of them proportionally to the stake that each
possesses according to the current blockchain ledger.
∗UniversityofEdinburghandIOHK.akiayias@inf.ed.ac.uk. WorkpartlyperformedwhileattheNationaland
Kapodistrian University of Athens, supported by ERC project CODAMODA #259152. Work partly supported by
H2020 Project #653497, PANORAMIX.
†University of Connecticut and IOHK. acr@cse.uconn.edu.
‡Aarhus University and IOHK, bernardo@bmdavid.com. Work partly supported by European Research Council
Starting Grant 279447.
§IOHK, roman.oliynykov@iohk.io.
1
In eﬀect, this yields a self-referential blockchain discipline: maintaining the blockchain relies on
the stakeholders themselves and assigns work to them (as well as rewards) based on the amount
of stake that each possesses as reported in the ledger. Aside from this, the protocol should make
no further “artiﬁcial” computational demands on the stakeholders. In some sense, this sounds
ideal; however, realizing such a proof of stake protocol appears to involve a number of deﬁnitional,
technical, and analytic challenges.
Previous work. The concept of PoS has been discussed extensively in the bitcoin forum.1 Proof
of stake based blockchain design has been more formally studied by Bentov et al., both in conjunc-
tion with PoW [7] as well as the sole mechanism for a blockchain protocol [6]. Although Bentov
et al. showed that their protocols are secure against some classes of attacks, they do not provide
a formal model for analyzing PoS based protocols or security proofs relying on precise deﬁnitions.
Heuristic proof of stake based blockchain protocols have been proposed (and implemented) for a
number of cryptocurrencies.2 Being based on heuristic security arguments, these cryptocurrencies
havebeenfrequentlyfoundtobedeﬁcientfromthepointofviewofsecurity. See[6]foradiscussion
of various attacks.
It is also interesting to contrast a PoS-based blockchain protocol with a classical consensus
blockchain that relies on a ﬁxed set of authorities (see, e.g., [21]). What distinguishes a PoS-based
blockchain from those which assume static authorities is that stake changes over time and hence
the trust assumption evolves with the system as well as the fact that the complexity of system
maintenance should be sublinear in the total number of users/stakeholders.
Another alternative to PoW is the concept of proof of space [2, 24], which has been speciﬁcally
investigated in the context of blockchain protocols [37]. In a proof of space setting, a “prover”
wishes to demonstrate the utilization of space (storage/memory); as in the case of a PoW, this
utilizes a physical resource but can demand less energy. A related concept is proof of space-time
(PoST)[32]. Inallthesecases,however,theprotocolreliesonanexpensivephysicalresource(either
storage or computational power).
The PoS Design challenge. A fundamental problem for PoS-based blockchain protocols is to
simulate the leader election process. In order to achieve a fair randomized election among stake-
holders, entropy must be introduced into the system, and mechanisms to introduce entropy may be
pronetomanipulationbytheadversary. Forinstance, anadversarycontrollingasetofstakeholders
may attempt to simulate the protocol execution trying diﬀerent sequences of stakeholder partici-
pants so that it ﬁnds a protocol continuation that favors the adversarial stakeholders. This leads
to a so called “grinding” vulnerability, where adversarial parties may use computational resources
to bias the leader election.
Our Results. We present “Ouroboros,” a provably secure proof of stake system. To the best of
our knowledge this is the ﬁrst blockchain protocol of its kind with a rigorous security analysis. In
more detail, our results are as follows.
First,weprovideamodelthatformalizestheproblemofrealizingaPoS-basedblockchainproto-
col. The model we introduce is in the spirit of [28], focusing on persistence and liveness, two formal
properties of a robust transaction ledger. Persistence states that once a node of the system pro-
claims a certain transaction as “stable,” the remaining nodes, if queried and responding honestly,
1See “Proof of stake instead of proof of work”, Bitcoin forum thread. Posts by user “QuantumMechanic” and
others. (https://bitcointalk.org/index.php?topic=27787.0.).
2A non-exhaustive list includes NXT, Neucoin, Blackcoin, Tendermint, Bitshares.
2
will also report it as stable. Here, stability is to be understood as a predicate that will be parame-
terized by some security parameter k that will aﬀect the certainty with which the property holds.
(E.g., “more than k blocks deep.”) Liveness ensures that once an honestly generated transaction
has been made available for a suﬃcient amount of time to the network nodes, say u time steps,
it will become stable. The conjunction of liveness and persistence provides a robust transaction
ledger in the sense that honestly generated transactions are adopted and become immutable. Our
model is suitably adapted to reﬂect PoS-based dynamics.
Second, we describe a novel blockchain protocol based on PoS. Our protocol assumes that
parties can freely create accounts and receive and make payments, and that stake shifts over time.
We utilize a (simple) secure multiparty implementation of a coin-ﬂipping protocol to produce the
randomness for the leader election process. This distinguishes our approach (and prevents so called
“grinding attacks”) from other previous solutions that either deﬁned such values deterministically
based on the current state of the blockchain or used collective coin ﬂipping as a way to introduce
entropy [6]. Also, unique to our approach is the fact that the system ignores round-to-round
stake modiﬁcations. Instead, a snapshot of the current set of stakeholders is taken in regular
intervals called epochs; in each such interval a secure multiparty computation takes place utilizing
the blockchain itself as the broadcast channel. Speciﬁcally, in each epoch a set of randomly selected
stakeholders form a committee which is then responsible for executing the coin-ﬂipping protocol.
Theoutcomeoftheprotocoldeterminesthesetofelectedstakeholdersthatwillexecutetheprotocol
in the subsequent epoch, as well as the outcomes of all leader elections for the epoch.
Third,weprovideasetofformalargumentsestablishingthatnoadversarycanbreakpersistence
and liveness. Our protocol is secure under a number of plausible assumptions: (1) the network
is synchronous in the sense that an upper bound can be determined during which any honest
stakeholder is able to communicate with any other stakeholder, (2) a number of stakeholders drawn
from the honest majority is available as needed to participate in each epoch, (3) the stakeholders
do not remain oﬄine for long periods of time, (4) the adaptivity of corruptions is subject to a small
delay that is measured in rounds linear in the security parameter (or alternatively, the players
have access to a sender-anonymous broadcast channel). At the core of our security arguments is a
probabilistic argument regarding a combinatorial notion of “forkable strings” which we formulate,
prove and also investigate experimentally. In our analysis we also distinguish covert attacks, a
special class of general forking attacks. “Covertness” here is interpreted in the spirit of covert
adversaries against secure multiparty computation protocols, cf. [3], where the adversary wishes to
breaktheprotocolbutprefersnottobecaughtdoingso. Weshowthatcovertlyforkablestringsare
a subclass of the forkable strings with much smaller density; this permits us to provide two distinct
security arguments that achieve diﬀerent trade-oﬀs in terms of eﬃciency and security guarantees.
Our forkable string technique is a natural and general tool that may have applications beyond
analysis of our speciﬁc PoS protocol.
Fourth, we turn our attention to the incentive structure of the protocol. We present a novel
reward mechanism for incentivizing the participants to the system which we prove to be an (ap-
proximate) Nash equilibrium. In this way, attacks like block withholding and selﬁsh-mining [25, 43]
are mitigated by our design. The core idea behind the reward mechanism is to provide positive
payoﬀ for those protocol actions that cannot be stiﬂed by a coalition of parties that diverges from
the protocol. In this way, it is possible to show that under plausible assumptions—namely that
certain protocol execution costs are small—following the protocol faithfully is an equilibrium when
all players are rational.
Fifth,weintroduceastakedelegationmechanismthatcanbeseamlesslyaddedtoourblockchain
protocol. Delegation is particularly useful in our context as we would like to allow our protocol
to scale even in a setting where the set of stakeholders is highly fragmented. In such cases, the
3
delegation mechanism can enable stakeholders to delegate their “voting rights,” i.e., the right of
participating in the committees running the leader selection protocol in each epoch. As in liquid
democracy (a.k.a.delegativedemocracy[27]),stakeholdershavetheabilitytorevoketheirdelegative
appointment when they wish, independently of each other.
Given our model and protocol description we also explore how various attacks considered in
practice can be addressed within our framework. Speciﬁcally, we discuss double spending attacks,
transaction denial attacks, 51% attacks, nothing-at-stake, desynchronization attacks and others.
Finally, we present evidence for the practical eﬃciency of our design. First we consider double
spending attacks. For illustrative purposes, we perform a comparison with Nakamoto’s analysis for
bitcoin regarding transaction conﬁrmation time with assurance 99.9%. Against covert adversaries,
the transaction conﬁrmation time is from 10 to 16 times faster than that of bitcoin, depending on
theadversarialhashingpower; forgeneraladversariesconﬁrmationtimeisfrom5to10timesfaster.
Moreover, our concrete analysis of double-spending attacks relies on our combinatorial analysis of
forkable and covertly forkable strings and applies to a much broader class of adversarial behavior
than Nakamoto’s more simpliﬁed analysis.3 We then survey our prototype implementation and
report on benchmark experiments run in the Amazon cloud that showcase the power of our proof
of stake blockchain protocol in terms of performance.
Related and Follow-up Work. In parallel to the development of Ouroboros, a number of other
protocolsweredevelopedtargetingvariouspositionsinthedesignspaceofdistributedledgersbased
on PoS. Sleepy consensus [8] considers a ﬁxed stakeholder distribution (i.e., stake does not evolve
over time) and targets a “mixed” corruption setting, where the adversary is allowed to be adaptive
as well as perform fail-stop and recover corruptions in addition to Byzantine faults. It is straight-
forward to extend our analysis in this mixed corruption setting, cf. Remark 2; nevertheless, the
resulting security can be argued only in the “corruptions with delay” setting, and thus is not fully
adaptive; in follow up work it is shown how our analysis can be extended to incorporate both
adaptive corruptions [22] as well as a more reﬁned model of availability [4] that covers fail-stop and
recover/sleepy corruptions. Snow White [9] addresses an evolving stakeholder distribution and uses
a corruption delay mechanism similar to ours for arguing security. Contrary to our approach here
the leader election of [9] enables a degree of “grinding”, i.e., making it feasible to signiﬁcantly bias
any adversarially chosen high probability event but aﬀords a much more eﬃcient randomness gen-
eration process. In follow-up work [22] it is shown how it is possible to obtain full adaptive security
and similarly eﬃcient randomness generation extending the forkable strings analysis introduced in
the present paper. Algorand [31] provides a distributed ledger following a Byzantine agreement
per block approach that can withstand adaptive corruptions. Given that agreement needs to be
reached for each block, such protocols will produce blocks at a rate substantially slower than a PoS
blockchain (where the slow down matches the expected length of the execution of the Byzantine
agreement protocol); on the other hand, Algorand can be parameterised to be free of forks and
then blocks will “settle” immediately after the conclusion of each consensus sub-protocol. In par-
ticular full settlement will happen at expected constant number of rounds, which, asymptotically,
is superior to any blockchain protocol (it is worth noting that blockchain protocols somewhat mit-
igate this inherent slow-down by letting ledger users choose a diﬀerent level of settlement security
depending on the value of transactions that are at risk or by using an overlay protocol such as
lightning [41]). This beneﬁt comes at the expense of imposing speciﬁc participation bounds for
3Nakamoto’s simpliﬁcations are pointed out in [28]: the analysis considers only the setting where a block with-
holding attacker acts without interaction as opposed to a more general attacker that, for instance, tries strategically
to split the honest parties in more than one chains during the course of the double spending attack.
4
each sub-protocol instance which are unnecessary in the case of a blockchain protocol, see the fol-
low up work on Ouroboros with dynamic availability [4] for further discussion on this topic. The
Algorand approach also does not require an agreed concept of time between the participants and
merely relies on the assumption that time passes with roughly the same speed. While the protocol
presented herein requires access to global time, in follow-up work, [5], it is shown how it is pos-
sible for the Ouroboros protocol to be enhanced with a time synchronization sub-protocol while
retaining the core security argument we present here. Fruitchain [40] provides a reward mechanism
and an approximate Nash equilibrium proof for a PoW-based blockchain. We use a similar reward
mechanism at the blockchain level, nevertheless our underlying mechanics are diﬀerent since we
operate in a PoS setting. The core of the idea is to provide a PoS analogue of “endorsing” inputs in
a fair proportion using the same logic as the PoW-based byzantine agreement protocol for honest
majority from [28]. Finally, in the present paper we prove that the error bound for the common-
preﬁxproperty(andthuspersistenceoftransactions)hasanerrorratethatdropssub-exponentially
with the security parameter, while experimentally we demonstrate an exponential drop. Follow up
work [42] shows how this gap can be closed by proving an exponentially decreasing error bound.
Paper overview. We lay out the basic model in Sec. 2. To simplify the analysis of our protocol,
we present it in four stages that are outlined in Sec. 3. In short, in Sec. 4 we describe and analyze
the protocol in the static setting; we then transition to the dynamic setting in Sec. 5. We then
present the protocol enhancement with anonymous channels in Sec. 7. Our incentive mechanism
and the equilibrium argument are presented in Sec. 8. Following this, we discuss delegation in
Sec. 9 and in Sec. 10, the resilience of the protocol under various particular attacks of interest.
Finally, in Sec. 11 we discuss transaction conﬁrmation times as well as general performance results
obtained from a prototype implementation running in the Amazon cloud.
2 Model
Time, slots, and synchrony. We consider a setting where time is divided into discrete units
called slots. A ledger, described in more detail below, associates with each time slot (at most) one
ledgerblock. Playersareequippedwith(roughlysynchronized)clocksthatindicatethecurrentslot.
This will permit them to carry out a distributed protocol intending to collectively assign a block
to this current slot. In general, each slot is indexed by an integer r ∈ {1,2,...}, and we assume
that the real time window that corresponds to each slot has the following properties.
• The current slot is determined by a publicly-known and monotonically increasing function of
current time.
• Each player has access to the current time. Any discrepancies between parties’ local time are
insigniﬁcant in comparison with the length of time represented by a slot.
• The length of the time window that corresponds to a slot is suﬃcient to guarantee that
any message transmitted by an honest party at the beginning of the time window will be
received by any other honest party by the end of that time window (even accounting for
small inconsistencies in parties’ local clocks). In particular, while network delays may occur,
they never exceed the slot time window.
TransactionLedgerProperties. AprotocolΠimplementsarobusttransactionledgerprovided
thattheledgerthatΠmaintainsisdividedinto“blocks”(assignedtotimeslots)thatdeterminethe
5
order with which transactions are incorporated in the ledger. It should also satisfy the following
two properties.
• Persistence, with parameter k ∈ N. Once a node of the system proclaims a certain
transaction tx as stable, the remaining nodes, if queried, will report tx at the same position
of the ledger and agree on the entire preﬁx of the ledger (prior to tx). Stability is deﬁned in
terms of the blockchain: a transaction is declared stable if and only if it is in a block that is
more than k blocks deep in the ledger.
• Liveness, with parameter u ∈ N. If all honest nodes in the system attempt to include
a certain transaction, then after the passing of time corresponding to u slots (called the
transaction conﬁrmation time), all nodes, if queried and responding honestly, will report the
transaction as stable.
Persistenceandlivenesscanbederivedfromthefollowingthreeelementaryproperties[28,30,39]
provided that protocol Π derives the ledger from a data structure in the form of a blockchain (or
simplychain)thateachpartymaintainslocallyandupdatesattheonsetofeachslot. Theproperties
are as follows.
• Common Preﬁx (CP); with parameter k ∈ N. The chains C ,C adopted by two honest
1 2
parties at the onset of the slots sl ≤ sl are such that Cdk (cid:22) C , where Cdk denotes the chain
1 2 1 2 1
obtained by removing the last k blocks from C , and (cid:22) denotes the preﬁx relation.
1
• Honest Chain Growth (HCG); with parameters τ ∈ (0,1] and s ∈ N. Consider the
chain C adopted by an honest party. Let sl be the slot associated with the last block of C
2
and let sl be a prior slot in which C has an honestly-generated block. If sl ≥ sl +s, then
1 2 1
the number of blocks appearing in C after sl is at least τs. The parameter τ is called the
1
speed coeﬃcient.
• Existential Chain Quality (∃CQ); with parameter s ∈ N. ConsiderthechainC adopted
by an honest party at the onset of a slot and any portion of C spanning s prior slots; then at
least one honestly-generated block appears in this portion.
Some remarks are in place. This deﬁnition of common preﬁx reﬂects a strong variant of that
appearing in [30]. As for chain quality, we work with this simple “existential” formulation for
convenience. Previous work focused on a more general notion that bounds the density of honestly-
generated blocks in a suﬃciently long portion of a chain. In fact, one can establish such a density
bound directly from existential chain quality along the lines of the proof of chain growth in Sec-
tion 4.5.
As for chain growth, we focus on a version pertaining to the suﬃx of the chain following an
honest block. In fact, as we note in Section 4.5, combining ∃CQ and HCG one can directly infer the
following stronger version.
• Chain Growth (CG); with parameters τ ∈ (0,1] and s ∈ N. Consider the chain C
adopted by an honest party at the onset of a slot and any portion of C spanning s prior slots;
then the number of blocks appearing in this portion of the chain is at least τs.
As in the case of bitcoin, the longest chain plays a preferred role in our protocol; this provides
a straightforward guarantee of honest chain growth.
6
Security Model. We adopt the model introduced by [28] for analyzing security of blockchain
protocols enhanced with an ideal functionality F. We denote by VIEWP,F (κ) the view of party
Π,A,Z
P after the execution of protocol Π with adversary A, environment Z, security parameter κ and
access to ideal functionality F. Similarly we denote by EXECF (κ) the output of Z.
Π,A,Z
We note that multiple diﬀerent “functionalities” will be encompassed by F. Contrary to [28],
our analysis is in the “standard model,” and without a random oracle functionality. The ﬁrst inter-
faces we incorporate in the ideal functionality used in the protocol are the “diﬀuse” and “key and
transaction” functionality, denoted F and described below. Note that the diﬀuse functionality
D+KT
is also the mechanism via which we will obtain protocol synchronization.
Diﬀuse functionality. The diﬀuse functionality maintains an incoming string for each party U
i
that participates. A party, if activated, is allowed at any moment to fetch the contents of its
incoming string; one may think of this as a mailbox. Additionally, parties can instruct the
functionality to diﬀuse a message, in which case the message will be appended to each party’s
incoming string. The functionality maintains rounds (slots) and all parties activated in a
round are allowed to diﬀuse once. Rounds do not advance unless all activated parties have
diﬀused a message. The adversary, when activated, may also interact with the functionality;
it may read all inboxes and all diﬀuse requests and deliver messages to the inboxes in any
order it prefers. At the end of the round, the functionality will ensure that all inboxes contain
all messages that have been diﬀused (but not necessarily in the same order they have been
requested to be diﬀused). The current slot index may be requested at any time by any party.
If a party does not fetch in a certain slot the messages written to its incoming string, they
are ﬂushed.
Key and Transaction functionality. The key registration functionality is initialized with n
users, U ,...,U , and their respective stakes, s ,...,s ; given such initialization, the func-
1 n 1 n
tionality will consult with the adversary and will accept a (possibly empty) sequence of
(Corrupt,U) messages and mark the corresponding users U as corrupt. For the corrupt users
without a registered public-key the functionality will allow the adversary to set their public-
keys. For honest users the functionality will sample public/secret-key pairs and record them
based on a digital signature algorithm; we will consider two modes for key generation. In the
ideal mode, key generation will be outsourced to an instance of an ideal signature function-
ality; in the real mode, an actual digital signature algorithm will be utilized; (cf. Figure 1
where we make these two variants explicit). Public-keys of corrupt users will be marked as
such. Subsequently, any sequence of the following actions may take place: (i) A user may
request to sign or verify a message whereupon the functionality will respond accordingly, re-
stricting signing requests to only the owners of the respective keys. (ii) The entire directory
of public-keys may be requested, whereupon the functionality will return it to the requesting
user. (iii) A new user may be requested to be created by a message (Create,U,C) from the
environment, in which case the functionality will follow the same procedure as above: it will
consult the adversary regarding the corruption status of U and will set its public and possibly
secret-key depending on the corruption status; additionally, it will store C as the suggested
initial state. The functionality will return the public-key to the environment upon successful
completion of this interaction. (iv) An existing user may be requested to be corrupted by the
adversary via a message (Corrupt,U). A user can only be corrupted after a delay of D slots;
speciﬁcally, after a corruption request is registered, a timer is maintained and the corruption
will take place after D slots have passed according to the round counter maintained in the
Diﬀuse component of the functionality. Note that when running in real mode, a corruption
7
will have the eﬀect of revealing the secret-key to the adversary. In any case, the adversary
will be able to access the signing interface of any corrupted party.
We assume throughout that the execution of the protocol is with respect to a functionality
F that incorporates, at least, the above two functionalities. Further functionalities are explained
below. Note that a corrupted stakeholder U will relinquish its entire state to A; from this point on,
theadversarywillbeactivatedinplaceofthestakeholderU. BeyondanyrestrictionsimposedbyF,
theadversarycanonlycorruptastakeholderifitisgivenpermissionbytheenvironmentZ running
the protocol execution. The permission is in the form of a message (Corrupt,U) which is provided
to the adversary by the environment. The environment can give arbitrary permissions, however
with respect to an initial stakeholder set and respective stake, the adversary will be restricted to
controlling only a percentage of that stake, say α. In such case we refer to this adversary as an
α-initially-bounded adversary. In summary, regarding activations we have the following.
• At each slot sl , the environment Z is allowed to activate any subset of stakeholders it
j
wishes. Each one of them will possibly produce messages that are to be transmitted to other
stakeholders.
• The adversary is activated, at least, as the last entity in each sl (as well as during all
j
adversarial party activations).
It is easy to see that the model above confers such sweeping power on the adversary that one
cannot establish any signiﬁcant guarantees on protocols of interest. It is thus important to restrict
the environment suitably (taking into account the details of the protocol) so that we may be able
to argue security. With foresight, the restrictions we will impose on the environment are as follows.
Restrictions imposed on the environment. The environment, which is responsible for acti-
vating the honest parties in each round, will be subject to the following constraints regarding the
activation of the honest parties running the protocol.
• In each slot there will be at least one honest activated party.
• Therewillbeaparameterk ∈ Zthatwillsignifythemaximumnumberofslotsthatanhonest
shareholder can be oﬄine. In case an honest stakeholder is spawned after the beginning of
the protocol via (Create,U,C) its initialization chain C provided by the environment should
match an honest parties’ chain which was active in the previous slot.
• The environment will distribute the transaction data d ∈ {0,1}∗ to all parties, emulating the
eﬀect of diﬀusing transactions in a peer-to-peer network. This transaction data, including
the required signatures by each stakeholder, is obtained by the environment as speciﬁed in
the protocol.
• In each slot sl , and for each active stakeholder U , the view of the stakeholder will include a
r j
setS (r)ofpublic-keysandstakepairsoftheform(vk ,s ) ∈ {0,1}∗×N,forj = 1,...,n ;here
j i i r
n is the number of users introduced up to that slot according to the view of U . Public-keys
r j
willbemarkedas“corrupted”ifthecorrespondingstakeholderhasbeencorrupted(ormarked
for corrupted by a delayed adversary). We will say the adversary is (1/2−δ)-bounded in a
particularexecutionforaparameterδ > 0ifitholdsthatthetotalstakeofthecorruptedkeys
divided by the total stake P s is less than 1/2−δ in all possible S (r). (Note the distinction
i i j
between this notion—a property of the execution—and that of a (1/2−δ)-initially-bounded
8
adversary, which refers to the initial distribution appearing in the genesis block.) If the above
is violated, we say the event Bad1/2−δ occurs for the given execution.
• Stake shift is bounded over short periods. Speciﬁcally, for any chain adopted by an honest
party, the observed shift in stake distribution between “nearby” preﬁxes of the chain are
bounded from above. See Deﬁnition 5.2 for a precise deﬁnition.
We note that the availability assumption (restricting honest parties from long periods of dis-
connection) stated above is very conservative and our protocol can tolerate much longer oﬄine
times depending on the course of the execution; nevertheless, for the sake of simplicity, we use
the above restriction. Finally, we note that in all of our proofs, whenever we say that a property
Q holds with high probability over all executions, we will in fact argue that Q ∨ Bad1/2−δ holds
with high probability over all executions. This captures the fact that we exclude environments and
adversaries that trigger Bad1/2−δ with non-negligible probability.
3 The Ouroboros Protocol: Overview of Design and Analysis
We ﬁrst provide a general overview of the approach to design and analyze our protocol. The
protocol’s analysis will depend on a number of parameters: (i.) k is the number of blocks a certain
message should have “on top of it” in order to be treated as part of the immutable history of the
ledger, (ii.) (cid:15),σ are parameters that bound adversarial stake and stake shift in the sense that the
adversary is (1/2−(cid:15))-initially bounded as well as (1/2−(cid:15)−σ)-bounded throughout the execution
and moreover stake shifts no more than σ occur over short enough time periods, (iii.) D is the
corruption delay that is imposed on the adversary, i.e., an honest stakeholder will be corrupted D
slots after the corresponding “corrupt” message is generated during an execution; (iv.) L is the
lifetime of the system, measured in slots; (v.) R is the length of an epoch, measured in slots (see
below for a discussion).
Wepresentourprotocoldescriptioninfourstages, successivelyimprovingtheadversarialmodel
it can withstand. In all stages an “ideal functionality” F is available to the participants. The
LS
functionality captures the resources that are available to the parties as preconditions for the secure
operation of the protocol (e.g., the genesis block will be speciﬁed by F ).
LS
Stage 1: Static stake; D = L = R. Intheﬁrststage, thetrustassumptionisstaticandremains
with the initial set of stakeholders; the execution is not further divided into epochs. There is an
initial stake distribution which is hardcoded into the genesis block that includes the public-keys of
the stakeholders, {(vk ,s )}n . Based on our restrictions on the environment, adversarial stake of
i i i=1
no more than 1/2−(cid:15) is assumed among those initial stakeholders. Speciﬁcally, the environment ini-
tially will allow the corruption of a number of stakeholders whose relative stake represents 1/2−(cid:15).
Theenvironmentallowspartycorruptionbyprovidingtokensoftheform(Corrupt,U)totheadver-
sary; note that due to the corruption delay imposed in this ﬁrst stage any further corruptions will
be against parties that have no stake initially and hence the corruption model is eﬀectively “static.”
F will subsequently sample ρ which will seed a “weighted by stake” stakeholder sampling and in
LS
this way lead to the election of a subset of m keys vk ,...,vk to form the committee that will
i1 iR
possess honest majority with overwhelming probability in R, (this uses the fact that the relative
stake possessed by malicious parties is 1/2−(cid:15); a linear dependency of R to (cid:15)−2 will be imposed at
thisstagetoguaranteeapplicabilityofstrongconcentrationbounds). Inmoredetail,thecommittee
will be selected implicitly by appointing a stakeholder with probability proportional to its stake to
eachoneoftheL = Rslots. Subsequently, stakeholderswillissueblocksfollowingtheschedulethat
9
is determined by the slot assignment. The longest chain rule will be applied and it will be possible
for the adversary to fork the blockchain views of the honest parties. Nevertheless, we will prove
with a novel combinatorial argument that the probability of a k-common preﬁx violation drops
√
exponentially in k, cf. Theorem 4.24. Similar reasoning will yield favorable guarantees of chain
growth and chain quality. An even more favorable analysis can be made against covert adversaries,
i.e., adversaries that prefer to remain “under the radar” (cf. Section 6).
Stage 2: Dynamic stake with a beacon, adversarial look-ahead E, epoch period of
R slots, and delay D ≈ 2R (cid:28) L. The central idea for the extension of the lifetime of the
above protocol is to consider the sequential composition of several invocations. We ﬁrst describe a
protocol which relies on a trusted beacon that emits a uniformly random string at regular intervals.
Speciﬁcally, the beacon, during slots {(j −1)·R+1,...,jR}, reveals the j-th random string that
seeds the leader election function for the following epoch. To simplify the relationship between
this stage and the next, which adopts a secure multiparty computation for randomness generation,
we expose the randomness beacon to the adversary E slots prior to exposure to honest parties;
this is the “adversarial look-ahead” parameter. The critical diﬀerence compared to the static stake
protocol is that the stake distribution is allowed to change and is drawn from the blockchain itself.
This means that the stake distribution adopted during the j-th epoch (with j ≥ 2) is determined
by the most recent block with time stamp less than (j −1)·R−k0 for an appropriate parameter
k0. (The generic parameter k0 appearing here is given a precise formula in the description of the
protocol.)
Regardingtheevolvingstakedistribution,transactionswillbecontinuouslygeneratedandtrans-
ferredbetweenstakeholdersviatheenvironment; playerswillincorporatepostedtransactionsinthe
blockchain-based ledgers that they maintain. In order to accommodate the new accounts that are
beingcreated, theF functionalityenablesanew(vk,sk)tobecreatedondemandandassignedto
LS
a new party U . Speciﬁcally, the environment can create new parties who will interact with F for
i LS
their public/secret-key in this way treating it as a trusted component that maintains the secret of
their wallet. Note that the adversary can interfere with the creation of a new party, corrupt it, and
supply its own (adversarially created) public-key instead. As before, the environment may request
transactions between stakeholder accounts and can also generate transactions in collaboration with
the adversary on behalf of the corrupted accounts. Recall that our assumption is that at any slot,
in the view of any honest player, the stakeholder distribution places (1/2+(cid:15)+σ) stake majority
with the honest players (note that diﬀerent honest players might perceive a diﬀerent stakeholder
distribution in a certain slot). Furthermore, the stake distribution is guaranteed to shift by at most
σ statistical distance over a certain number of slots—this permits honest players to obtain reliable
estimates on past stake distributions by examining portions of their blockchains which may have
adversarial blocks. The security proof can be seen as an induction in the number of epochs L/R
with the base case supplied by the proof of the static stake protocol. In the end we will argue that
in this setting, a (1/2−(cid:15)−σ) bound in adversarial stake is suﬃcient for security of a single draw
(and observe that the size of committee, m, now should be selected to overcome also an additive
term of size ln(L/R) given that the lifetime of the system includes such a number of successive
epochs). The corruption delay is set to D ≈ 2R (in fact, it can be set more precisely as a function
of E and k0), thus enabling the adversary to perform adaptive corruptions as long as these are not
instantaneous.
Stage 3: Dynamic stake without a beacon, epoch period of R slots, and delay D ≈ 2R (cid:28)
L. In the third stage, we remove dependence on the beacon by introducing a secure multiparty
10
protocol with “guaranteed output delivery” that eﬀectively simulates it. In this way, we can obtain
the long-livedness of the protocol as described in the stage 2 design but under the weaker assump-
tions of the stage 1 design, i.e., the mere availability of an initial random string and stakeholder
distributions with honest majority. The core idea is the following: given that we guarantee that an
honest majority among elected stakeholders will hold with very high probability, we can further use
this elected set as participants in an instance of a (simple) secure multiparty computation (MPC)
protocol. Naturally, this will require the choice of the length of the epoch to be suﬃcient so that
it can accommodate a run of the MPC protocol. From a security point of view, the main challenge
is to demonstrate that the MPC suitably simulates a beacon with the relaxation that the output
may become known to the adversary before it is known to the honest parties. A feature of this
stage—from a cryptographic design perspective—is the use of the ledger itself for the simulation of
a reliable broadcast that supports the MPC protocol.
Stage 4: Input endorsers, stakeholder delegates, anonymous communication. In the
ﬁnal stage of our design, we augment the protocol with two new roles for the entities that are
maintaining the ledger and consider the beneﬁts of anonymous communication. Input-endorsers
create a second layer of transaction endorsing prior to block inclusion. This mechanism enables
the protocol to withstand deviations such as selﬁsh mining and enables us to show that honest
behaviour is an approximate Nash equilibrium under reasonable assumptions regarding the costs
of running the protocol. Note that input-endorsers are assigned to slots in the same way that
slot leaders are, and inputs included in blocks are only acceptable if they are endorsed by an
eligible input-endorser. Second, the delegation feature allows stakeholders to transfer committee
participation to selected delegates that assume the responsibility of the stakeholders in running
the protocol (including participation to the MPC and issuance of blocks). Delegation naturally
gives rise to “stake pools” that can act in the same way as mining pools in bitcoin. Finally, we
observe that by including an anonymous communication layer we can remove the corruption delay
requirement that is imposed in our analysis. This is done at the expense of increasing the online
time requirements for the honest parties.4
4 Analysis of the Static Stake Protocol
4.1 Basic Concepts and Protocol Description
We begin by describing the blockchain protocol π in the “static stake” setting, where leaders
SPoS
are assigned to blockchain slots with probability proportional to their (ﬁxed) initial stake which
will be the eﬀective stake distribution throughout the execution. To simplify our presentation, we
abstract this leader selection process, treating it simply as an “ideal functionality” that faithfully
carries out the process of randomly assigning stakeholders to slots. In the following section, we
explain how to instantiate this functionality with a speciﬁc secure computation.
Weremarkthat—evenwithanidealleaderassignmentprocess—analyzingthestandard“longest
chain” preference rule in our PoS setting appears to require signiﬁcant new ideas. The challenge
arises because large collections of slots (epochs, as described above) are assigned to stakeholders at
once; while this has favorable properties from an eﬃciency (and incentive) perspective, it furnishes
the adversary a novel means of attack. Speciﬁcally, an adversary in control of a certain population
of stakeholders can, at the beginning of an epoch, choose when standard “chain update” broadcast
messages are delivered to honest parties with full knowledge of future assignments of slots to
4In follow-up work we show how the same can be achieved eﬃciently, see [22].
11
stakeholders. Additionally, an adversary in control of a particular slot may freely generate multiple
blocks associated with the slot, perhaps committing to distinct prior blockchains, and strategically
advertise them to honest players. In contrast, adversaries in typical PoW settings are constrained
to make decisions in an online fashion and cannot freely generate multiple blocks. We remark that
this can have a dramatic eﬀect on the ability of an adversary to produce alternate chains; see the
discussion on “forkable strings” below for detailed discussion.
In the static stake case, we assume that a ﬁxed collection of n stakeholders U ,...,U interact
1 n
throughout the protocol. Stakeholder U possesses s stake before the protocol starts. For each
i i
stakeholder U a veriﬁcation and signing key pair (vk ,sk ) for a prescribed signature scheme is
i i i
generated; we assume without loss of generality that the veriﬁcation keys vk ,... are known by all
1
stakeholders. Before describing the protocol, we establish basic deﬁnitions following the notation
of [28].
Deﬁnition 4.1 (Genesis Block). The genesis block B contains the list of stakeholders identiﬁed
0
by their public-keys, their respective stakes (vk ,s ),...,(vk ,s ) and auxiliary information ρ.
1 1 n n
With foresight we note that the auxiliary information ρ will be used to seed the slot leader
election process.
Deﬁnition 4.2 (State). A state is a string st ∈ {0,1}λ.
Deﬁnition 4.3 (Block). A block B generated at a slot sl ∈ {1,...,R} contains the current state
st ∈ {0,1}λ, data d ∈ {0,1}∗, the slot number sl and a signature σ = Sign (st,d,sl) computed
sk
under sk corresponding to the stakeholder U generating the block at that slot.
Deﬁnition 4.4 (Blockchain). A blockchain (or simply chain) relative to the genesis block B is a
0
sequence of blocks B ,...,B associated with a strictly increasing sequence of slots for which the
1 n
state st of B is equal to H(B ), where H is a prescribed collision-resistant hash function. The
i i i−1
length of a chain len(C) = n is its number of blocks. The block B is the head of the chain, denoted
n
head(C). We treat the empty string ε as a legal chain and by convention set head(ε) = ε.
Let C be a chain of length n and k be any non-negative integer. We denote by Cdk the chain
resulting from removal of the k rightmost blocks of C. If k ≥ len(C) we deﬁne Cdk = ε. We let
C (cid:22) C indicate that the chain C is a preﬁx of the chain C . We let C[k] = B and adopt interval
1 2 1 2 k
notationtoreﬂectcontiguousportionsofachain: speciﬁcally, C[k : ‘] = B ,...,B andparentheses
k ‘
are used to indicate removal of endpoint so that, for example, C[k : ‘) = B ,...,B .
k ‘−1
Deﬁnition 4.5 (Epoch). An epoch is a set of R adjacent slots S = {1,...,R}.
(The relevant value R is a parameter of the protocol we analyze in this section.)
Deﬁnition 4.6 (Adversarial Stake Ratio). Let U be the set of stakeholders controlled by an
A
adversary A. Then the adversarial stake ratio is deﬁned as
P s
α = j∈UA j ,
Pn s
i=1 i
where n is the total number of stakeholders and s is stakeholder U ’s stake.
i i
Reﬂecting corruption delay. In general, we consider adversaries subject to a corruption delay,
which imparts a delay between the time when the adversary selects a party for corruption and the
time when the party actually passes into adversarial control. With such an adversary, parties which
12
have been identiﬁed for corruption but are not yet under adversarial control are counted in the
adversarial stake ratio.
Unambiguous stake distributions. In principle, it is possible for various honest parties to disagree
onthecurrent(oraprevious)stakedistribution. Weavoidtheseambiguitiesbyexplicitlyidentifying
a stake distribution when considering adversarial stake ratio.
Slot Leader Selection. In the protocol described in this section, for each 0 < j ≤ R, a slot
leader E is determined who has the (sole) right to generate a block at sl . Speciﬁcally, for each
j j
slot a stakeholder U is selected as the slot leader with probability p proportional to its stake
i i
registered in the genesis block B ; these assignments are independent between slots. In this static
0
stake case, the genesis block as well as the procedure for selecting slot leaders are determined by an
ideal functionality F , deﬁned in Figure 1. This functionality is parameterized by the set of initial
LS
stakeholders{(U ,s ),...,(U ,s )}assigningtoeachstakeholderitsrespectivestake,adistribution
1 1 n n
D that provides auxiliary information ρ and a leader selection function F deﬁned below.
Deﬁnition 4.7 (Leader Selection Process). A leader selection process with respect to stakeholder
distribution S = {(vk ,s ),...,(vk ,s )}, (D,F) is a pair consisting of a distribution and a deter-
1 1 n n
ministic function such that, when ρ ← D it holds that for all sl ∈ {sl ,...,sl }, F(S,ρ,sl ) outputs
j 1 R j
U ∈ {U ,...,U } with probability
i 1 n
s
p = i
i Pn s
k=1 k
where s is the stake held by stakeholder U (we call this “weighting by stake”); furthermore the
i i
family of random variables {F(S,ρ,sl )}R are independent.
j j=1
We note that sampling proportional to stake can be implemented in a straightforward manner.
For instance, a simple process operates as follows. Let p˜ = s /Pn s . For each i = 1,...,n−1,
i i j=i j
provided that no stakeholder has yet been selected, the process ﬂips a p˜-biased coin; if the result
i
of the coin is 1, the party U is selected for the slot and the process is complete. (Note that p˜ = 1,
i n
so the process is certain to complete with a unique leader.) When we implement this process as
a function F(·), suﬃcient randomness must be allocated to simulate the biased coin ﬂips. If we
implement the above with λ precision for each individual coin ﬂip, then selecting a stakeholder will
require ndlogλe random bits in total. Note that using a pseudorandom number generator (PRG)
one may use a shorter “seed” string and then stretch it using the PRG to the appropriate length.
A Protocol in the F [mode]-hybrid model. We start by describing a simple PoS based
LS
blockchain protocol considering static stake in the F [SIG]-hybrid model, i.e., where the genesis
LS
block B (and consequently the slot leaders) are determined by the ideal functionality F [SIG].
0 LS
F [SIG] provides the stakeholders with a genesis block containing a stake distribution indexed by
LS
signature veriﬁcation keys generated by a EUF-CMA signature scheme, while F [F ] obtains
LS DSIG
such keys from a signature ideal functionality F . This subtle diﬀerence comes into play when
DSIG
describing an ideal version of π used in an intermediate hybrid argument of the security proof,
SPoS
which will be discussed in Section 4.2. The stakeholders U ,...,U interact among themselves and
1 n
with F through Protocol π described in Figure 2.
LS SPoS
We are interested in applications where transactions are inserted in the ledger. In our analysis,
we will consider simple coin transfer transactions of the format “stakeholder vk transfers to stake-
1
holders vk an amount of x coins.” A transaction will consist of a transaction template tx of this
2
format accompanied by a signature of tx under the signing key corresponding to vk . We deﬁne a
1
valid transaction as follows:
13
Functionality F [mode]
LS
F [mode]incorporatesthediﬀuseandkey/transactionfunctionalityF fromSection2andisparam-
LS D+KT
eterizedbytherespectivestakesoftheinitialstakeholdersS ={(U ,s ),...,(U ,s )},adistributionD
0 1 1 n n
and a function F so that (D,F) is a leader selection process. In addition, F [mode] is parameterized by
LS
mode, which determines how signature veriﬁcation keys are generated. When F [mode] is instantiated
LS
with mode = SIG (resp. mode = F ) it is denoted F [SIG] (resp. F [F ]). F interacts with
DSIG LS LS DSIG LS
stakeholders as follows:
• Signature Key Pair Generation: F [SIG] generates signing and veriﬁcation keys sk ,vk for
LS i i
stakeholder U by executing KG(1κ) for i = 1,...,n. F [F ] generates (sk ,vk ) by querying
i LS DSIG i i
F (Figure 3) with (KeyGen,sid ) on behalf of U (with a unique session identiﬁer sid related
DSIG i i i
to U ) and setting (sk = sid ,vk = v ) (received from F as response) for i = 1,...,n. In
i i i i i DSIG
either case, F [mode] sets S0 ={(vk ,s ),...,(vk ,s )}.
LS 0 1 1 n n
• Genesis Block GenerationUponreceiving(genblock req,U )fromstakeholderU ,F proceeds
i i LS
as follows. If ρ has not been set, F samples ρ ← D. In any case, F sends (genblock,S0,ρ,F)
LS LS 0
to U .
i
• Signatures and Veriﬁcation. For signing and veriﬁcation requests on behalf of user U ,
i
F [F ] provides access to the corresponding F interface, while F [SIG] utilizes (sk ,vk )
LS DSIG DSIG LS i i
to respond restricting access of signing to the respective secret-key owners.
Figure 1: Functionality F [mode].
LS
Deﬁnition 4.8 (Valid Transaction). A pair (tx,σ) is considered a valid transaction by a veriﬁer
V if the following holds:
• The transaction template tx is of the format “stakeholder vk transfers to stakeholder vk an
1 2
amount of x coins with transaction serial number sn” where vk is a veriﬁcation key contained
1
in the current stake distribution S and x ∈ Z.
• Vrf (σ,tx) = 1.
vk1
• The ledger cannot contain two transactions issued from the same stakeholder with the same
serial number sn; thus a transaction is only valid with respect to a blockchain if no previous
transaction (from the same stakeholder) has the same serial number.
For simplicity we assume that all properly signed transactions are valid and are included in
the ledger; in particular this means that there is a way to parse the ledger and disambiguate any
recorded double/overspents (e.g., following the order that is imposed by the ledger).
Given Deﬁnitions 4.4 and 4.8, we deﬁne a valid chain as a blockchain (according to Deﬁni-
tion 4.4) where all transactions contained in every block are valid (according to Deﬁnition 4.8).
The protocol relies on a maxvalid (C,C) function that chooses a chain given the current chain C
S
and a set of valid chains C that are available in the network. In the static case we analyze the
simple “longest chain” rule. (In the dynamic case the rule is parameterized by a common chain
length; see Section 5.)
Function maxvalid(C,C): Returns the longest chain from C∪{C}. Ties are broken in
favor of C, if it has maximum length, or arbitrarily otherwise.
14
Protocol π
SPoS
π is a protocol run by stakeholders U ,...,U interacting with F [SIG] over a sequence of slots
SPoS 1 n LS
S ={1,...,R}. π proceeds as follows:
SPoS
1. Initialization Stakeholder U ∈ {U ,...,U }, receives from the key registration interface its
i 1 n
public and secret key. Then it receives the current slot from the diﬀuse interface and in case it
is sl it sends (genblock req,U ) to F [SIG], receiving (genblock,S ,ρ,F) as answer. U sets the
1 i LS 0 i
local blockchain C =B =(S ,ρ) and the initial internal state st=H(B ). Otherwise, it receives
0 0 0
fromthekeyregistrationinterfacetheinitialchainC,setsthelocalblockchaintoC andtheinitial
internal state st=H(head(C)).
2. Chain Extension For every slot sl ∈S, every stakeholder U performs the following steps:
j i
(a) U receives from the environment the transaction data d ∈ {0,1}∗ to be inserted into the
i
blockchain.
(b) CollectallvalidchainsreceivedviabroadcastintoasetC,verifyingthatforeverychainC0 ∈
CandeveryblockB0 =(st0,d0,sl0,σ0)∈C0 itholdsthatVrf (σ0,(st0,d0,sl0))=1,wherevk0
vk0
is the veriﬁcation key of the stakeholder U0 =F(S ,ρ,sl0). U computes C0 =maxvalid(C,C),
0 i
sets C0 as the new local chain and sets state st=H(head(C0)).
(c) If U is the slot leader determined by F(S ,ρ,sl ), it generates a new block B =(st,d,sl ,σ)
i 0 j j
wherestisitscurrentstate,d∈{0,1}∗ isthetransactiondataandσ =Sign (st,d,sl )isa
signature on (st,d,sl ). U computes C0 =C|B, broadcasts C0, sets C0 as thesnkiew localjchain
j i
and sets state st=H(head(C0)).
3. Transaction generation Upon receiving a transaction template tx from the environment, U
i
computes σ =Sign (tx) provided that tx is consistent with the state of the ledger in the view of
U ) and sends (tx,σsk)i to the environment.
i
Figure 2: Protocol π .
SPoS
4.2 Transition to the Ideal Protocol
As a ﬁrst step of the security analysis of π , we will introduce an idealized protocol π and
SPoS iSPoS
present an intermediate hybrid argument that shows that it is computationally indistinguishable
from π . Instead of relying on F [SIG] and an EUF-CMA signature scheme, π operates
SPoS LS iSPoS
with an ideal signature scheme. To that end, π interacts with F [F ] for obtaining signing
iSPoS LS DSIG
and veriﬁcation keys for the ideal signature scheme employed in the protocol. In the next sec-
tions, we will prove that π is secure through a series of combinatorial arguments. This hybrid
iSPoS
approach insulates these combinatorial arguments from the speciﬁc details of the underlying sig-
nature schemes used to instantiate π and the biases that these schemes might introduce in the
SPoS
distributions of π .
SPoS
First, in Figure 3, we present Functionality F as deﬁned in [16], where it is also shown that
DSIG
EUF-CMA signature schemes realize F . Notice that this fact will be used to show that our
DSIG
idealized protocol can actually be realized based on practical digital signature schemes (such as
DSA and ECDSA) and ultimately that π is indistinguishable from π .
iSPoS SPoS
The idealized protocol π is run by the stakeholders interacting with F [F ] and F .
iSPoS LS DSIG DSIG
Basically,π behavesexactlyasπ exceptforcallstoVrf (σ)andSign (m). Namely,instead
iSPoS SPoS vk sk
of locally computing Sign (m), U sends (Sign,sid,m) to F , receiving (Signature,sid,m,σ)
ski i DSIG
and outputting σ as the signature. Moreover, instead of locally computing Vrf (σ,m), U sends
vk0 i
(Verify,sid ,m,σ,v0) to F (where v0 corresponds to veriﬁcation key vk0), outputting the value
i DSIG
f received in message (Veriﬁed,sid ,m,f). Protocol π is described in Figure 4. This idealized
i iSPoS
description will be further developed when arguing about the dynamic stake case, where additional
15
Functionality F
DSIG
F interacts with stakeholders as follows:
DSIG
• KeyGenerationUponreceivingamessage(KeyGen,sid)fromastakeholderU ,verifythatsid=
i
(U ,sid0)forsomesid0. Ifnot, thenignoretherequest. Else, hand(KeyGen,sid)totheadversary.
i
Upon receiving (VeriﬁcationKey,sid,v) from the adversary, output (VeriﬁcationKey,sid,v) to U ,
i
and record the pair (U ,v).
i
• Signature Generation Upon receiving a message (Sign,sid,m) from U , verify that sid =
i
(U ,sid0) for some sid0. If not, then ignore the request. Else, send (Sign,sid,m) to the ad-
i
versary. Upon receiving (Signature,sid,m,σ) from the adversary, verify that no entry (m,σ,v,0)
isrecorded. Ifitis,thenoutputanerrormessagetoU andhalt. Else,output(Signature,sid,m,σ)
i
to U , and record the entry (m,σ,v,1).
i
• Signature Veriﬁcation Upon receiving a message (Verify,sid,m,σ,v0) from some stakeholder
U , hand (Verify,sid,m,σ,v0) to the adversary. Upon receiving (Veriﬁed,sid,m,φ) from the ad-
i0
versary do:
1. If v0 = v and the entry (m,σ,v,1) is recorded, then set f = 1. (This condition guarantees
completeness: Iftheveriﬁcationkeyv0 istheregisteredoneandσ isalegitimatelygenerated
signature for m, then the veriﬁcation succeeds.)
2. Else, if v0 = v, the signer is not corrupted, and no entry (m,σ0,v,1) for any σ0 is recorded,
thensetf =0andrecordtheentry(m,σ,v,0). (Thisconditionguaranteesunforgeability: If
v0 istheregisteredone,thesignerisnotcorrupted,andneversignedm,thentheveriﬁcation
fails.)
3. Else, if there is an entry (m,σ,v0,f0) recorded, then let f = f0. (This condition guaran-
tees consistency: All veriﬁcation requests with identical parameters will result in the same
answer.)
4. Else, let f =φ and record the entry (m,σ,v0,φ).
Output (Veriﬁed,sid,m,f) to U .
i0
Figure 3: Functionality F .
DSIG
building blocks must be considered in the idealized protocol.
Thefollowingpropositionisanimmediatecorollaryoftheresultsin[16]showingthatEUF-CMA
signature schemes realize F .
DSIG
Proposition 4.9. For each PPT A,Z it holds that there is a PPT S so that
EXECFLS[SIG] (λ) and EXECFLS[FDSIG](λ)
πSPoS,A,Z πiSPoS,S,Z
are computationally indistinguishable.
In light of the above proposition in the remaining of the analysis we will focus on the properties
of the protocol π (note that this implication does not apply to any5 possible property one
iSPoS
might consider in an execution for π ; nevertheless the properties we will prove for π
iSPoS iSPoS
are all veriﬁable by the environment Z and as a result they can be inherited by π due to
SPoS
proposition 4.9).
4.3 The Fork Abstraction
In our security arguments we routinely use elements of {0,1}n to indicate which slots—among
a particular window of slots of length n—have been assigned to adversarial stakeholders. When
5An example of such a property would be a property testing a non-trivial fact about the parties’ private states.
16
Protocol π
iSPoS
π is a protocol run by stakeholders U ,...,U interacting with F [F ] over a sequence of slots
iSPoS 1 n LS DSIG
S ={1,...,R}. π proceeds as follows:
iSPoS
1. Initialization Stakeholder U ∈ {U ,...,U }, receives from the key registration interface its
i 1 n
public and secret key. Then it receives the current slot from the diﬀuse interface and in case it
is sl it sends (genblock req,U ) to F [F ], receiving (genblock,S ,ρ,F) as answer. U sets the
1 i LS DSIG 0 i
local blockchain C =B =(S ,ρ) and the initial internal state st=H(B ). Otherwise, it receives
0 0 0
fromthekeyregistrationinterfacetheinitialchainC,setsthelocalblockchaintoC andtheinitial
internal state st=H(head(C)).
2. Chain Extension For every slot sl ∈S, every stakeholder U performs the following steps:
j i
(a) Collect all valid chains received via broadcast into a set C, verifying that for every
chain C0 ∈ C and every block B0 = (st0,d0,sl0,σ0) ∈ C0 it holds that F answers
DSIG
with (Veriﬁed,sid,(st0,d0,sl0),1) upon being queried with (Verify,sid,(st0,d0,sl0),σ0,vk0),
where vk0 is the veriﬁcation key of the stakeholder U0 = F(S ,ρ,sl0). U computes
0 i
C0 =maxvalid(C,C), sets C0 as the new local chain and sets state st=H(head(C0)).
(b) If U is the slot leader determined by F(S ,ρ,sl ), it generates a new block B =(st,d,sl ,σ)
i 0 j j
where st is its current state, d ∈ {0,1}∗ is the transaction data and σ is obtained from
F ’s answer (Signature,sid,(st,d,sl ),σ) upon being queried with (Sign,sid ,(st,d,sl )).
DSIG j i j
U computes C0 = C|B, broadcasts C0, sets C0 as the new local chain and sets state st =
i
H(head(C0)).
3. Transaction generation Given a transaction template tx, U returns σ obtained from F ’s
i DSIG
answer(Signature,sid ,tx,σ)uponbeingqueriedwith(Sign,sid ,tx),providedthattxisconsistent
i i
with the state of the ledger in the view of U .
i
Figure 4: Protocol π .
iSPoS
strings have this interpretation we refer to them as characteristic strings.
Deﬁnition 4.10 (Characteristic String). Fix an execution E with genesis block B , adversary A,
0
and environment Z. Let S = {i+1,...,i+n} denote a sequence of slots of length |S| = n. The
characteristic string w ∈ {0,1}n of S is deﬁned so that w = 1 if and only if the adversary controls
k
the slot leader of slot i+k. For such a characteristic string w ∈ {0,1}∗ we say that the index i is
adversarial if w = 1 and honest otherwise.
i
We start with some intuition for our approach to analyze the protocol. Let w ∈ {0,1}n be
a characteristic string for a sequence of slots S. Among the fundamental properties we wish to
ensure of our protocol (CP, ∃CQ, and HCG), common preﬁx (CP) will require the most technical
eﬀort. In this section, we develop a graph-theoretic abstraction to facilitate reasoning about these
properties, principally motivated by the task of establishing CP.
To motivate this, consider two observers that (i.) go oﬄine immediately prior to the com-
mencement of a sequence of slots S, (ii.) have adopted the same current chain C prior to the
0
commencement of S, and (iii.) come back online at the last slot of S and request an update of their
chain. Afundamentalconcerninouranalysisisthepossibilitythatsuchobserverscanbepresented
with a “diverging” view over the sequence S: speciﬁcally, the possibility that the adversary can
force the two observers to adopt two diﬀerent chains C ,C whose common preﬁx is exactly C . We
1 2 0
observe that not all characteristic strings permit this. For instance the (entirely honest) string 0n
ensuresthatthetwoobserverswilladoptthesamechainC whichwillconsistofnnewblocksontop
ofthecommonpreﬁxC . Ontheotherhand,otherstringsdonotguaranteesuchcommonextension
0
of C ; in the case of 1n, it is possible for the adversary to produce two completely diﬀerent histories
0
17
during the sequence of slots S and thus furnish to the two observers two distinct chains C ,C that
1 2
only share the common preﬁx C . The bulk of the proof that the Ouroboros protocol achieves CP
0
relies on the fact that characteristic strings permitting such “forkings” are quite rare—indeed, we
√
show that they have density 2−Ω( n) so long as the fraction of adversarial slots is 1/2−(cid:15).
To reason about the protocol at a more abstract level, we deﬁne below a formal notion of
“fork” that captures the relationship between the chains adopted by honest slot leaders during an
execution of the protocol π . In preparation for the deﬁnition, we recall that honest players
iSPoS
always choose to extend a maximum length chain among those available to the player on the
network. Furthermore, if such a maximal chain C includes a block B previously broadcast by an
honest player, the preﬁx of C prior to B must entirely agree with the chain (terminating at B)
broadcast by this previous honest player. This “conﬂuence” property follows immediately from the
factthatthestateofanyhonestblockeﬀectivelycommitstoauniquechainbeginningatthegenesis
block. To conclude, any chain C diﬀused by an honest player must begin with a chain produced
by a previously honest player (or, alternatively, the genesis block), continue with a possibly empty
sequence of adversarial blocks and, ﬁnally, terminate with an honest block. It follows that the
chains broadcast by honest players form a natural directed tree. The fact that honest players
reliably broadcast their chains and always build on the longest available chain introduces a second
important property of this tree: the “depths” of the various honest blocks added by honest players
during the protocol must all be distinct.
Ofcourse,theactualchainsinducedbyanexecutionofπ arecomprisedofblockscontaining
iSPoS
a variety of data that are immaterial for reasoning about forking or the other elementary chain
properties. For this reason the formal notion of fork below merely reﬂects the directed tree formed
by the relevant chains and the identities of the players—expressed as indices in the string w—
responsible for generating the blocks in these chains.
Forks and forkable strings. We deﬁne, below, the basic combinatorial structures we use to
reason about the possible views observed by honest players during a protocol execution with this
characteristic string.
t
2 3
ˆ
t
0 2 4 6 8 9
1
4 5
w = 0 1 0 1 0 0 1 1 0
Figure 5: A fork F for the string w = 010100110; vertices appear with their labels and honest
verticesarehighlightedwithdoubleborders. Notethatthedepthsofthe(honest)verticesassociated
with the honest indices of w are strictly increasing. Two tines are distinguished in the ﬁgure: one,
labeled tˆ, terminates at the vertex labeled 9 and is the longest tine in the fork; a second tine t
terminates at the vertex labeled 3. The quantity gap(t) indicates the diﬀerence in length between t
and tˆ; in this case gap(t) = 4. The quantity reserve(t) = |{i | ‘(v) < i ≤ |w| and w = 1}| indicates
i
the number of adversarial indices appearing after the label of the last honest vertex v of the tine;
in this case reserve(t) = 3. As each leaf of F is honest, F is closed.
18
Deﬁnition 4.11 (Fork). Let w ∈ {0,1}n and let H = {i | w = 0} denote the set of honest indices.
i
A fork for the string w is a directed, rooted tree F = (V,E) with a labeling ‘ : V → {0,1,...,n} so
that
• each edge of F is directed away from the root;
• the root r ∈ V is given the label ‘(r) = 0;
• the labels along any directed path in the tree are strictly increasing;
• each honest index i ∈ H is the label of exactly one vertex of F;
• the function d : H → {1,...,n}, deﬁned so that d(i) is the depth in F of the unique vertex v
for which ‘(v) = i, is strictly increasing. (Speciﬁcally, if i,j ∈ H and i < j, then d(i) < d(j).)
As a matter of notation, we write F ‘ w to indicate that F is a fork for the string w. We say that
a fork is trivial if it contains a single vertex, the root.
Deﬁnition 4.12 (Tines, depth, and height). A path in a fork F originating at the root is called a
tine. For a tine t we let length(t) denote its length, equal to the number of edges on the path. For
a vertex v, we let depth(v) denote the length of the (unique) tine terminating at v. The height of
a fork (as usual for a tree) is deﬁned to be the length of the longest tine.
We overload the notation ‘() so that it applies to tines, by deﬁning ‘(t) (cid:44) ‘(v), where v is
the terminal vertex on the tine t. We borrow the “truncation operator,” described earlier in the
paper for chains: for a tine t we let tdk denote the tine obtained by removing the last k edges; if
length(t) ≤ k, we deﬁne tdk to consist solely of the root.
If a vertex v of a fork is labeled with an adversarial index (i.e., w = 1) we say that the vertex
‘(v)
is adversarial; otherwise, we say that the vertex is honest. For convenience, we declare the root
vertex to be honest. We extend this terminology to tines: a tine is honest if it terminates with an
honest vertex and adversarial otherwise. By this convention the empty tine t is honest.
(cid:15)
The fork of honestly constructed chains. As discussed above, with an execution E of π
iSPoS
one can naturally associate a characteristic string w and a fork F ‘ w corresponding to the chains
D
constructed and diﬀused by honest participants during the protocol. See Figure 5 for an example,
which also demonstrates some of the quantities deﬁned above and in the remainder of this section.
The fork shown in the ﬁgure reﬂects an execution in which (i.) the honest player associated with
the ﬁrst slot builds directly on the genesis block (as it must), (ii.) the honest player associated with
the third slot is shown a chain of length 1 produced by the adversarial player of slot 2 (in addition
to the honestly generated chain of step (i.)), which it elects to extend, (iii.) the honest player
associated with slot 5 is shown a chain of length 2 building on the chain of step (i.) augmented
with a further adversarial block produced by the player of slot 4, etc.
Weremarkthatthetightcorrespondencedescribedabovebetweenforksandexecutionsrequires
that a slot is marked as adversarial if the owner of that slot ever fell under adversarial control
during the protocol; this is one direct indication of the challenge of “long-range attacks” which
involve corruption of slot leaders long after they have been awarded leadership. In our long-lived
protocols, such attacks are mitigated by a bounded-depth longest-chain rule which permits analysis
of forks whose characteristic strings are determined by the corruption schedule of an adversary over
a bounded period of time.
We begin by deﬁning a natural notion of inclusion for two forks:
19
Deﬁnition 4.13 (Fork preﬁxes). If w is a preﬁx of the string w0 ∈ {0,1}∗, F ‘ w, and F0 ‘ w0,
we say that F is a preﬁx of F0, written F v F0, if F is a consistently-labeled subgraph of F0.
Speciﬁcally, every vertex and edge of F appears in F0 and, furthermore, the labels given to any
vertex appearing in both F and F0 are identical.
IfF v F0, eachtineofF appearsasthepreﬁxofatineinF0. Inparticular, thelabelsappearing
on any tine terminating at a common vertex are identical and, moreover, the depth of any honest
vertex appearing in both F and F0 is identical.
In many cases, it is convenient to work with forks that do not “commit” anything beyond ﬁnal
honest indices.
Deﬁnition 4.14 (Closed forks). A fork is closed if each leaf is honest. By convention the trivial
fork, consisting solely of a root vertex, is closed.
Note that the fork F discussed above of corresponding to honestly created chains is closed:
D
Everychainconstructedbyanhonestplayernaturallyterminateswithblockbroadcastinanhonest
slot. We remark that a closed fork has a unique longest tine (as all maximal tines terminate with
an honest vertex, and these must have distinct depths). Note, additionally, that if wˇ is a preﬁx of
w and F ‘ w, then there is a unique closed fork Fˇ ‘ wˇ for which Fˇ v F. In particular, taking
wˇ = w, we note that for any fork F ‘ w, there is a unique closed fork F ‘ w for which F v F; in
this case we say that F is the closure of F.
The fork of adopted chains. Consider now the valid chains adopted by the honest participants
oftheprotocol. Thissetclearlyincludesallchainsconstructed(anddiﬀused)byhonestparticipants;
on the other hand, it may contain additional valid chains delivered by the adversary to honest
participants. In particular, we may associate a fork F ‘ w with these adopted chains and note
A
that F v F . The fork F is not, in general, closed. Note, however, that maximal tines in this
D A A
fork—as they have been adopted by an honest player according to the longest chain rule—must
have length no less than any chain previously diﬀused by an honest player. We begin by precisely
deﬁning this notion.
Deﬁnition 4.15 (Viability). Let F ‘ w be a fork for a string w ∈ {0,1}n and let t be a tine of F.
We say that t is viable if, for all honest indices h ≤ ‘(t), we have
d(h) ≤ length(t).
(Recall that ‘(t) is the label of the terminal vertex of t.)
If t is viable, an honest participant (or observer) witnessing the execution at time ‘(t)—if
provided the tine t along with all honest tines generated up to time ‘(t)—could conceivably select
t via the maxvalid() rule. Observe that any honest tine is viable: by deﬁnition, the depth of the
terminal vertex of an honest tine exceeds that of all prior honest vertices. As remarked above, all
maximal tines appearing in F are viable.
A
4.3.1 The Abstract Chain Properties
Let w ∈ {0,1}n be a characteristic string. We deﬁne the following properties of w which are direct
analogues of the general protocol properties deﬁned above. Given a tine t and a sequence of slots S
suchthat‘(t) ≥ maxS,werefertoa“portionoftspanningS”asthemaximumsubgrapht0 oftsuch
that ‘(v) ∈ S ∧v ∈ t =⇒ v ∈ t0. We use the notation t(S) to denote this subgraph. We continue
20
to use interval notation for sequences of slots: that is, [sl : sl ] = {sl ,...,sl } and parentheses in
1 2 1 2
place of brackets indicate that the endpoint is left out. Thus [sl : sl ) = {sl ,...,sl −1}. As a
1 2 1 2
ﬁnal matter of notation, we often elide the parentheses in expressions such as t([sl ,sl ]), simply
1 2
writing t[sl ,sl ]. We will refer to a “portion of t spanning s slots” when the particular sequence of
1 2
slots is not speciﬁed.
• Common Preﬁx (cp); with parameter k ∈ N. A characteristic string w possesses k-cp if,
for every fork F ‘ w and every pair of viable tines t and t of F for which ‘(t ) ≤ ‘(t ), the
1 2 1 2
tine tdk is a preﬁx of t . (Equivalently, length(t )−length(t ∩t ) ≤ k, where t ∩t denotes
1 2 1 1 2 1 2
the common preﬁx of the two tines.)
• Honest-Bounded Chain Growth (hcg); with parameters τ ∈ (0,1] and s ∈ N. A
characteristic string w possesses hcg with parameters τ and s if, for every fork F ‘ w, every
viabletinetofF,andeveryhonestvertexv ontforwhich‘(v)+s ≤ ‘(t),thepatht(‘(v),‘(t)]
contains at least τs vertices.
• Chain Growth (cg); with parameters τ ∈ (0,1] and s ∈ N. A characteristic string
w possesses (τ,s)-cg if, for every fork F ‘ w and every viable tine t of F, any portion of t
spanning s slots contains at least τs vertices.
• Existential Chain Quality (∃cq); with parameter s ∈ N. A characteristic string w
possesses s-∃cq if, for every fork F ‘ w and every viable tine t of F, any portion of t spanning
s slots contains at least one honest vertex.
4.3.2 Probabilistic Preliminaries
Anticipating the proofs in the next few sections, we record a Chernoﬀ–Hoeﬀding bound and an
elementary stochastic dominance argument.
Theorem 4.16 (Chernoﬀ–Hoeﬀdingbound; see, e.g.,[33]). Let X ,...,X be independent random
1 T
variables with X ∈ [0,1]. Let X = PT X and µ = E[X]. Then, for all δ ≥ 0,
i i=1 i
Pr[X ≥ (1+δ)µ] ≤ e−2δ+2δµ and Pr[X ≤ (1−δ)µ] ≤ e−δ22µ.
Additionally, for any Λ > 0,
Pr[X ≥ µ+Λ] ≤ e−2Λ2/T and Pr[X ≤ µ−Λ] ≤ e−2Λ2/T .
Deﬁnition 4.17. For two elements x,y ∈ {0,1}n, we write x ≤ y if, for each i, x ≤ y . With this
i i
partial order, we deﬁne a notion of monotone subsets of {0,1}n: A subset E ⊆ {0,1}n is monotone
if, for each pair x,y ∈ {0,1}n, x ∈ E and x ≤ y implies that y ∈ E. Let X and Y be two random
variables taking values in {0,1}n. We write X ≺ Y if Pr[X ∈ E] ≤ Pr[Y ∈ E] for any monotone
set E. In this case, we say that Y stochastically dominates X.
Lemma 4.18. Let X = (X ,...,X ) be a family of random variables taking values in {0,1} with
1 n
the property that, for each i > 0, E[X | X ,...,X ] ≤ p. Let B = (B ,...,B ) be a family of
i 1 i−1 1 n
independent random variables, taking values in {0,1}, for which E[B = 1] = p. Then X ≺ B.
i
Proof. We proceed by induction. The statement is clear for n = 1. In general, consider a random
variableX satisfyingtheconditionsofthetheoremandtakingvaluesin{0,1}n+1; letE ⊂ {0,1}n+1
be a monotone event. We wish to prove that Pr[X ∈ E] ≤ Pr[B ∈ E].
21
We write X = (Y,Z), where Y takes values in {0,1}n and Z in {0,1}. By induction, we may
assume that Y ≺ (B ,...,B ). Consider the events
1 n
E = {(y ,...,y ) | (y ,...,y ,0) ∈ E} and E = {(y ,...,y ) | (y ,...,y ,1) ∈ E};
0 1 n 1 n 1 1 n 1 n
observe that the monotonicity of E implies that E ⊆ E and that E ,E are monotone. To study
0 1 0 1
Pr[X ∈ E], for an element y = (y ,...,y ) ∈ {0,1}n deﬁne
1 n
q(y) = Pr[X ∈ E | Y = y].
Observe that Pr[X ∈ E] = E[q(Y)] and, recalling that E ⊂ E , that
0 1
y ∈ E ⇒ q(y) = 1,
0
y ∈ E \E ⇒ q(y) ≤ p by assumption, and
1 0
y 6∈ E ⇒ q(y) = 0.
1
We conclude that
Pr[X ∈ E] ≤ Pr[Y ∈ E ]+p·Pr[Y ∈ E \E ] = pPr[Y ∈ E ]+(1−p)Pr[Y ∈ E ]
0 1 0 1 0
≤ pPr[(B ,...,B ) ∈ E ]+(1−p)Pr[(B ,...,B ) ∈ E ] (1)
1 n 1 1 n 0
= Pr[(B ,...,B ) ∈ E ]+pPr[(B ,...,B ) ∈ E \E ] = Pr[B ∈ E],
1 n 0 1 n 1 0
as desired. The inequality of line (1) follows by the induction hypothesis.
4.4 Chain Quality
Lemma 4.19 (AbstractExistentialChainQuality). Consider a characteristic string w = w ...w
1 L
drawn in {0,1}L so that each w is independently assigned the value 1 with probability 1/2−(cid:15) for
i
some (cid:15) ∈ (0,1/2). Then, for s > 0,
(cid:16) (cid:17)
Pr[w does not satisfy s-∃cq] ≤ (cid:15) (s;L,(cid:15)) (cid:44) ((cid:15)−2+3)/2 Lexp(−2(cid:15)2s).
∃cq
Proof. An s-∃cq violation for w consists of a fork F ‘ w and a viable tine t for which there is a
pair of indices sl and sl so that sl +s ≤ sl ≤ ‘(t) and t(sl : sl ] contains no honest vertices.
1 2 1 2 1 2
For such a violation, let sl∗ denote the largest index of an honest vertex in t[0 : sl ]—note that the
1 1
root of F is honest by ﬁat so that sl∗ is well-deﬁned. Similarly, let sl∗ denote the smallest index
1 2
for which sl ≤ sl∗ ≤ ‘(t) and t[0 : sl∗] is viable. This is also well deﬁned since t is viable. Observe
2 2 2
that no sl ≤ sl∗ ≤ sl∗ can index an honest vertex of t; otherwise, sl∗ > sl (by assumption) but the
2 2 2
tine t[0 : sl∗−1] would be viable—as it supports extension by an honest vertex—which contradicts
minimality of sl∗. As we assume that s > 0,
2
sl∗ ≤ sl < sl +s ≤ sl ≤ sl∗
1 1 1 2 2
and observe that t(sl∗,sl∗] contains no honest vertices. We deﬁne the rank of this violation to be
1 2
the quantity ‘ = sl∗−sl∗ and refer to sl∗ as the target of the violation; we say that the pair (sl∗;‘)
2 1 2 2
is the signature of such a violation. Note that the rank ‘ of a s-∃cq violation is always at least s.
Consider now the sequence
sl∗ = hsl < ··· < hsl ≤ sl∗,
1 0 g 2
22
where hsl ,...,hsl denote the honest indices in the region [sl∗,sl∗], and let t ,...,t denote the
0 g 1 2 0 g
tines for which ‘(t ) = hsl . Note that t[0 : sl∗] = t and that length(t ) < length(t ) for each
i i 1 0 i−1 i
0 < i ≤ g. As t[0 : sl∗] is viable and hsl is honest, we note that length(t ) ≤ length(t[0 : sl∗]). To
2 g g 2
conclude,
length(t[0 : sl∗]) ≥ length(t[0 : sl∗])+g.
2 1
We remark that g = #0(wˆ), where wˆ = wsl∗+1,...,wsl∗, and note that ‘ = |wˆ|. On the other hand,
as t(sl∗,sl∗] contains no honest vertex we h1ave the imm2 ediate upper bound
1 2
length(t[0 : sl∗]) ≤ length(t[0 : sl∗])+# (wˆ),
2 1 1
where # (wˆ) denotes the number of adversarial indices in wˆ. Thus # (wˆ) ≥ # (wˆ).
1 1 0
Fixing a particular signature (sl,‘) it follows that
Pr[w admits an s-∃CQ violation with signature (sl;‘)]
≤Pr[# (wˆ)−# (wˆ) ≤ 0]
0 1
w
=Pr[# (wˆ) ≥ ‘/2]
1
w
≤Pr[# (wˆ) ≥ ‘(1/2−(cid:15))+(cid:15)‘] ≤ exp(−2(cid:15)2‘)
1
w
where wˆ, as above, denotes w ,...,w . It follows that for any sl ≤ L
sl−‘+1 sl
Pr[w admits an s-∃CQ violation with signature (sl;‘) for any ‘ ≥ s]
∞ Z ∞ 1
≤Xexp(−2(cid:15)2‘) ≤ exp(−2(cid:15)2‘)d‘ = exp(−2(cid:15)2(s−1))
2(cid:15)2
s−1
‘=s
exp(2(cid:15)2)
= exp(−2(cid:15)2s).
2(cid:15)2
The union bound, applied over all indices, yields
exp(2(cid:15)2) h i
Pr[w admits an s-∃CQ violation over y] ≤ Lexp(−2(cid:15)2s) ≤ ((cid:15)−2+3)/2 Lexp(−2(cid:15)2s),
2(cid:15)2
where the ﬁnal inequality follows from exp(x) ≤ 1+(3/2)x for x ∈ (0,1/2).
4.5 Chain Growth
We begin with the lemma below demonstrating that chain growth (cg) follows from existential
chain quality (∃cq) and honest-bounded chain growth (hcg).
Lemma 4.20. Consider a characteristic string w that satisﬁes ∃cq with parameter s and hcg
∃cq
with parameters τ and s ; then it satisﬁes cg with parameters
hcg hcg
  !
s
s = 2s +s and τ = τ · hcg .
∃cq hcg hcg s +2s
hcg ∃cq
In particular, assuming s ≥ 2s , the execution satisﬁes cg with parameter τ ≥ τ /2.
hcg ∃cq hcg
Proof. Let F ‘ w be a fork and let t be a viable tine. Consider a portion of t spanning sˆ ≥ s =
2s +s slots. By ∃cq, there must be an honest vertex of t associated with the ﬁrst s and
∃cq hcg ∃cq
23
last s slots. As these two honest blocks are separated by at least s slots, applying hcg to the
∃cq hcg
tine that terminates at the later honest block (which is necessarily viable) guarantees that at least
(cid:18)sˆ−2s (cid:19)   s !
τ ·(sˆ−2s ) = τ · ∃cq sˆ≥ τ · hcg sˆ
hcg ∃CQ hcg sˆ hcg s +2s
hcg ∃cq
| {z }
(†)
vertices appear in the region. (The last inequality follows because the function f (x) = (x−λ)/x,
λ
for any λ > 0, is strictly increasing for x > 0—thus (†) is minimized when sˆ= s +2s .) The
HCG ∃CQ
statement of the lemma follows.
We now establish concrete bounds on hcg; coupled with the conclusions about ∃cq from Sec-
tion 4.4, this will yield our desired bounds on cg.
Lemma 4.21 (Abstract Honest Chain Growth). Consider w = w ...w drawn in {0,1}L so that
1 L
each w independently takes the value 1 with probability 1/2−(cid:15). Then for any s > 0 and δ > 0,
i
(cid:16) (cid:17)
Pr[w admits a (τ,s)-hcg violation] ≤ (cid:15) (τ,s;L,(cid:15)) (cid:44) (δ−2+3)/2 Lexp(−2δ2s),
hcg
where τ = 1/2+(cid:15)−δ. In particular, taking δ = (cid:15), we remark that
Pr[w admits a (1/2,s)-hcg violation] ≤ ((cid:15)2/2+2)Lexp(−2(cid:15)2s).
Proof. In the event that w admits a (τ,s)-hcg violation there is a fork F ‘ w, a viable tine t of
F, and two indices sl and sl for which (i.) t has an honest vertex v associated with sl , (ii.)
1 2 1 1
sl = ‘(t), (iii.) sl +s ≤ sl , and (iv.) t(sl ,sl ] contains fewer than τs vertices. Let
2 1 2 1 2
sl = hsl < hsl < ··· < hsl ≤ sl
1 0 1 g 2
denote the increasing sequence of all honest indices in the interval {sl ,...,sl } and, for each
1 2
0 ≤ i ≤ g, let t denote the tine for which ‘(t ) = hsl . Observe that t[0 : sl ] = t and, in case
i i i 1 0
g > 0, length(t ) < length(t ) for i ∈ {0,...,g−1}. Observe that,
i i+1
(∗)
length(t) = length(t[0 : sl ]) ≥ length(t ) ≥ length(t )+g ≥ length(t[0 : sl ])+g.
2 g 0 1
(∗)
where ≥ follows from viability of t. Thus length(t) ≥ length(t[0 : sl ])+g.
1
Note that g is the number of zeros appearing in the string wˇ = w ,...,w and, in light of
sl1+1 sl2
the discussion above g < τs. We say sl is the target of this violation, and that sl −sl = |wˇ| is
2 2 1
the rank.
Observe now that
Pr[w admits a (τ,s)-hcg violation with target sl and rank ‘]
≤Pr[# (wˇ) < τs] = Pr[# (wˇ) < [(1−α)−δ]‘]
0 0
≤Pr(cid:2)wt(wˇ) < E[wt(wˇ)]−‘δ(cid:3) ≤ exp(−2δ2‘),
where the last inequality follows from the Chernoﬀ-Hoeﬀding bounds (Theorem 4.16).
24
By the union bound, applied over ranks ‘, we conclude that
Pr[W admits a (τ,s)-HCG violation with target sl]
Z ∞
≤Xexp(−2δ2‘) ≤ exp(−2δ2‘)d‘
‘=s−1
‘≥s
1 exp(2δ2)
= exp(−2δ2(s−1)) ≤ exp(−2δ2s).
2δ2 2δ2
To complete the argument, a union bound over all targets yields the bound:
exp(2δ2) (cid:16) (cid:17)
Pr[w does not possess (s,τ)-hcg] ≤ L exp(−2δ2s) ≤ (δ−2+3)/2 Lexp(−2δ2s),
2δ2
where the ﬁnal inequality follows from exp(x) ≤ 1+(3/2)x for x ∈ (0,1/2).
Lemma 4.22 (Abstract Chain Growth). Consider w = w ,...,w drawn in {0,1}L so that each
1 L
w independently takes the value 1 with probability 1/2−(cid:15). Then for s > 0, we have
i
Pr[w does not satisfy (1/4,s)-cg] ≤ (cid:15) (1/4,s;L,(cid:15)) (cid:44) ((cid:15)−2+4)Lexp(−(cid:15)2s/2) .
cg
Proof. ThecorollaryfollowsdirectlybycombiningLemmas4.19,4.20,and4.21withtheparameters
s = s/4, and s = s/2, δ = (cid:15).
∃cq hcg hcg
Speciﬁcally, applying Lemma 4.19 with s = s/4,
∃cq
Pr[w does not satisfy s/4-∃cq] ≤ ((cid:15)−2/2+2)Lexp(−(cid:15)2s/2).
Likewise, applying Lemma 4.21 with s = s/2, δ = (cid:15), and τ = 1/2+(cid:15)−δ = 1/2,
hcg hcg hcg
Pr[w does not satisfy (1/2,s/2)-hcg] ≤ ((cid:15)−2/2+2)Lexp(−(cid:15)2s).
In light of Lemma 4.20, and considering that s ≤ s /2,
∃cq hcg
Pr[w does not satisfy (1/4,s)-cg] ≤ ((cid:15)−2/2+2)Lexp(−(cid:15)2s/2)+((cid:15)−2/2+2)Lexp(−(cid:15)2s)
≤ ((cid:15)−2+4)Lexp(−(cid:15)2s/2).
4.6 Common Preﬁx
Deﬁnition 4.23 (Flat forks; the ∼ relation). For two tines t and t of a fork F, we write t ∼ t
1 2 1 2
if they share an edge. Note that ∼ is an equivalence relation on the set of nontrivial tines; on the
other hand, if t denotes the “empty” tine consisting solely of the root vertex then t 6∼ t for any
(cid:15) (cid:15)
tine t. We say that a fork is ﬂat if it has two tines t 6∼ t of length equal to the height of the fork.
1 2
A string w ∈ {0,1}∗ is said to be forkable if there is a ﬂat fork F ‘ w.
Note that in order for an execution of π to yield two entirely disjoint chains of maximum
iSPoS
length (in the view of an observer), the characteristic string associated with the execution must be
forkable. Our goal is to establish the following upper bound on the number of forkable strings. We
then apply this to control the probability of a common preﬁx violation.
Theorem 4.24. Let (cid:15) ∈ (0,1) and let w be a characteristic string drawn from {0,1}n by indepen-
√
dently assigning each w = 1 with probability (1−(cid:15))/2. Then Pr[w is forkable] = 2−Ω( n).
i
HeretheΩ()notationhidesaconstantthatdependson(cid:15). Notethatinsubsequentwork,Russell
et al. [42] improved this bound to 2−Ω(n).
25
Structural features of forks: Reach, gap, reserve, and margin.
Deﬁnition 4.25 (Gap, reserveand reach). Let F ‘ w be a closed fork and let tˆdenote the (unique)
tine of maximum length in F. We deﬁne the gap of a tine t, denoted gap(t), to be the diﬀerence in
length between tˆand t; thus
gap(t) = length(tˆ)−length(t).
We deﬁne the reserve of a tine t to be the number of adversarial indices appearing in w after the
last index in t; speciﬁcally, if t is given by the path (r,v ,...,v ), where r is the root of F, we deﬁne
1 k
reserve(t) = |{i | w = 1 and i > ‘(v )}|.
i k
We remark that this quantity depends both on F and the speciﬁc string w associated with F. Finally,
for a tine t we deﬁne
reach(t) = reserve(t)−gap(t).
Deﬁnition 4.26 (Margin). For a closed fork F ‘ w we deﬁne ρ(F) to be the maximum reach taken
over all tines in F:
ρ(F) = maxreach(t).
t
Likewise, we deﬁne the margin of F, denoted µ(F), to be the “penultimate” reach taken over edge-
disjoint tines of F: speciﬁcally,
(cid:16) (cid:17)
margin(F) = µ(F) = max min{reach(t ),reach(t )} . (2)
1 2
t16∼t2
We remark that the maxima above can always be obtained by honest tines. Speciﬁcally, if t is
an adversarial tine of a fork F ‘ w, reach(t) ≤ reach(t), where t is the longest honest preﬁx of t.
As ∼ is an equivalence relation on the nonempty tines, it follows that there is always a pair of
(edge-disjoint) tines t and t achieving the maximum in the deﬁning equation (2) which satisfy
1 2
reach(t ) = ρ(F) ≥ reach(t ) = µ(F).
1 2
The relevance of margin to the notion of forkability is reﬂected in the following proposition.
Proposition 4.27. A string w is forkable if and only if there is a closed fork F ‘ w for which
margin(F) ≥ 0.
Proof. Ifw hasnohonestindices, thenthetrivialforkconsistingofasinglerootnodeisﬂat, closed,
and has non-negative margin; thus the two conditions are equivalent. Consider a forkable string w
with at least one honest index and letˆi denote the largest honest index of w. Let F be a ﬂat fork
forw andletF ‘ w betheclosureofF (obtainedfromF byremovinganyadversarialverticesfrom
the ends of the tines of F). Note that the tine tˆcontainingˆi is the longest tine in F, as this is the
largest honest index of w. On the other hand, F is ﬂat, in which case there are two edge-disjoint
tines t and t with length at least that of tˆ. The preﬁxes of these two tines in F must clearly have
1 2
reserve no less than gap (and hence non-negative reach); thus margin(F) ≥ 0 as desired.
On the other hand, suppose w has a closed fork with margin(F) ≥ 0, in which case there are
two edge-disjoint tines of F, t and t , for which reach(t ) ≥ 0. Then we can produce a ﬂat fork by
1 2 i
simply adding to each t a path of gap(t ) vertices labeled with the subsequent adversarial indices
i i
promised by the deﬁnition of reserve().
In light of this proposition, for a string w we focus our attention on the quantities
ρ(w) = max ρ(F), µ(w) = max µ(F),
F‘w, F‘w,
F closed F closed
26
and, for convenience,
m(w) = (ρ(w),µ(w)).
Note that this overloads the notation ρ(·) and µ(·) so that they apply to both forks and strings,
but the setting will be clear from context. We remark that the deﬁnitions do not guarantee a priori
that ρ(w) and µ(w) can be achieved by the same fork, though this will be established in the lemma
below. In any case, it is clear that ρ(w) ≥ 0 and ρ(w) ≥ µ(w) for all strings w; furthermore, by
Proposition 4.27 a string w is forkable if and only if µ(w) ≥ 0. We refer to µ(w) as the margin of
the string w.
In preparation for the proof of Theorem 4.24, we establish a recursive description for these
quantities.
Lemma 4.28. m((cid:15)) = (0,0) and, for all nonempty strings w ∈ {0,1}∗,
m(w1) = (ρ(w)+1,µ(w)+1),and

(ρ(w)−1,0) if ρ(w) > µ(w) = 0,
m(w0) = (0,µ(w)−1) if ρ(w) = 0,
(ρ(w)−1,µ(w)−1) otherwise.
Furthermore, for every string w, there is a closed fork F ‘ w for which m(w) = (ρ(F ),µ(F )).
w w w
Proof. The proof proceeds by induction. If w = (cid:15), deﬁne F to be the trivial fork; F ‘ w is the
(cid:15) (cid:15)
unique closed fork for this string and m((cid:15)) = (0,0) = (ρ(F ),µ(F )), as desired.
(cid:15) (cid:15)
In general, we consider m(w0) for a string w0 = wx—where w ∈ {0,1}∗ and x ∈ {0,1}; the
argument recursively expands m(w0) in terms of m(w) and the value of the last symbol x. In each
case, we consider the relationship between two closed forks F v F0 where F ‘ w and F0 ‘ w0 = wx.
In the case where x = 1, we must have F = F0 as graphs, because the forks are assumed to
be closed; it is easy to see that the reach of any tine t of F ‘ w has increased by exactly one
when viewed as a tine of F0 ‘ w0. We write reach (t) = reach (t)+1, where we introduce the
F0 F
notation reach(cid:3)() to denote the reach in a particular fork. It follows that ρ(F0) = ρ(F)+1 and
µ(F0) = µ(F) + 1. If F∗ ‘ w0 is a closed fork for which ρ(F∗) = ρ(w0), note that F∗ may be
treated as a fork for w and, applying the argument above, we ﬁnd that ρ(w0) ≤ ρ(w)+1. A similar
argument implies that µ(w0) ≤ µ(w)+1. On the other hand, by induction there is a fork F for
w
which m(w) = (ρ(F ),µ(F )) and hence m(w0) ≥ (ρ(w)+1,µ(w)+1). We conclude that
w w
m(w0) = (ρ(w)+1,µ(w)+1). (3)
Moreover, m(w0) = (ρ(F ),µ(F )), where F is treated as a fork for w0 = w1.
w w w
The case when x = 0 is more delicate. As above, we consider the relationship between two
closed forks F ‘ w and F0 ‘ w0 = w0 for which F v F0. Here F0 is necessarily obtained from F
by appending a path labeled with a string of the form 1a0 to the end of a tine t of F. (In fact,
it is easy to see that we may always assume that this is appended to an honest tine.) In order
for this to be possible, gap(t) ≤ reserve(t) (which is to say that reach(t) ≥ 0) and, in particular,
gap(t) ≤ a ≤ reserve(t): for the ﬁrst inequality, note that the depth of the new honest vertex
must exceed that of the deepest (honest) vertex in F and hence a ≥ gap(t); as for the second
inequality, there are only reserve(t) possible adversarial indices that may be added to t and hence
a ≤ reserve(t). We deﬁne the quantity a˜ ≥ 0 by the equation a = gap(t)+a˜ and let t0 denote the
tine (of F0) resulting by extending t in this way. We say that a˜ is the parameter for this pair of
forks F v F0.
27
Of course, every honest tine t of F is an honest tine of F0 and it is clear that reach (t) =
F0
reach (t)−(a˜+1), as the length of the longest tine t0 in F0 exceeds the length of the longest tine
F
of F by exactly a˜+1. Note that the reach of the new honest tine t0 (in F0) is always 0, as both
gap(t0) and reserve(t0) are zero. It remains to describe how µ(w) and ρ(w) are determined by this
process.
The case ρ(w) > µ(w) = 0. By induction, there is a fork F for which m(w) = (ρ(F ),µ(F )).
w w w
Let t and t be edge-disjoint tines of F for which ρ(F ) = reach(t ) and µ(F ) = reach(t ).
1 2 w w 1 w 2
Deﬁne F0 ‘ w0 to be the fork obtained by extending the tine t of F with parameter a˜ = 0
2 w
to yield a new tine t0 in F0. Then reach (t ) = ρ(w)−1 and reach (t0) = 0. It follows that
2 F0 1 F0 2
ρ(w0) ≥ ρ(w)−1 and µ(w0) ≥ 0. We will show that ρ(w0) ≤ ρ(w)−1 and that µ(w0) ≤ 0,
in which case we can conclude that
ρ(w0) = ρ(w)−1 and µ(w0) = 0.
Moreover, the fork F = F0 achieves these statistics, as desired.
w0
We return to establish that ρ(w0) ≤ ρ(w)−1 and that µ(w0) ≤ 0. Let F∗ ‘ w0 be a closed
fork for which ρ(w0) = ρ(F∗) and let F ‘ w be the unique closed fork for which F v F∗;
as above, let a˜ denote the parameter for this extension. Let t∗ be an honest tine of F∗ so
that reach (t∗) = ρ(w0). If t∗ is a tine of F, reach (t∗) = reach (t∗)−(a˜+1) ≤ ρ(w)−1.
F∗ F∗ F
Otherwise t∗ was obtained by extension and reach (t∗) = 0 ≤ ρ(w)−1 by assumption. In
F∗
either case ρ(w0) ≤ ρ(w)−1, as desired. It remains to show that µ(w0) ≤ 0. Now consider
F∗ ‘ w0 to be a closed fork for which µ(F∗) = µ(w0). Let t∗ and t∗ be two edge-disjoint
1 2
honest tines of F∗ so that reach (t∗) = ρ(F∗) and reach (t∗) = µ(F∗) = µ(w0). Let F ‘ w
F∗ 1 F∗ 2
be the unique closed fork for which F v F∗ and let a˜ be the parameter for this extension.
If both t∗ and t∗ are tines of F, reach (t∗) = reach (t∗) − (a˜ + 1) and, in particular,
1 2 F∗ i F i
reach (t∗) ≥ reach (t∗). It follows that reach (t∗) ≤ µ(F) ≤ µ(w) = 0 and hence that
F 1 F 2 F 2
µ(w0) < 0. Otherwise, one of the two tines was the result of extension and has zero reach()
in F∗. As reach (t∗) ≥ reach (t∗), in either case it follows that µ(F∗) = reach (t∗) ≤ 0,
F∗ 1 F∗ 2 F∗ 2
as desired.
The case ρ(w) = 0. By induction, there is a fork F for which m(w) = (ρ(F ),µ(F )). Let t
w w w 1
andt beedge-disjointtinesofF forwhichρ(F ) = reach(t )andµ(F ) = reach(t ). Deﬁne
2 w w 1 w 2
F0 ‘ w0 to be the fork obtained by extending the tine t of F with parameter a˜ = 0 to yield
1 w
a new tine t0 in F0. Then reach (t0) = 0 and reach (t ) = reach (t )−1. It follows that
1 F0 1 F0 2 F 2
ρ(w0) ≥ 0 and µ(w0) ≥ µ(w)−1. We will show that ρ(w0) ≤ 0 and that µ(w0) ≤ µ(w)−1,
in which case we can conclude that
ρ(w0) = 0 and µ(w0) = µ(w)−1.
Moreover, the fork F = F0 achieves these statistics, as desired.
w0
We return to establish that ρ(w0) ≤ 0 and that µ(w0) ≤ µ(w) − 1. Let F∗ ‘ w0 be a
closed fork for which ρ(w0) = ρ(F∗) and let F ‘ w be the unique closed fork for which
F v F∗; as above, let a˜ denote the parameter for this extension. Let t∗ be an honest tine
of F∗ so that reach (t∗) = ρ(w0). Note that t∗ cannot be a tine of F; if it were then
F∗
reach (t∗) = reach (t∗)−(a˜ +1) ≤ ρ(w)−1 < 0 which contradicts ρ(w0) ≥ 0. Thus t∗
F∗ F
was obtained by extension and reach (t∗) = 0. It remains to show that µ(w0) ≤ 0. Now let
F∗
F∗ ‘ w0 be a closed fork for which µ(F∗) = µ(w0). Let t∗ and t∗ be two edge-disjoint honest
1 2
tines of F∗ so that reach (t∗) = ρ(F∗) and reach (t∗) = µ(F∗) = µ(w0). Let F ‘ w be the
F∗ 1 F∗ 2
28
unique closed fork for which F v F∗ and let a˜ be the parameter for this extension. Similarly,
t∗ cannot be a tine of F; if it were, ρ(F∗) = reach (t∗) = reach (t∗)−(a˜+1) ≤ ρ(F)−1 ≤
1 F∗ 1 F 1
ρ(w)−1 < 0 which contradicts ρ(F) ≥ 0. It follows that t∗ must extend a tine t of F for
1 1
which reach (t ) = 0, because extension can only occur for tines of non-negative reach and
F 1
ρ(F) = 0 = ρ(w). Thus t∗ is a tine of F and t 6∼ t∗ so that reach (t∗) ≤ µ(F) ≤ µ(w) and
2 1 2 F 2
we conclude that µ(w0) = reach (t∗) ≤ reach (t∗)−1 ≤ µ(w)−1, as desired.
F∗ 2 F 2
The case ρ(w) > 0,µ(w) 6= 0. By induction, there is a fork F for which m(w) = (ρ(F ),µ(F )).
w w w
Let t and t be edge-disjoint tines of F for which ρ(F ) = reach(t ) and µ(F ) = reach(t ).
1 2 w w 1 w 2
In fact, any extension of F will suﬃce for the construction; for concreteness, deﬁne F0 ‘
w
w0 to be the fork obtained by extending the tine t of F with parameter a˜ = 0. Then
1 w
reach (t ) = reach (t )−1. It follows that ρ(w0) ≥ ρ(w)−1 and µ(w0) ≥ µ(w)−1. We
F0 i Fw i
will show that ρ(w0) ≤ ρ(w)−1 and that µ(w0) ≤ µ(w)−1, in which case we can conclude
that
ρ(w0) = ρ(w)−1 and µ(w0) = µ(w)−1.
Moreover, the fork F = F0 achieves these statistics, as desired.
w0
We return to establish that ρ(w0) ≤ ρ(w)−1 and that µ(w0) ≤ µ(w)−1. Let F∗ ‘ w0 be a
closedforkforwhichρ(w0) = ρ(F∗)andletF ‘ wbetheuniqueclosedforkforwhichF v F∗;
as above, let a˜ denote the parameter for this extension. Let t∗ be an honest tine of F∗ so that
reach (t∗) = ρ(w0). Note that if t∗ is a tine of F then reach (t∗) = reach (t∗)−(a˜+1) ≤
F∗ F∗ F
ρ(w)−1; otherwise t∗ is obtained by extension and reach (t∗) = 0 ≤ ρ(w)−1, as desired.
F∗
(Recall that ρ(w) > 0.) It remains to show that µ(w0) ≤ µ(w)−1. Now let F∗ ‘ w0 be a
closed fork for which µ(F∗) = µ(w0). Let t∗ and t∗ be two edge-disjoint honest tines of F∗ so
1 2
that reach (t∗) = ρ(F∗) and reach (t∗) = µ(F∗) = µ(w0). Let F ‘ w be the unique closed
F∗ 1 F∗ 2
fork for which F v F∗ and let a˜ be the parameter for this extension. If both t∗ and t∗ are
1 2
tines of F then reach (t∗) = reach (t∗)−(a˜+1) and, in particular, reach (t∗) ≥ reach (t∗)
F∗ i F i F 1 F 2
so that reach (t∗) ≤ µ(w) and reach (t∗) ≤ µ(w)−1, as desired.
F 2 F∗ 2
To complete the argument, we consider the case that one of the tines t∗ arises by extension.
i
Note that in this case reach (t∗) ≤ 0, as either t∗ is obtained by extension so that it has zero
F∗ 2 2
reach, or t∗ is obtained by extension so that reach (t∗) ≤ reach (t∗) = 0. Here we further
1 F∗ 2 F∗ 1
separate the analysis into two cases depending on the sign of µ(w):
• If µ(w) > 0, then reach (t∗) ≤ 0 ≤ µ(w)−1, as desired.
F∗ 2
• If µ(w) < 0 then t∗ cannot be the extension of a tine in F. To see this, suppose to the
2
contrary that t∗ extends a tine t of F; then reach (t ) ≥ 0. Additionally, t∗ must be a
2 2 F 2 1
tine of F, edge-disjoint from t , and reach (t∗) = reach (t∗)+(a˜+1) > 0. It follows
2 F 1 F∗ 1
that µ(w) ≥ µ(F) ≥ 0, a contradiction.
Theotherpossibilityisthatt∗ isanextensionofatinet ofF inwhichcasereach (t ) ≥
1 1 F 1
0. Notethatt∗isatineofF andedge-disjointfromt ;thusmin(reach (t∗),reach (t )) ≤
2 1 F 2 F 1
µ(F) < 0andreach (t∗) ≤ µ(F). Weconcludethatreach (t∗) = reach (t∗)−(a˜+1) ≤
F 2 F∗ 2 F 2
µ(w)−1, as desired.
With this recursive description in place, we return to the proof of Theorem 4.24, which we
restate below for convenience.
Theorem 4.24, restated. Let (cid:15) ∈ (0,1) and let w be a string drawn from {0,1}n by independently
assigning each w = 1 with probability (1−(cid:15))/2. Then
i
√
Pr[w is forkable] = 2−Ω( n).
29
Proof of Theorem 4.24. The theorem concerns the probability distribution on {0,1}n given by in-
dependently selecting each w ∈ {0,1} so that
i
1+(cid:15)
Pr[w = 0] = = 1−Pr[w = 1].
i 2 i
For the string w ...w chosen with the probability distribution above, deﬁne the random variables
1 n
R = ρ(w ...w ) and M = µ(w ...w ).
t 1 t t 1 t
Our goal is to establish that
√
Pr[w forkable] = Pr[M ≥ 0] = 2−Ω( n).
n
We extract from the statement of Lemma 4.28 some facts about these random variables.
(R = R +1 if w = 1,
R > 0 =⇒ t+1 t t+1 (4)
t R = R −1 if w = 0;
t+1 t t+1
(M = M +1 if w = 1,
M < 0 =⇒ t+1 t t+1 (5)
t M = M −1 if w = 0;
t+1 t t+1

Rt+1 = 1 if wt+1 = 1,
R = 0 =⇒ R = 0 if w = 0, (6)
t t+1 t+1
M < 0 if w = 0.
t+1 t
In light of the properties (4) above, the random variables R are quite well-behaved when
t
positive—in particular, considering the distribution placed on each w , they simply follow the
i
familiar biased random walk of Figure 6. Likewise, considering the properties (5), the random
variables M follow a biased random walk when negative. The remainder of the proof combines
t
these probability laws with (6) and the fact that M () ≤ R () to establish that M < 0 with high
t t n
probability.
q q q q
··· −1 0 1 ···
p p p p
Figure 6: The simple biased walk where p = (1+(cid:15))/2 and q = 1−p.
We recall two basic facts about the standard biased walk associated with the Markov chain of
Figure 6. Let Z ∈ {±1} (for i = 1,2,...) denote a family of independent random variables for
i
which Pr[Z = 1] = (1−(cid:15))/2. Then the biased walk given by the variables Y = PtZ has the
i t i i
following properties.
Constant escape probability; gambler’s ruin. With constant probability, depending only on
(cid:15), Y 6= 1 for all t > 0. In general, for each k > 0,
t
Pr[∃t,Y = k] = αk, (7)
t
for a constant α < 1 depending only on (cid:15). (In fact, the constant α is (1−(cid:15))/(1+(cid:15)); see, e.g.,
[29, Chapter 12] for a complete development.)
30
Concentration (the Chernoﬀ bound). Consider T steps of the biased walk beginning at state
0; then the resulting value is tightly concentrated around −(cid:15)T. Speciﬁcally, E[Y ] = −(cid:15)T and
T
(cid:20) (cid:15)T(cid:21)
Pr Y > − = 2−Ω(T). (8)
T 2
(The constant hidden in the Ω() notation depends only on (cid:15). See, e.g., [1, Cor. A.1.14].)
√ √
Partitioning the string w, we write w = w(1)···w( n) where w(t) = w ...w and a = dt ne,
1+at−1 at t
for t = 0,1,.... Let R = 0 and R = R ; similarly deﬁne M = 0 and M = M . Fix δ (cid:28) (cid:15)
(0) (t) at (0) (t) at
to be a small constant.
We deﬁne three events based on the random variables R and M :
(t) (t)
√ √
Hot We let Hot denote the event that R ≥ δ n and M ≥ −δ n.
t (t) (t)
√ √
Volatile We let Vol denote the event that −δ n ≤ M ≤ R < δ n.
t (t) (t)
√
Cold We let Cold denote the event that M < −δ n.
t (t)
Note that for each t, exactly one of these events occurs—they partition the probability space. Then
we will establish that
√
Pr[Cold | Cold ] ≥ 1−2−Ω( n), (9)
t+1 t
Pr[Cold | Vol ] ≥ Ω((cid:15)), (10)
t+1 t
√
Pr[Hot | Vol ] ≤ 2−Ω( n). (11)
t+1 t
θ(1)
Vol
≈ 0
θ(1)
≈ 1 Cold Hot
Figure 7: An illustration of the transitions between Cold, Vol, and Hot.
Note that the event Vol occurs by deﬁnition. Assuming these inequalities, we observe that the
0
system is very likely to eventually become cold, and stay that way. In this case, Cold√ occurs,
√ n
M◦ < δ n < 0, and w is not forkable. Speciﬁcally, note that the probability that the system
n √
ever transitions from volatile to hot is no more than 2−Ω( n) (as transition from Vol to Hot is
√ √
bounded above by 2−Ω( n), and there are no more than n possible transition opportunities).
Note, also, that while the system is volatile, it transitions to cold with constant probability during
each period. In particular, the probability that the system is volatile for the entire process is no
31
√
more that 2−Ω( n). Finally, note that the probability that the system ever transitions out of the
√ √
cold state is no more than 2−Ω( n) (again, there are at most n possible times when this could
√
happen, and any individual transition occurs with probability 2−Ω( n)). It follows that the system
√
is cold at the end of the process with probability 1−2−Ω( n).
It remains to establish the three inequalities (9), (10), and (11).
Inequality (9): This follows directly from (4) and (7). Speciﬁcally, in light of (5) the random
variables M follow the probability law of the simple biased walk when they are negative.
i √
Conditioned on M = M < −δ n, the probability that any future M ever climbs to the
(t) at √ s
value −1 is no more than α−δ n = 2−Ω(n), as desired. (Here α < 1 is a ﬁxed constant that
depends only on (cid:15).)
Inequality (10): This follows from (4), (6), (7), and (8). Speciﬁcally, conditioned on Vol , R ≤
√ t (t)
δ n. Recall from (4) that the random variables R follow the probability law of the simple
i √
biasedwalkwhentheyarepositive. LetD betheeventthatR > 0foralla ≤ i < a +2δ n.
√ i√ t t
Accordingto(8),then,wherewetakeT = 2δ n,Pr[D] ≤ 2−Ω( n). Withnearcertainty,then,
the random variables R visit the value 0 during this period. Observe that if R = 0 then,
i i
by (6), M ≤ −1 with constant probability and (conditioned on this), by (7), with constant
i+1
probability the subsequent random variables M do not return to the value 0. Additionally,
j √
in light of (8), the probability that there is a sequence w ...w of length at least 2(δ/(cid:15)) n
i j
for which
Xj (1 if wk = 1, √
  ≥ −δ n
−1 if w = 0.
k=i k
√ √
is no more than ( n)22−Ω( n). It follows that with constant probability, the walk (of R )
√ i
hits 0, as described above, and then M terminates at a value less than −δ n.
i
Inequality (11): This follows from (4), (6), (7), and (8). Speciﬁcally, conditioned on Vol , R ≤
√ t (t)
δ n. Recall from (4) that the random variables R follow the probability law of the simple
i √
biasedwalkwhentheyarepositive. LetD betheeventthatR > 0foralla ≤ i < a +2δ n.
√ i √ t t
According to (8), then, where we take T = 2δ n, Pr[D] ≤ 2−Ω( n). With near certainty,
then, therandomvariablesR visitthevalue0duringthisperiod. ConditionedonD, inorder
√ i
for R ≥ δ n there must be a sequence of these random variables 0 = R ,R ,...,R =
√ at+1 i i+1 j
bδ nc so that none of these take the value 0 except the ﬁrst. (Such a sequence arises by
taking i to be the last time the variables R ,... visit 0 and j the ﬁrst subsequent time
√ at
that the sequence is larger than δ n.) In light of (7), the probability of such a subsequence
√
appearing at a particular value for i is no more than α−δ n. It follows that the probability
√ √ √ √
that R ≥ δ n is less than nα−δ n = 2−Ω( n), as desired.
at+1
Exact probabilities of forkability for explicit values of n. In order to gain further insight
regarding the density of forkable strings, we exactly computed the probability that a string w—
drawnsothateachw isindependentlyassignedthevalue1withprobabilityp ∈ {.40,.41,...,.50}—
i
is forkable for several diﬀerent lengths. These results are presented in Figure 8.
Reducing common preﬁx to forkability. Returning now to the challenge of common preﬁx,
we note that the random assignment of slots to stakeholders given by F guarantees that the
LS
coordinates of the associated characteristic string w are independent Bernoulli random variables
taking the value 1 with probability equal to the adversarial stake. Thus Theorem 4.24 establishes
32
Probability of Forkability
0.8 n = 500
y n = 1000
t
li n = 1500
i
ab 0.6 n = 2000
k
r
o
f
of 0.4
y
t
i
l
i
ab 0.2
b
o
r
P
0
0.4 0.42 0.44 0.46 0.48 0.5
Probability that w = 1
i
Figure 8: Graphs of the probability that a string drawn so that each bit is independently assigned
thevalue1withacertainprobabilityisforkable. Graphsforstringlengthsn = 500,1000,1500,2000
are shown for probabilities .40,.41,...,.49,.50.
that no execution of the protocol π can induce two tines (chains) of maximal length with no
iSPoS
common preﬁx.
Inthecontextofπ , however, wewishtoestablishamuchstrongercommon preﬁx property:
iSPoS
any pair of chains which could, in principle, be presented by the adversary to an honest party must
have a “recent” common preﬁx, in the sense that removing a small number of blocks from the
shorter chain results in a preﬁx of the longer chain.
To formally articulate and prove this property, we introduce a further deﬁnition regarding tines
and forks.
Deﬁnition 4.29 (Divergence). Let F be a fork for a string w ∈ {0,1}∗. For two viable tines t and
t0 of F we deﬁne the notation t/t0 by the rule
t/t0 = length(t)−length(t∩t0),
where t∩t0 denotes the common preﬁx of t and t0. Then deﬁne the divergence of two viable tines
t and t to be the quantity
1 2

t1/t2 if ‘(t1) < ‘(t2),
div(t ,t ) = t /t if ‘(t ) < ‘(t ),
1 2 2 1 2 1
max(t /t ,t /t ) if ‘(t ) = ‘(t ).
1 2 2 1 1 2
We overload this notation by deﬁning divergence for F as the maximum over all pairs of viable
tines:
div(F) = max div(t ,t ).
1 2
t1,t2 viable
tines of F
Finally, deﬁne the divergence of w to be the maximum such divergence over all possible forks for w:
div(w) = max div(F).
F‘w
Observe that if div(t ,t ) ≤ k and, say, ‘(t ) ≤ ‘(t ), the tine tdk is a preﬁx of t .
1 2 1 2 1 2
33
Divergence and common preﬁx violations. Divergence directly reﬂects the possibility of a
common preﬁx violation. In particular, the characteristic string w satisﬁes k-cp if and only if
div(w) ≤ k. We ﬁrst establish that a string with large divergence must have a large forkable
substring. We then apply this in Theorem 4.31 below to conclude that characteristic strings arising
from π (that is, for which each bit is a Bernoulli random variable) are unlikely to have large
iSPoS
divergence and, hence, possess the common preﬁx property. The speciﬁc fork of relevance, as
described above, is F arising from the protocol; however, the analysis below will show that no
A
fork realizes large divergence.
Theorem 4.30. Let w ∈ {0,1}∗. Then there is forkable substring wˇ of w with |wˇ| ≥ div(w).
Proof. Consider a string w ∈ {0,1}n, a fork F ‘ w, and a pair of viable tines (t ,t ) for which
1 2
‘(t ) ≤ ‘(t ) and t /t = div(w). (12)
1 2 1 2
We may further assume that
|‘(t )−‘(t )| is minimum among all pairs of tines for which (12) holds. (13)
2 1
We begin by identifying the substring wˇ; the remainder of the proof is devoted to constructing
a ﬂat fork for wˇ to establish forkability. Let y denote the last vertex on the tine t ∩t , as in the
1 2
diagram below, and let α (cid:44) ‘(y) = ‘(t ∩t ).
1 2
t
1
y
t
2
Let β denote the smallest honest index of w for which β ≥ ‘(t ), with the convention that if there
2
is no such index we deﬁne β = n+1. It follows that ‘(t ) < β. Speciﬁcally, if ‘(t ) = ‘(t ) = i then
1 1 2
this label i is adversarial and hence ‘(t ) < β; otherwise, either ‘(t ) < ‘(t ) ≤ β or β = n+1 and
1 1 2
thus ‘(t ) < β.
1
These indices, α and β, distinguish the substring wˇ = w ...w which will be the subject
α+1 β−1
of the remainder of the proof. As the function ‘(·) is strictly increasing along any tine, observe that
|wˇ| = β −α−1 ≥ ‘(t )−‘(y) ≥ length(t )−length(t ∩t ) = div(w),
1 1 1 2
so wˇ has the desired length and it suﬃces to establish that it is forkable.
We brieﬂy summarize the proof before presenting the details. We begin by establishing several
structural properties of the tines t and t that follow from the assumptions (12) and (13) above.
1 2
To establish that wˇ is forkable we then extract from F a ﬂat fork (for wˇ) in two steps: (i.) the fork
F is subjected to some minor restructuring to ensure that all “long” tines pass through y; (ii.) a
ﬂat fork is constructed by treating the vertex y as the root of a portion of the subtree of F labeled
with indices of wˇ. At the conclusion of the construction, segments of the two tines t and t will
1 2
yield the required “long, disjoint” tines satisfying the deﬁnition of forkable.
We observe, ﬁrst of all, that the vertex y cannot be adversarial: otherwise it is easy to construct
an alternative fork F˜ ‘ w and a pair of tines in F˜ that achieve larger divergence. Speciﬁcally,
construct F˜ from F by adding a new (adversarial) vertex y˜ to F for which ‘(y˜) = ‘(y), adding an
edgetoy˜fromthevertexprecedingy, andreplacingtheedgeoft followingy withonefromy˜; then
1
the other relevant properties of the fork are maintained, but t /t —and hence the divergence—of
1 2
the resulting tines has increased by one. (See the diagram below.)
34
y˜
t
1
y
t
2
A similar argument implies that the fork F ‘ w ...w obtained by including only those vertices
0 1 α
of F with labels less than or equal to α = ‘(y) has a unique vertex of depth depth(y) (namely, y
itself). In the presence of another vertex y˜ (of F ) with depth depth(y), “redirecting” t through
0 1
y˜ (as in the argument above) would likewise result in a fork with larger divergence. Note that ‘(·)
would indeed be increasing along this new tine (resulting from redirecting t ) because ‘(y˜) ≤ ‘(y)
1
according to the deﬁnition of F . As α is the last index of the string, this additionally implies that
0
F has no vertices of depth exceeding depth(y).
0
We remark that the minimality assumption (13) implies that any honest index h for which
h < β has depth no more than min(length(t ),length(t )): speciﬁcally,
1 2
h < β =⇒ d(h) ≤ min(length(t ),length(t )). (14)
1 2
To see this, consider an honest index h < β and the tine t for which ‘(t ) = h. Recall that t
h h 1
and t are viable; as h < ‘(t ) it follows immediately that d(h) ≤ length(t ). Similarly, if h ≤ ‘(t )
2 2 2 1
then d(h) ≤ length(t ), so it remains to settle the case when ‘(t ) < h < ‘(t ): in particular, in
1 1 2
this regime we wish to likewise guarantee that d(h) ≤ length(t ). For the sake of contradiction,
1
assume that length(t ) = d(h) > length(t ). Considering the tine t , we separately investigate
h 1 h
two cases depending on whether t shares an edge with t after the vertex y. If, indeed, t and t
h 1 h 1
share an edge after the vertex y then t and t do not share such an edge, and we observe that
h 2
div(w) ≥ t /t ≥ t /t = div(w) (and hence div(w) = div(t ,t )) while |‘(t )−h| < |‘(t )−‘(t )|
h 2 1 2 h 2 2 2 1
which contradicts (13). If, on the other hand, t shares no edge with t after y, we similarly observe
h 1
that div(w) ≥ t /t ≥ t /t = div(w) while |h−‘(t )| < |‘(t )−‘(t )|, which contradicts (13).
1 h 1 2 1 2 1
In light of the remarks above, we observe that the fork F may be “pinched” at y to yield an
essentially identical fork F(cid:66)y(cid:67) ‘ w with the exception that all tines of length exceeding depth(y)
pass through the vertex y. Speciﬁcally, the fork F(cid:66)y(cid:67) ‘ w is deﬁned to be the graph obtained
from F by changing every edge of F directed towards a vertex of depth depth(y)+1 so that it
originates from y. To see that the resulting tree is a well-deﬁned fork, it suﬃces to check that ‘(·)
is still increasing along all tines of F(cid:66)y(cid:67). For this purpose, consider the eﬀect of this pinching on
an individual tine t terminating at a particular vertex v—it is replaced with a tine t(cid:66)y(cid:67) deﬁned so
that:
• If length(t) ≤ depth(y), the tine t is unchanged: t(cid:66)y(cid:67) = t.
• Otherwise, length(t) > depth(y) and t has a vertex z of depth depth(y) + 1; note that
‘(z) > ‘(y) because F contains no vertices of depth exceeding depth(y). Then t(cid:66)y(cid:67) is
0
deﬁned to be the path given by the tine terminating at y, a (new) edge from y to z, and the
suﬃx of t beginning at z. (As ‘(z) > ‘(y) this has the increasing label property.)
Thus the tree F(cid:66)y(cid:67) is a legal fork on the same vertex set; note that depths of vertices in F and
F(cid:66)y(cid:67) are identical.
By excising the tree rooted at y from this pinched fork F(cid:66)y(cid:67) we may extract a fork for the
string w ...w . Speciﬁcally, consider the induced subgraph Fy(cid:67) of F(cid:66)y(cid:67) given by the vertices
α+1 n
{y}∪{z | depth(z) > depth(y)}. By treating y as a root vertex and suitably deﬁning the labels
‘y(cid:67) of Fy(cid:67) so that ‘y(cid:67)(z) = ‘(z) − ‘(y), this subgraph has the deﬁning properties of a fork for
35
w ...w . In particular, considering that α is honest it follows that each honest index h > α has
α+1 n
depth d(h) > length(y) and hence labels a vertex in Fy(cid:67). For a tine t of F(cid:66)y(cid:67), we let ty(cid:67) denote
the suﬃx of this tine beginning at y, which forms a tine in Fy(cid:67). (If length(t) ≤ depth(y), we deﬁne
ty(cid:67) to consist solely of the vertex y.) Note that ty(cid:67) and ty(cid:67) share no edges in the fork Fy(cid:67).
1 2
Finally, let Fˇ denote the tree obtained from Fy(cid:67) as the union of all tines t of Fy(cid:67) so that all
labels of t are drawn from wˇ (as it appears as a preﬁx of w ...w ), and
α+1 n
length(t) ≤ max d(h).
h≤|wˇ|
hhonest
It is immediate that Fˇ ‘ wˇ. To conclude the proof, we show that Fˇ is ﬂat. For this purpose, we
consider the tines ty(cid:67) and ty(cid:67). As mentioned above, they share no edges in Fy(cid:67), and hence the
1 2
preﬁxestˇ and tˇ (of ty(cid:67) and ty(cid:67)) appearing inFˇ share no edges. We wish to see that these preﬁxes
1 2 1 2
have maximum length in Fˇ, in which case Fˇ is ﬂat, as desired. This is immediate for the tine tˇ
1
because all labels of ty(cid:67) are drawn from wˇ and, considering (14), its depth is at least that of all
1
relevant honest vertices. As for tˇ, observe that if ‘(t ) is not honest then β > ‘(t ) so that, as with
2 2 2
tˇ, the tine tˇ is labeled by wˇ so that the same argument, relying on (14), ensures that tˇ has length
1 2 2
at least that of all relevant honest vertices. If ‘(t ) is honest, β = ‘(t ), and the terminal vertex of
2 2
ty(cid:67) does not appear in Fˇ (as it does not index wˇ). In this case, however, length(ty(cid:67)) > d(h) for
2 2
any honest index of wˇ, and it follows that length(tˇ) = length(ty(cid:67))−1 is at least the depth of any
2 2
honest index of wˇ, as desired.
Theorem 4.31. Let k,L ∈ N and (cid:15) ∈ (0,1/2). Let w = w ...w of length L, where each w is
1 L i
independently distributed in {0,1} so that Pr[w = 1] = 1/2−(cid:15). Then
i
√
Pr[w does not possess k-cp] = (cid:15) (k;L,(cid:15)) = Lexp(−Ω( k)).
cp
The constant hidden by the Ω() notation depends only on (cid:15).
Proof. Recall that w violates k-cp precisely when there is a fork F ‘ w for which div(F) ≥ k. Thus
√
we wish to show that the probability that div(w) ≥ k is no more than exp(−Ω( k)+logL).
It follows from Theorem 4.30 that if div(w) ≥ k, there is a forkable substring wˇ of length at
least k. Thus
(cid:20)∃α,β ∈ {1,...,L} so that α+k−1 ≤ β and(cid:21)
Pr[w does not possess k-cp] ≤ Pr
w ...w is forkable
α β
≤ X X Pr[w ...w is forkable] .
α β
1≤α≤Lα+k−1≤β≤L
| {z }
(∗)
AccordingtoTheorem4.24theprobabilitythatastringoflengthtdrawnfromthisdistribution
√
is forkable is no more than exp(−c t) for a positive constant c. Note that for any α ≥ 1,
L √ Z ∞ √ √ √ √
X e−c t ≤ e−c tdt = (2/c2)(1+c k−1)e−c k−1 = e−Ω( k)
k−1
t=α+k−1
√
and it follows that the sum (∗) above is exp(−Ω( k)). Thus
√ √
Pr[w does not possess k-cp] ≤ L·exp(−Ω( k)) ≤ exp(lnL−Ω( k)),
as desired.
36
4.7 Security Analysis of the Idealized Protocol
Theorem 4.32. Consider the execution E of π over a lifetime of L slots with a (1/2 − (cid:15))-
iSPoS
initially-bounded adversary A and environment Z. Then persistence with parameter k fails to hold
with probability no more than
√
(cid:15) (k;L,(cid:15))+(cid:15) = L·exp(−Ω( k))+(cid:15)
CP H H
and liveness, with parameter u = 2(k+‘), fails to hold with probability no more than
(cid:15) (1/2,2k;L,(cid:15))+(cid:15) (‘;L,(cid:15))+(cid:15) = O(L·[exp(−4(cid:15)2k)+exp(−2(cid:15)2‘)])+(cid:15) ,
HCG ∃CQ H H
where (cid:15) denotes the probability of a collision across all queries to H by the participants in the
H
protocol (including A). All probabilities are conditioned on ¬Bad1/2−(cid:15) (which is to say that we
assume executions in which the adversary is (1/2−(cid:15))-bounded).
Proof. Recall that the F [F ] functionality directly provides a leader selection schedule and—
LS DSIG
for any adversarial selection of corrupted players with total stake (1/2−(cid:15))—yields a characteristic
string w = w ,...,w where each w is selected independently and E[w ] = 1/2−(cid:15). Recall that
1 L i i
• we have the luxury of an ideal signature scheme and, furthermore,
• theprobability—takenacrossallevaluationsofthehashfunctionbyallparticipantsofthepro-
tocolincludingtheadversary—thatacollisionisobservedisnomorethan(cid:15) (q) (cid:44) q2/|Range|,
H
whereq isthetotalnumberofqueriestothehashfunctionand|Range|isthesizeoftherange
of the function.
In light of these properties, unless there is an (unlikely) collision among the queries to the hash
function, theadoptedchainsformawell-deﬁnedforkF ‘ w. Weobservethatifw satisﬁescp, hcg,
A
and ∃cq, the execution E satisﬁes CP, HCG, and ∃CQ with the same parameters. (It is possible,
of course, that the execution E actually satisﬁes these properties with stronger parameters, as the
execution yields a speciﬁc fork (F ) while the abstract quantities cp, cg, and ∃cq for w are worst
A
case estimates taken over all forks.)
We observe that a violation of persistence would imply directly a violation of k-CP. As a result
Pr[E violates persistence] ≤ Pr[F violates k-cp]+(cid:15) ≤ Pr[w violates k-cp]+(cid:15)
A H H
√
≤ (cid:15) (k;L,(cid:15))+(cid:15) ≤ L·exp(−Ω( k))+(cid:15) ,
CP H H
where the last inequality follows directly from Theorem 4.31.
Now regarding liveness with parameter u = 2(k+‘), we observe that it is implied by (1/2,2k)-
HCG and ‘-∃CQ. Speciﬁcally, consider a transaction tx being provided as part of input data for a
period S of u slots. Let t be any viable tine that spans S. In light of ‘-∃CQ, t contains an honestly
generated block associated with a slot sl among the ﬁrst ‘ slots of S and—as tx was available to
1
the honest party generating this block—it must appear in t[0,sl ]. Similarly, an honest block must
1
be associated with a slot sl among the last ‘ slots of S. As u = 2(k+‘), sl ≥ sl +2k and, as a
2 2 1
consequence of (1/2,2k)-HCG, the tine t contains at least k blocks after sl (but indexed by slots
1
in S); speciﬁcally, length(t(sl ,sl ]) ≥ k. This guarantees u-liveness. Thus
1 2
Pr[E violates liveness] ≤ Pr[F violates ‘-∃cq, or (1/2,2k)-hcg]+(cid:15)
A H
≤ Pr[w violates ‘-∃cq, or (1/2,2k)-hcg]+(cid:15)
H
≤ (cid:15) (‘;L,(cid:15))+(cid:15) (1/2,2k;L,(cid:15))+(cid:15)
∃CQ HCG H
≤ L[O(exp(−2(cid:15)2‘)+O(exp(−4(cid:15)2k)]+(cid:15) ,
H
which completes the proof.
37
5 Analysis of the Dynamic Stake Protocol
5.1 Using a Trusted Beacon
Inthestaticversionoftheprotocolintheprevioussection, weassumedthatstakewasstaticduring
the whole execution (i.e., one epoch), meaning that stake changing hands inside a given epoch does
not aﬀect leader election. Now we put forth a modiﬁcation of protocol π that can be executed
SPoS
over multiple epochs in such a way that each epoch’s leader election process is parameterized by
the stake distribution at a certain designated point of the previous epoch, allowing for change in
the stake distribution across epochs to aﬀect the leader election process. As before, we construct
the protocol in a hybrid model, enhancing the F ideal functionality to now provide randomness
LS
and auxiliary information for the leader election process throughout the epochs (the enhanced
functionality will be called F ). We then discuss how to implement F using only F and in
DLS DLS LS
this way reduce the assumption back to the simple common random string selected at setup.
Beforedescribingtheprotocolforthecaseofdynamicstake,weneedtoexplainthemodiﬁcation
ofF sothatmultipleepochsareconsidered. Theresultingfunctionality,F ,allowsstakeholders
LS DLS
to query it for the leader selection data speciﬁc to each epoch. F is parameterized by the initial
DLS
stakeofeachstakeholderbeforetheﬁrstepoche starts; insubsequentepochs,partieswilltakeinto
1
considerationthestakedistributioninthelatestblockofthepreviousepoch’sﬁrstR−k0 slots(k0 is
parameterwesetbelow). Giventhatthereisnopredeterminedviewofthestakeholderdistribution,
the functionality F will provide only a random string and will leave the interpretation according
DLS
to the stakeholder distribution to the party that is calling it. The eﬀective stakeholder distribution
is the sequence S ,S ,... deﬁned as follows: S is the initial stakeholder distribution; for slots
1 2 1
{(j −1)R+1,...,jR} for j ≥ 2 the eﬀective stakeholder S is determined by the stake allocation
j
that is found in the latest block with timestamp less than (j−1)R−k0, provided all honest parties
agree on it, or is undeﬁned if the honest parties disagree on it. The functionality F is deﬁned
DLS
in Figure 9. For maximum ﬂexibility, and to anticipate the needs of the next phase of our analysis,
we allow the adversary to perform a lookahead on the beacon value for E ≥ 0 slots prior to the
onset of the epoch. To account for this lookahead the value of k0 must be suitably adjusted; see
below.
Functionality F
DLS
F incorporates the diﬀuse and key/transaction functionality from Section 2 and is parameter-
DLS
ized by the public keys and respective stakes of the initial (before epoch e starts) stakeholders
1
S = {(vk ,s0),...,(vk ,s0)} a distribution D and a leader selection function F. In addition, F
0 1 1 n n DLS
operates as follows:
• Genesis Block Generation Upon receiving (genblock req,U ) from stakeholder U it operates
i i
as functionality F on that message.
LS
• Signature Key Pair Generation It operates as functionality F .
LS
• Epoch Randomness UpdateUponreceiving(epochrnd req,U ,e )fromstakeholderU ,ifj ≥2
i j i
is the current epoch, F proceeds as follows. If ρj has not been set, F samples ρj ← D.
DLS DLS
Then, F sends (epochrnd,ρj) to U . The adversary is allowed a lookahead of E ≥ 0 slots to
DLS i
this interface where E is a parameter of the functionality.
Figure 9: Functionality F with beacon lookahead parameter E ≥ 0.
DLS
We now describe protocol π , which is a modiﬁed version of π that updates its genesis
DPoS SPoS
38
block data (and thus the leader selection process) for every new epoch. The protocol also adopts
an adaptation of the static maxvalid function, deﬁned so that it narrows selection to those chains
S
which share common preﬁx. Speciﬁcally, it adopts the following rule, parameterized by a preﬁx
length k:
Function maxvalid (C,C). Returns the longest chain from C∪{C} that does not fork
k
from C more than k blocks. If multiple exist it returns C, if this is one of them, or it
returns the one that is listed ﬁrst in C.
As a matter of notation, we simply refer to this rule as maxvalid() when the parameter can be
inferred from context.
Protocolπ isdescribedinFigure10andfunctionsintheF -hybridmodel. Wealsodeﬁne
DPoS DLS
an idealised version of this protocol π for which it holds that access to the digital signature is
iDPoS
performed via the interface of F .
DSIG
Protocol π ; with parameters k,‘,E,R,L satisfying 2(k+‘)+E ≤R.
DPoS
π isaprotocolrunbyasetofstakeholders, initiallyequaltoU ,...,U , interactingwithF over
DPoS 1 n DLS
a sequence of L slots S ={1,...,L} divided in epochs of length R<L. π proceeds as follows:
DPoS
1. Initialization Stakeholder U ∈ {U ,...,U }, receives from the key registration interface its
i 1 n
public and secret key. Then it receives the current slot from the diﬀuse interface and in case it
is sl it sends (genblock req,U ) to F , receiving (genblock,S ,ρ,F) as the answer. U sets the
1 i LS 0 i
local blockchain C =B =(S ,ρ) and the initial internal state st=H(B ). Otherwise, it receives
0 0 0
fromthekeyregistrationinterfacetheinitialchainC,setsthelocalblockchainasC andtheinitial
internal state st=H(head(C)).
2. Chain ExtensionForeveryslotsl∈S,everyonlinestakeholderU performsthefollowingsteps:
i
(a) If a new epoch e , with j ≥ 2, has started, U deﬁnes S to be the stakeholder distribution
j i j
drawn from the most recent block with timestamp less or equal to (j−1)R−2(k+‘)−E
where E ≥ 0 is the lookahead the adversary is allowed on the beacon and sends
(epochrnd req,U ,e ) to F , receiving (epochrnd,ρj) as answer.
i j LS
(b) Collect all valid chains received via broadcast into a set C, verifying that for every chain
C0 ∈CandeveryblockB0 =(st0,d0,sl0,σ0)∈C0itholdsthatVrf (σ0,(st0,d0,sl0))=1,where
vk0
vk0 is the veriﬁcation key of the stakeholder U0 = F(S ,ρj0,sl0) with e being the epoch in
j0 j0
which the block B0 belongs (as determined by sl0). U computes C0 =maxvalid(C,C), sets C0
i
as the new local chain and sets state st=H(head(C0)).
(c) If U is the slot leader determined by F(S ,ρj,sl) in the current epoch e , it generates
i j j
a new block B = (st,d,sl,σ) where st is its current state, d ∈ {0,1}∗ is the data and
σ = Sign (st,d,sl) is a signature on (st,d,sl). U computes C0 = C|B, broadcasts C0, sets
C0 as thesnkiew local chain and sets state st=H(heiad(C0)).
3. Transaction generation as in protocol π .
SPoS
Figure 10: Protocol π
DPoS
With a similar argument as in Proposition 4.9 we have the following statement.
Proposition 5.1. For each PPT A,Z it holds that there is a PPT S so that
EXECFDLS[SIG] (λ) and EXECFDLS[FDSIG](λ)
πDPoS,A,Z πiDPoS,S,Z
are computationally indistinguishable.
39
In the light of this proposition in the remaining of this section we will focus on the analysis of
iDPoS.
Remark 1. The modiﬁcation to maxvalid(·) to not diverge more than k blocks from the last chain
possessed will require stakeholders to be online at least every k slots. The relevance of the rule
comes from the fact that as stake shifts over time, it will be feasible for the adversary to corrupt
stakeholders that used to possess a stake majority at some point without triggering Bad1/2−δ and
thus any adversarial chains produced due to such an event should be rejected.
Wearenowreadytostatethemainresultofthesectionthatestablishesthattheπ protocol
DPOS
is a robust transaction ledger under the environmental conditions that we have assumed. Recall
that in the dynamic stake case we have to ensure that the adversary cannot exploit the way stake
changes over time and corrupt a set of stakeholders that will enable the control of the majority of
an elected committee of stakeholders in an epoch. In order to capture this dependency on stake
“shifts,” we introduce the following property.
Deﬁnition 5.2(Stakeshift). Considertwoslotssl ,sl andanexecutionE. The stakeshiftbetween
1 2
sl and sl is the maximum statistical distance, taken over all chains C adopted by an honest party,
1 2
of the two weighted-by-stake distributions that are deﬁned by C[0 : sl ] and C[0 : sl ].
1 2
With this deﬁnition in place we are ready to state the main theorem.
Theorem 5.3. Fix parameters k, ‘, (cid:15), σ, E, R, and L, where R ≥ 2(k + ‘) + E and L is an
integer multiple of R. Consider an execution E of π with lifetime L coupled with a (1/2−(cid:15))-
iDPoS
initially-bounded adversary A with corruption delay D = R+E +2(k +‘) and beacon lookahead
E and environment Z exhibiting a stake-shift of no more than σ over any period of ‘ slots. Then
persistence, withparameterk, andliveness, withparameteru = 2(k+‘), areviolatedwithprobability
no more than
√
h i
(cid:15) (k;L,(cid:15))+(cid:15) (1/2,2k;L,(cid:15))+(cid:15) (‘;L,(cid:15))+(cid:15) ≤ L· exp(−Ω( k))+O(exp(−2(cid:15)2‘)) +(cid:15) .
CP HCG ∃CQ H H
Here (cid:15) denotes the probability of a collision occurring among the queries to H (including those of
H
A). The above probabilities are in the conditional space ¬Bad1/2−(cid:15)−σ.
Proof. Consider an execution E generated by π with a (1/2−(cid:15))-initially-bounded adversary A
iDPoS
withcorruptiondelayD = R+E+2(k+‘)andenvironmentZ. Weimplicitlyconditionthroughout
on ¬Bad1/2−(cid:15)−σ by simply working in this conditioned probability space; we furthermore condition
on the event that there are no collisions among the queries made to the hash function by all
participants and the adversary: rather than adjusting the ambient probability space for this second
conditioning, we introduce an error term (cid:15) into our security guarantees. In terms of the random
H
variable E, we begin by deﬁning several other random variables. The most important family of
random variables capture the high-level chain properties of the protocol:
Chain guarantees. For each t, Chain is the event that, over the course of epochs numbered 1
t
through t,
• CP is satisﬁed with parameter k,
• ∃CQ is satisﬁed with parameter ‘, and
• HCG is satisﬁed with parameters (1/2,2k).
40
Weremark,byreasoningparalleltothatofTheorem4.32,thatthesepropertiesdirectlyimply
CG with parameters (k/(2k+2‘),2(k+‘)). (In particular, this guarantees growth of k blocks
over any period of 2(k+‘) slots.)
For convenience, we adopt the convention that Chain occurs by ﬁat.
0
We continue to deﬁne a number of ancillary random variables which only take on relevant values
in case Chain occurs.
t
Instantaneous common preﬁx. WhenChain occurs,thechainsadoptedbythefamilyofhonest
t
players at the outset of slot tR share a common preﬁx through slot tR−2(k+‘); we let C(t)
denote this common chain. This follows directly from the chain properties discussed above,
which guarantee k-CP and growth of k blocks over any window of 2(k+‘) slots.
The analysis below critically relies on the property that C(t) is immutable: speciﬁcally, when
Chain occurs all honest participants agree on C(t) and, as maxvalid can only revise the last
t k
k blocks of a currently adopted chain, C(t) will be a preﬁx of all future chains held by the
honest parties.
If Chain does not occur, we deﬁne C(t) = ⊥.
t
Instantaneous stake distribution; instantaneous characteristic string. S isdeﬁnedbythe
1
genesis block. For each t > 1, we deﬁne S to be the stake distribution determined by C(t−1)
t
if Chain occurs; otherwise, we set S = ⊥.
t−1 t
For each t, we deﬁne a random variable w(t) ∈ {0,1}R∪{⊥R} so that:
• If Chain occurs, then w(t) is the characteristic string associated with epoch t. More
t−1
precisely, thisisthecharacteristicstringdeﬁnedby(i)theleaderelectionscheduledeter-
minedbystakedistributionS andthebeaconρt, and(ii)thesetofpartiescorrupted, or
t
selected for corruption, by the adversary as of slot R(t−1)−E. (As we work with delay
D = R+E+2(k+‘), this includes all parties that will be under adversarial control at
any point during epoch t or the 2(k+‘) slots following this epoch.)
• If Chain does not occur, w(t) = ⊥···⊥.
t−1
| {z }
R
• For later convenience, we also identify the random variables Hon which indicate if a
t
majority of slots in epoch t are honest (which is to say that the Hamming weight of
w(t) is strictly less than R/2). Speciﬁcally, we deﬁne Hon = ⊥ if w(t) = ⊥, Hon = 1 if
t t
Pw(t) < R/2, and Hon = 0 otherwise.
i t
We let w(<t) denote the concatenation w(1)···w(t−1).
We use the word “instantaneous” above to emphasize that these random variables are deﬁned by
the state of the protocol at a particular time slot, and that the various features they describe (e.g.,
stake distributions, chains, etc.) evolve over the future course of the protocol.
We note some critical properties of these random variables.
First of all, considering that Chain ⇒ Chain for all s ≤ t, the occurrence of Chain implies that
t s t
a variety of protocol data established during these epochs persists through the rest of the protocol.
Speciﬁcally, C(1) (cid:22) ··· (cid:22) C(t) and, more generally, each C(s) is a preﬁx of the chains adopted by all
honest parties during epochs s+1,s+2,.... As a result, the honest parties unanimously agree on
the stake distribution S , for each 1 ≤ s ≤ t+1, both at the end of the epoch in which they are
s
deﬁned and throughout the rest of the protocol.
41
Continuing to discuss the ramiﬁcations of Chain , the fact that the honest parties agree on
t
S ,...,S and, of course, agree on the beacon values, yields persistent agreement on the leader
1 t+1
schedules for the ﬁrst t+1 epochs. As a matter of analysis, we remark that Chain thus unambigu-
t
ously deﬁnes the characteristic string w = w(1)...w(t+1) and a fork Ft+1 ‘ w associated with all
A
chains adopted by honest parties. Note, in particular, the graph structure of Ft+1 is simply deﬁned
A
by the unambiguous leader schedules, the structure of the chains held by honest players, the fact
that no collisions are observed by the hash function, and the ideal signature scheme. To check
that Ft+1 ‘ w, it suﬃces to ensure that any slot behaving adversarially vis-a-vis the structure of
A
the fork—for example, violating the longest chain rule or generating multiple blocks—is correctly
reﬂected by the deﬁnition of w. Note, however, that a block signed by the leader of slot i (and
associated with slot number i) can only be adopted by an honest player during the next 2(k+‘)
slots, as this is suﬃcient time for any player to accumulate a chain of length k beyond which no
alteration to slot i is possible. As w surely identiﬁes a slot as adversarial if the leader will be under
adversarial control during the following 2(k+‘) slots, this deﬁnition of w supports the fork Ft+1,
A
as desired.
We shift our attention to the distribution determined on w. Conditioned on Chain , as noted
t
above, the stake distribution S is unambiguously determined by C(t)[0 : Rt−2(k+‘)−E] (cf.
t+1
part (a) of the Chain Extension step of Figure 10). As of slot Rt−E, when the beacon is exposed
to the adversary, this chain is stable in the view of all honest parties; that is—applying ‘-∃CQ and
(1/2,2k)-HCG as above—any honest party has added at least k blocks to the chain so that it will
exist as a preﬁx of all honest parties’ chains for the remainder of the protocol. It follows that the
beacon value ρt+1 is independent of S . Consider now the adversarial stake distribution indicated
t+1
by C[0 : Rt−E −2(k +‘)]. As the last block of this chain might not be honestly generated, we
cannot directly apply the guarantee provided by Bad1/2−(cid:15)−σ to this distribution; however, in light
of ‘-∃CQ, there is an honestly generated block on C appearing no more than ‘ slots beyond the last
block of C[0 : Rt−E −2(k+‘)] so that, recalling the guarantee of σ stake shift over any ‘ slots,
the adversarial stake ratio given by C[0 : Rt−E−2(k+‘)] is no more than 1/2−(cid:15). It follows that
Pr[w(t) = 1 | w(<t),w(t),...,w(t) ] ≤ 1/2−(cid:15)
r 1 r−1
and that the fork Ft+1 determined by epoch t+1 of the protocol has the property that Ft+1 ‘
A A
w(1)...w(t+1).
To complete the proof, consider the “virtual characteristic string” x obtained by substituting
all ⊥ in w = w(1)...w(L/R) with 0. Note that if Chain fails for some t, the string w—and hence
t
the string x—must violate k-cp, ‘-∃cq, or (1/2,2k)-HCG. Observe, also, that the string x, taking
values in {0,1}L has the property that for each t
Pr[x = 1 | x ,...,x ] ≤ 1/2−(cid:15)
i 1 i−1
and hence, by Lemma 4.18, that the random variable x is stochastically dominated by the random
variable b = b ...,b ∈ {0,1}L given by independently assigning each b = 1 with probability
1 L i
exactly 1/2−(cid:15). The event that a characteristic string violates k-cp, ‘-∃cq, or (1/2,2s)-cg is clearly
monotone, asanyviolationispreservedbymonotonicallyincreasingthesetofadversarialslots. We
remark, additionally, that if a characteristic string satisﬁes k-cp then, for any z ≥ 2k, the Hamming
weight of the string is less than z/2 over any interval of z slots (otherwise there is an immediate
k-cp violation). In light of Lemma 4.19, Lemma 4.22, and Theorem 4.31, it follows that
Pr[x violates k-cp, ‘-∃cq, or (1/2,2k)-cg] ≤ Pr[b violates k-cp, ‘-∃cq, and (1/2,2k)-cg]
√
h i
≤ L O(exp(−2(cid:15)2‘)+exp(−Ω( k)) +(cid:15) .
H
42
To conclude, observe that if x satisﬁes k-cp, s-∃cq, and (1/2,2s)-cg, then Chain holds for all t and
t
hence w = x. In light of the comment above, in this case Hon is also satisﬁed for all t. It follows,
t
in this case, that E satisﬁes k-CP, ‘-∃CQ, and (1/2,2k)-CG, as desired.
These properties imply persistence with parameter k and liveness with parameter u = 2(k+‘).
Liveness and persistence for π . We observe now that Proposition 5.1 and Theorem 5.3
DPoS
can be combined to show the security of protocol π in the setting of a trusted beacon: in
DPoS
particular, if there is an attack against persistence or liveness against π , it can be transformed
DPoS
to an attack against π . It follows that π possesses the same liveness and persistence
iDPoS DPoS
properties as π , with an extra error term to account for failure of the signature scheme. We
iDPoS
omit further details as we turn our focus to the ﬁnal protocol, where we show how the beacon can
be implemented.
5.2 Simulating a Trusted Beacon
While protocol π handles multiple epochs and takes into consideration changes in the stake
DPoS
distribution, it still relies on F to perform the leader selection process. In this section, we show
DLS
how to remove the dependency to F through a Protocol π , which allows the stakeholders to
DLS DLS
compute the randomness and auxiliary information necessary in the leader election. The resulting
modiﬁed protocol that we will denote Π[π ,π ] operates in the F hybrid world.
DPoS DLS LS
Recall that the only essential diﬀerence between F and F is the continuous generation of
LS DLS
random strings ρ2,ρ3,... for epochs e ,e ,.... The idea is simple: protocol π will use a coin
2 3 DLS
tossing protocol to generate unbiased randomness that can be used to deﬁne the values ρj,j ≥ 2
bootstrapping on the initial random string and initial honest stakeholder distribution. However,
notice that the adversary could cause a simple coin tossing protocol to fail by aborting. Thus, we
build a coin tossing scheme with “guaranteed output delivery.”
Protocolπ isdescribedinFigure12andusesapubliclyveriﬁablesecretsharing(PVSS)[44].
DLS
TheresultingcombinedprotocolΠ[π ,π ]operatesasπ whileitrunsπ tosupportthe
DPoS DLS DPoS DLS
random beacon generation for each epoch. For simplicity we will describe the combined protocol in
the random oracle model, i.e., with access to a random oracle functionality F ; nevertheless, it is
RO
alsopossibletoachievealternativerealisationsthatdonotdependontherandomoracleabstraction.
WewilltakeadvantageofasimulationargumentthatwillexploitthefactthatthePVSSschemeand
thecoin-ﬂippingprotocolbuiltontopofitsimulatesaperfectbeaconwithnegligibledistinguishing
advantage. Simulation here suggests that, in the case of honest majority, there is a simulator that
interacts with the adversary and produces indistinguishable protocol transcripts when given the
beacon value after the commitment stage. While describing such a simulator is outside the scope of
our exposition, such a simulator can be inferred from the PVSS schemes of [44] or [18] realized in
the random oracle model where one can take advantage of programmability of the oracle. We note
that a random oracle is by no means necessary and it is possible to derive a simulator by taking
advantage of a “common reference string” (CRS) embedded into the genesis block.
Commitments and Coin Tossing. Acointossingprotocolallowstwoormorepartiestoobtain
auniformlyrandomstring. Aclassicapproachtoconstructsuchaprotocolisbyusingcommitment
schemes. In a commitment scheme, a committer carries out a commitment phase, which sends
evidence of a given value to a receiver without revealing it; later on, in an opening phase, the
committer can send that value to the receiver and convince it that the value is identical to the
value committed to in the commitment phase. Such a scheme is called binding if it is hard for
43
the committer to convince the receiver that he was committed to any value other than the one for
which he sent evidence in the commitment phase, and it is called hiding if it is hard for the receiver
to learn anything about the value before the opening phase. We denote the commitment phase
with randomness r and message m by Com(r,m) and the opening as Open(r,m).
In a standard two-party coin tossing protocol [11], one party starts by sampling a uniformly
random string u and sending Com(r,u ). Next, the other party sends another uniformly random
1 1
string u in the clear. Finally, the ﬁrst party opens u by sending Open(r,u ,) and both parties
2 1 1
compute output u = u ⊕u . Note, however, that in this classical protocol the committer may
1 2
selectively choose to “abort” the protocol (by not opening the commitment) once he observes the
value u . While this is an intrinsic problem of the two-party setting, we can avoid this problem
2
in the multi-party setting by relying on a veriﬁable secret sharing scheme and an honest majority
amongst the protocol participants.
Publicly Veriﬁable Secret Sharing (VSS). A secret sharing scheme allows a dealer P to
D
splitasecretσ intonshares distributedtopartiesP ,...,P , suchthatnoadversarycorruptingup
1 n
to t parties can recover σ. In a Veriﬁable Secret Sharing (VSS) scheme [26], there is the additional
guarantee that the honest parties can recover σ even if the adversary corrupts the shares held by
the parties that it controls and even if the dealer itself is malicious. We deﬁne a VSS scheme as a
pair of eﬃcient dealing and reconstruction algorithms (Deal,Rec). We are only interested in VSS
where the secret is a random string. The dealing algorithm Deal(t,n) takes as input the number of
shares to be generated n as well as a parameter t ≤ n and outputs shares σ ,...,σ of a random
1 n
value σ. The reconstruction algorithm Rec takes as input shares σ ,...,σ and outputs the secret
1 n
σ as long as no more than t shares are corrupted (unavailable shares are set to ⊥ and considered
corrupted). A publicly veriﬁable secret sharing scheme allows any third party to verify the validity
of the shares in a non-interactive way without learning the shares themselves. This is achieved by
publishing auxiliary veriﬁcation information that can later be attested to correspond to the shares
when those are revealed. Speciﬁcally, there is a Setup algorithm which is assumed to be executed
honestly, a key generation algorithm KeyGen that is executed by each shareholder resulting in a
secret and a public-key, as well as having an encryption for each σ , denoted by β , from which σ is
i i i
recoverableviathesecret-keyofthei-thstakeholderbyrunningalgorithmDecrypt. Finally, aVerify
algorithm is capable of verifying all encrypted shares using the public-key and setup information.
We refer to the discrete logarithm based PVSS of [44] or [18] for more details.
Constructing Protocol π . The main problem to be solved when realizing F with a
DLS DLS
protocol run by the stakeholders is that of generating uniform randomness for the leader selection
process while tolerating adversaries that may try to interfere by aborting or feeding incorrect
information to parties. In order to generate uniform randomness ρj for epoch e , j ≥ 2, the elected
j
stakeholders for epoch e will employ a coin tossing scheme for which all honest parties are
j−1
guaranteed to receive output as long as there is an honest majority. The protocol has two stages,
commit and reveal, and it employs two parameters k,‘. The stages of the protocol are presented
in Figure 11.
The commitment phase, consisting of 2k +3‘ slots, proceeds as follows: for 1 ≤ i ≤ R, stake-
holderU engagesinPVSSbyexecutingDeal(R,R/2)andpoststheoutputsharestotheblockchain.
i
Later, 2k + 3‘ slots after the beginning of the commitment phase, players check whether their
blockchainuptoslot‘ofthecommitmentphasecontainsproperPVSSsharesfromatleastR/2+1
of the selected stakeholders; this requires running the PVSS veriﬁcation for each commitment.
Assuming this is the case, the reveal stage commences. In the reveal stage, which lasts for ‘
44
Stakedistributiondeadline
Commit Synchronize Reveal
......... ......... ......... ......... .........
∃CQ ∃CQ HCG ∃CQ ∃CQ
‘slots ‘slots 2k slots ‘slots ‘slots
CG
Figure 11: The stages of the protocol π that use the blockchain as a broadcast channel in an
DPoS
epoch of R ≥ 2k+4‘ slots.
slots, for 1 ≤ i ≤ R, stakeholder U reveals the share it received for each commitment, cf. Protocol
i
π in Figure 12. We remark that it is possible, at the expense of expanding the length of an
DLS
epoch somewhat more, to run a more eﬃcient opening stage ﬁrst and then “force-open” only those
commitments that were kept private. Given that, optimistically, no force-open will be required, the
overall communication complexity in this case would improve.
As a prelude to the next section, we will show how π protocol implements the F func-
DLS DLS
tionality based on the F functionality and a “bulletin board” F . Speciﬁcally, the functionality
LS BB
operates as follows: it is parameterized by k,‘ and a stakeholder distribution S . Whenever one of
0
the stakeholders submits a message m this is passed to the adversary and after ‘ slots it is reported
as pending to any party querying the bulletin board. Finally after 2(k+‘) slots, all pending mes-
sages submitted before 2(k +‘) slots are ﬁnalized in some slot selected by the adversary and are
reported to any party querying the functionality together with a slot they are ﬁnalised in, which
can be anywhere from 1 up to ‘ slots later than the the slot they were originally submitted. Below
we use F as a global functionality, cf. [17].
BB
Proposition 5.4 (essentially from [44]). For each PPT A,Z it holds that there is a PPT S so that
EXECFLS,FRO,FBB(λ) and EXECFDLS,FBB(λ)
πDLS,A,Z S,Z
are computationally indistinguishable under the Computational Diﬃe Hellman assumption where
the lookahead parameter of F is set to E = ‘.
DLS
Proof. Fixing any A, the simulator S runs A and controls the honest parties’ postings with respect
to the underlying π protocol following the round structure of the protocol. We recall here the
DLS
structure of the PVSS protocol of [44]. There are public parameters g,G and each party has a
registered public-key of the form yi = Gxi. To make a commitment each party picks a random
polynomial p(·) of degree d = R/2 with coeﬃcients a ,a ,...,a . It performs a commitment
0 1 d
by publishing the values C0 = ga0,...,Cd = gad as well as Y1 = y1p(1),...,YR = yRp(R). Let
X = Qd Cij = gp(i). Using a proof of equality of discrete logarithms the party also publishes
i j=0 j
for each i, a proof that log (X ) = log (Y ). A commitment is veriﬁed by checking all proofs of
g i yi i
discrete-log equality. Note that a commitment may be opened by publishing S = Ga0 together
with a proof of equality of discrete logarithms log (S) = log (C ). The hash of the product of
G g 0
opened commitments is the value of the next beacon. The parties “force” open the commitments
of each other by publishing the values: (i,S ) with S = Yx−i 1) together with a proof of equality of
i i i
discrete-logarithms log (Y ) = log (G). Subsequently it is possible to recover each random value
Si i Yi
by computing the Lagrange coeﬃcients λ ,...,λ with respect to the indexes that are available,
1 d
say i ,...,i and compute S = Qd Sλj.
1 d j=1 ij
45
WenextdescribeasimulatedexecutionoftheprotocolthatisbasedonaDDHtuplehg,G,C,Di.
During the initial commit stage, S follows the protocol of each honest party modifying the com-
mitment C0 to be computed as Ca0 as opposed to ga0. For simplicity, assume that the adversarial
parties are 1,...,R/2. In the simulated execution, the public-keys y ,...,y are selected as
R/2+1 R
powers of g. The polynomial values p(1),...,p(R/2) are selected on behalf of the honest party
at random. Subsequently, the share encryptions yp(1),...,yp(R/2) are calculated. Note that the
1 R/2
values p(R/2 + 1),...,p(R) cannot be evaluated directly since the value p(0) is determined by
log (C ) = a ·log C which is unknown to the simulator. However it is possible for S to calculate
g 0 0 g
Y = yp(R/2+1),...,Y = yp(R)
R/2+1 R/2+1 R R
by performing Lagrange interpolation and taking advantage of the fact that log (y ) for i ∈
g i
{R/2+1,...,R} is known. Speciﬁcally, the simulator can calculate gp(R/2)+1,...,gp(R) by a suit-
able Lagrange interpolation over the bases: gp(1),...,gp(R/2),Ca0 = gp(0) and then, by raising them
to the corresponding honest party secret-keys, the simulator obtains Y ,...,Y . In a similar
R/2+1 R
manner the values C1 = ga1,...,Cd = gad can be calculated by Lagrange interpolation with the
bases gp(1),...,gp(R/2),Ca0 = gp(0). All proofs performed by S on behalf of the honest party will
be simulated taking advantage of random oracle programmability.
Observe that the PVSS opening for the honest party is equal to Da0. S follows the above
strategy for all honest parties while it receives all the PVSS values contributed by the malicious
party. At the conclusion of the 2(k +‘) round, S queries F to obtain the beacon value of the
DLS
next epoch. At this moment S is ready to program the random oracle so that the next epoch is
ﬁxed to the correct beacon value; we call this the critical moment of the simulation. Note that
programmability will be achievable provided that the value Da0 for a PVSS of an honest party can
be set to a desired random value; if this value is already deﬁned then S fails. Assuming the failure
event does not happen, given that S controls a majority of parties, it is capable of extracting the
PVSS value contributed by each malicious party; note that this requires the proper secret-key of
the honest party, which in turn requires log (G).
g
Next we argue that the failure event happens with negligible probability. For the sake of
contradiction supposethatit happenswith someprobabilityα which isnon-negligible. Weperform
the simulation as above setting the values hg,G,Ci to a given instance of the CDH problem for a
randomhonestparty. Subsequentlyatthecriticalmomentofthesimulationweterminatereturning
as output the value X1/a0 where X is a random input value in the random oracle table. Given that
the failure event happens with probability α, we conclude that this algorithm breaks CDH with
probability α/(Rq) where is q is the number of queries posed to the random oracle.
5.3 Robust Transaction Ledger
The key idea is to combine the π protocol and its ability to simulate F as shown in Proposi-
DLS DLS
tion 5.4 with the recursive argument of Theorem 5.3 observing that the blockchain itself can play
the role of the F that π requires. The resulting combined protocol Π[π ,π ] executes
BB DLS DPoS DLS
both operations of π and π in this order in each slot while it queues any messages to be
DPoS DLS
transmitted for diﬀusion by either protocol and transmits them at the end of each slot.
Theorem 5.5. Fix parameters k, ‘, E, (cid:15),σ, R, and L, where R ≥ 2k +4‘ and L is an integer
multiple of R. Consider an execution E of Π[π ,π ] with lifetime L coupled with a (1/2−(cid:15))-
DPoS DLS
initially-bounded adversary A with corruption delay D = 2R and environment Z exhibiting a stake-
46
Protocol π with parameter k,‘.
DLS
π is a protocol run by a subset of elected stakeholders each one corresponding to a slot during an
DLS
epoch e that lasts R ≥ 2k + 4‘ slots. The stakeholders without loss of generality are denoted by
j
U ,...,U and they are not necessarily distinct.
1 R
Precondition. We assume that the Setup algorithm for the PVSS has been executed and its output
is posted in F as well as each stakeholder U has performed KeyGen to obtain y ,s and posted the
BB i i i
public-key y to F . (If some of the stakeholders’ keys are missing the same protocol is executed with
i BB
R adjusted accordingly).
1. Commitment Phase (2k+3‘ slots) At slot R−2k−4‘ of epoch e , for 1≤i≤R, stakeholder
j
U performs Deal(R,R/2,y ,...,y ) to obtain the encryptions β ,...,β and posts them to F .
i 1 R 1 n BB
2. Reveal Phase(‘slots)AtslotR−‘ofepoche ,for1≤i≤R,U runsDecrypt(s ,β )torecover
j i i li
theencryptedsharesσ foranyU thatsuccessfullypostedinF R encryptedsharesthatverify
li l BB
correctly (i.e., pass Verify) and were ﬁnalized in F during the ﬁrst ‘ slots of the commitment
BB
phase. Subsequently it posts σ to the F .
li BB
The implementation of epochrnd req is then as follows.
• Giveninput(epochrnd req,U ,e ),thevaluesρj arecalculatedtobeequaltoH(Rec(σ ,...,σ ))
i j l l1 lR
assuming that U posted to F all shares correctly (otherwise ρj is set to 0). Finally the epoch
l BB l
randomness is set to ρj =⊕R ρj. The responce is then set to (epochrnd,ρj).
l=1 l
Figure 12: Protocol π using F ,F ,F and an underlying PVSS scheme.
DLS LS BB RO
shiftofσ over‘slots. Thenpersistence, withparameterk, andliveness, withparameteru = 2(k+‘),
are violated with probability no more than
√
h i
ε := L· exp(−Ω( k))+O(exp(−2(cid:15)2‘)) +(cid:15) +(L/R)(cid:15) +(cid:15) .
H DLS DSIG
Here (cid:15) denotes the probability of a collision occurring among the queries to H (including those of
H
A), (cid:15) is the distinguishing advantage of the digital signature implementation, (cid:15) is the dis-
DSIG DLS
tanceoftheDSIGimplementation. Theaboveprobabilitiesareintheconditionalspace¬Bad1/2−(cid:15)−σ.
Proof. Fix some environment Z and adversary A. As before we ﬁrst consider the execution E
of Π[π ,π ]. We consider now a modiﬁed execution E∗ where the execution of the π
iDPoS DLS DLS
protocol is substituted by the simulation that is provided due to Proposition 5.4. In this modiﬁed
execution E∗ we deﬁne the same set of random variables Chain∗ and C∗(t),Hon∗ for each epoch t as
t t
in the proof of Theorem 5.3. The stakeholder distribution for each beacon simulation that samples
the beacon for the next epoch is drawn from the immutable chain C∗(t).
The simulation might stop for two reasons. First it might be the case that the chain C∗(t) = ⊥,
i.e., the immutable chain of the stakeholders is not deﬁned and hence no stakeholder distribution
can be determined to execute the beacon protocol. The second case where it might fail is because
of a dishonest majority among the R selected stakeholders, i.e., Hon = 0.
t
We now observe that in the modiﬁed execution E∗ the proof of Theorem 5.3 can be repeated
identically and we can infer that the probability of B∗, the event that persistence or liveness is
violated or the simulation fails in E∗, is at most
√
h i
L· exp(−Ω( k))+O(exp(−2(cid:15)2‘)) +(cid:15) .
H
Now consider the event B that either persistence or liveness is violated in an execution E of the
protocol Π[π ,π ] and let t˜be the index of the earliest epoch that this takes place (or t˜= ∞
iDPoS DLS
47
if the event never happens). We deﬁne the intermediate hybrid distributions between E and E∗
denoted by E(t) for which it holds that the beacon generation in the ﬁrst t epochs is performed in
simulation as in E∗ while the remaining are performed as in E by performing π . Observe that
DLS
E(0) = E and E(L/R) = E∗. Furthermore, conditional on 1 ≤ t < t˜, it holds that the computational
distance between E(t−1) and E(t) is at most (cid:15) . It follows that the probability of B is bounded
DLS
by the probability of B∗ plus (L/R)·(cid:15) . As a result, persistence and liveness are violated in E
DLS
with probability at most
√
h i
exp(−Ω( k))+O(exp(−2(cid:15)2‘)) +(cid:15) +(L/R)·(cid:15) .
H DLS
Armed with this result, and using proposition 5.1 we can infer that there is a simulator S that
1
idealises the digital signature used in the protocol and acts as the attacker in an execution E.
(cid:12) h i h i(cid:12)
(cid:12)Pr EXECFLS[SIG],FRO (λ) −Pr EXECFLS[FDSIG],FRO (λ) (cid:12) ≤ (cid:15) .
(cid:12) Π[πDPoS,πDLS],A,Z Π[πiDPoS,πDLS],S1,Z (cid:12) DSIG
From the above it follows immediately that persistence and liveness are violated in an execution of
Π[π ,π ] with the probability stated in the theorem.
DPoS DLS
Remark 2. We note that it is easy to extend the adversarial model to include fail-stop (and recover)
corruptions in addition to Byzantine corruptions. The advantage of this mixed corruption setting,
is that it is feasible to prove that we can tolerate a large number of fail-stop corruptions (arbitrarily
above 50%). The intuition behind this is simple: the forkable string analysis still applies even if
an arbitrary percentage of slot leaders is rendered inactive. The only necessary provision for this
would be expand the parameter k inverse proportionally to the rate of non-stopped parties; if the
rate is constant asymptotically the same analysis would apply. For a further investigation in this
direction see the follow up work, Ouroboros Genesis [4].
6 Covert Adversaries
The general notion of fork deﬁned in Deﬁnition 4.11 above reﬂects the possibility that adversarial
slot leaders may broadcast multiple blocks for a single slot; such adversaries may simultaneously
extend many diﬀerent chains. While this provides the adversary signiﬁcant opportunities to in-
terfere with the protocol, it leaves a suspicious “audit trail”—multiple signed blocks for the same
slot—which conspicuously deviates from the protocol.
This motivates our consideration of a restricted class of covert adversaries, who broadcast no
more than one block per slot. Such an adversary may still deviate from the protocol by extend-
ing short chains, but does not produce such suspicious evidence and hence its strategy is more
“deniable”: it can blame network delays for its actions.6
6.1 Covert Forks, and Covertly Forkable Strings
Such an adversary yields a restricted notion of fork, deﬁned below:
Deﬁnition 6.1. Let F ‘ w be a fork for a string w ∈ {0,1}∗. We say that F is covert if the
labeling ‘ : V → {0,1,...} is injective. In particular, no adversarial index labels more than one
node.
6Contrast this with a more general adversary that attempts to fork by signing two diﬀerent blocks for the same
slot; such an adversary cannot merely blame the network for such a deviation.
48
As in the general case, we deﬁne a notion of forkable string for such adversaries.
Deﬁnition 6.2. We say that a string w is covertly forkable if there is a ﬂat covert fork F ‘ w.
Covert adversaries and forks have much simpler structure than general adversaries. In particu-
lar, a string is covertly forkable if and only if a majority of its indices are adversarial. This provides
an analogue of Proposition 4.27 for covertly forkable strings.
Proposition 6.3. A string w ∈ {0,1}n is covertly forkable if and only if wt(w) ≥ n/2.
Proof. Let w be a covertly forkable string and F ‘ w a ﬂat covert fork. As F is ﬂat, there are
two edge disjoint tines, t and t , with length equal to height(F) and it follows that the number
1 2
of vertices in F is at least 2·height(F)+1. In this covert case the labeling function is injective,
and it follows that n ≥ 2·height(F). (Recall that the root vertex is labeled by 0, which is not an
index into w.) On the other hand, the height of F is at least the number of honest indices of w.
We conclude that the length of w is at least twice the number of honest indices, as desired.
If wt(w) ≥ n/2, we can produce a ﬂat covert fork F ‘ w by placing all honest indices on a
common tine t and selecting length(t ) adversarial indices to form an edge-disjoint second tine
1 1
t .
2
As the structure of covertly forkable strings is so simple, an analogue of Theorem 4.24 for the
density of covertly forkable strings follows directly from standard large deviation bounds.
Theorem 6.4. Let (cid:15) ∈ (0,1) and let w be a string drawn from {0,1}n by independently assigning
each w = 1 with probability 1/2−(cid:15). Then
i
Pr[w is covertly forkable] = 2−Θ((cid:15)2n).
Proof. This follows from standard estimates for the cumulative density function of the binomial
distribution.
Exact probabilities of covert forkability for explicit values of n. For comparison with
the general case, we computed the probability that a string drawn from the binomial distribution
is covertly forkable. These results are presented in Figure 13. (Note that these probabilities are
simply appropriate evaluations of the cumulative density function of the binomial distribution.)
Analogous results for the general case appeared in Figure 8.
6.2 Common Preﬁx with Covert Adversaries
We revisit the notion of common preﬁx in the setting of covert adversaries. We deﬁne the covert
divergence of w to be the maximum divergence over all possible covert forks for w:
cdiv(w) = max div(F).
F‘w
F covert
As in the setting with general adversaries, we wish to establish that a string with large covert
divergence must have a large covertly forkable substring. A direct analogue of Theorem 4.31 then
implies that characteristic strings arising from π are unlikely to have large covert divergence
iSPoS
and, hence, possess the common preﬁx property against covert adversaries.
We record an analogue of Theorem 4.30 for covert adversaries.
49
Probability of Covert Forkability
y n = 500
t
ili n = 1000
b
a n = 1500
ork 0.4 n = 2000
f
t
r
e
v
o
c
f 0.2
o
y
t
i
l
i
b
a
b
o 0
r
P
0.4 0.42 0.44 0.46 0.48 0.5
Binomial distribution parameter
Figure 13: Graphs of the probability that a string drawn from the binomial distribution is
covertly forkable. Graphs for string lengths n = 500,1000,1500,2000 are shown with parameters
.40,.41,...,.49,.50.
Theorem 6.5. Let w ∈ {0,1}∗. Then there is a covertly forkable substring wˇ of w with |wˇ| ≥
cdiv(w).
Proof. We are more brief, as portions of the proof have direct analogs in the proof of Theorem 4.30.
Consider a covert fork F ‘ w and a pair of viable tines (t ,t ) of F for which ‘(t ) ≤ ‘(t ) and
1 2 1 2
t /t = cdiv(w); we assume, as in the proof of the general case, that this pair of tines minimizes
1 2
the quantity |‘(t )−‘(t )| among all pairs with divergence equal to cdiv(w).
2 1
Let y denote the last vertex on the tine t ∩ t . In contrast to the setting with a general
1 2
adversary, it is not clear that y is honest and this motivates a slightly diﬀerent choice for the
beginning of the string wˇ: deﬁne α to be the largest honest index of w on the tine t ∩ t , with the
1 2
convention that α = 0 if there is no such index. As in the proof of Theorem 4.30, deﬁne β to be
the smallest honest index of w for which β ≥ ‘(t ), with the convention that β = n+1 if there is
2
no such honest index. Then deﬁne wˇ = w ...w ; as in the proof of Theorem 4.30 it is easy
α+1 β−1
to conﬁrm that |wˇ| = (β−1)−α ≥ ‘(t )−‘(t ∩t ) ≥ cdiv(w). The remainder of the proof argues
1 1 2
that wˇ is covertly forkable.
As in the proof of Theorem 4.30, the depth d(h) of any honest index h < β is no more
than min(length(t ),length(t )): if h ≤ ‘(t ) this follows directly from the deﬁnition of viabil-
1 2 1
ity. Otherwise, ‘(t ) < h < ‘(t ) and we consider the tine t labeled with h: if length(t ) ≥
1 2 h h
min(length(t ),length(t )) then the tine t , coupled with either t or t , would produce a pair
1 2 h 1 2
of tines with divergence no less than div(t ,t ), but for which |‘(·) − ‘(·)| is strictly less than
1 2
|‘(t )−‘(t )|.
1 2
To complete the proof, we deﬁne an injective function i : H → A, where H denotes the set of
honest indices in {α+1,...,β−1} and A the complement—the set of adversarial indices of wˇ. The
existence of such a function implies that |H| ≤ |A| and hence that wˇ is covertly forkable by the
criterion given in Proposition 6.3. Let A0 ⊂ A denote the set of adversarial indices of wˇ appearing
as a label on either of the two tines t and t . The function i is deﬁned as follows: i(h), for an
1 2
honest index h ∈ H, is the smallest (adversarial) index of A0 which labels a vertex at depth equal
50
to d(h). Assuming that this function is well-deﬁned it is clearly injective, as labels cannot appear
on multiple vertices of a covert fork and depths of honest vertices are pairwise distinct.
To conﬁrm that i(h) is well-deﬁned, note that for any h ∈ H we must have d(α) < d(h) ≤
min(length(t ),length(t )) and hence there is at least one vertex v on each of t and t with depth
1 2 1 2
equal to d(h); furthermore, by the deﬁning properties of α and β, this vertex is labeled with
an index of wˇ. If d(h) ≤ length(t ∩ t ), there is a common vertex v on these tines for which
1 2
length(v) = d(h); note that this vertex cannot be honest by the deﬁnition of α, so i(h) = ‘(v) is
well-deﬁned in this case. If d(h) > length(t ∩t ), the two tines have distinct vertices at depth
1 2
d(h), and one of these must then be adversarial—thus i(h) is well-deﬁned in this case as well.
Finally, we remark that the proof of Theorem 4.31 applies with minor adaptations to the covert
case.
Theorem 6.6. Let k,R ∈ N and (cid:15) ∈ (0,1/2). Let w = w ...w be drawn in {0,1}R so that each
1 R
w independently takes the value 1 with probability 1/2−(cid:15). Then
i
Pr[cdiv(w) ≥ k] ≤ Rexp(−Ω((cid:15)2k)).
This directly bounds the probability that a covert adversay can eﬀect a common preﬁx violation in
an execution of π .
iSPoS
Proof. TheproofofTheorem4.31appliesdirectly; inthiscasetheasymptoticsrelyonTheorem6.4
and the fact that
∞ Z ∞
Xe−ct ≤ e−ctdt = O(1)·e−ck = e−ck+O(1),
k−1
t=k
where the hidden constant may depend on c, but not k.
7 Anonymous Communication and Stronger Adversaries
The protocols constructed in the previous section are proven secure against delayed adaptive cor-
ruptions, meaning that, after requesting to corrupt a given party U , the adversary has to wait for
i
D slots before the corruption actually happens. Naturally, it is desirable to make D as small as
possible, or even eliminate it altogether to achieve security against a standard adaptive adversary.
Thedelayisrequiredbecausetheadversarymustnotbeabletocorruptpartiesindirectresponse
to knowledge of the leader election schedule. (Recall that the protocol determines this schedule
on an epoch-by-epoch basis, so that such an attack would be particularly devastating.) However,
notice that the slot leaders are selected by weighting public keys by stake, while the adversary
can only choose to corrupt a user U without knowing its public key. Thus, the adversary must
i
be able to observe communication between U and the Diﬀuse functionality in order to determine
i
which public key is associated with user U and detect when U is selected as a slot leader. We will
i i
show that we can eliminate the delay by extending our model with a sender anonymous broadcast
channel (provided by the Diﬀuse functionality) and having the environment activate all parties in
every round. We introduce the following modiﬁcations in the ideal functionalities:
• Diﬀuse Functionality: The functionality will work as described in Section 2 except that it
will remove all information about the sender U of every message before delivering it to the
s
receiver U ’s inbox (input tape), thus ensuring that the sender remain anonymous.7
r
7Inpractice,asenderanonymousbroadcastchannelwithpropertiesakintothoseoftheDiﬀusefunctionalitycan
be implemented by Mix-networks [19] or DC-networks [20] that can be executed by the nodes running the protocol.
51
• Key and Transaction Functionality: The functionality will work as described in Section 2 ex-
ceptthatitwillallowimmediatecorruptionofauserU uponreceivingamessage(Corrupt,U)
from the adversary.
Apart from these modiﬁcations in the ideal functionalities, we also change the environment
behavior by requiring that it activates all users at every slot sl . Having all parties being activated
j
at every slot results in an anonymity set of size equal to the number of honest parties, making it
diﬃcult for the adversary to associate a given public key with a user (i.e., any of the honest parties
could be associated with a given public key that is not associated with a corrupted party). In this
extended model we can reprove Theorem 5.5 without a delay D by strengthening the restrictions
that are imposed on the environment in the following way.
• We will say the adversary is restricted to less than 1/2−δ relative stake for windows of length
D if for all sets of consecutive slots of length D, the sum over all corrupted keys of the
maximum stake held by each key during this period of D slots (in any possible S (r) where
j
U is an honest party) is no more than 1/2−δ of the minimum total stake during this period.
j
In case the above is violated an event Bad1/2−δ becomes true for the given execution.
D
Using the above strengthened condition, we can remove the corruption delay requirement D in
Theorem 5.5 by assuming that Bad1/2−δ is substituted with Bad1/2−δ.
D
8 Incentives
So far our analysis has focused on the cryptographic setting where a set of honest players operate
in the presence of an adversary who may corrupt some of the players. In this section we consider
the setting of a coalition of rational players and their incentives to deviate from honest protocol
operation.
8.1 Input Endorsers
In order to address incentives, we modify further our basic protocol to assign two diﬀerent roles
to stakeholders. As before, in each epoch there is a set of elected stakeholders that are the slot
leaders of the epoch responsible for issuing blocks and forming the randomness of the next epoch.
Together with those there is a (not necessarily disjoint) set of stakeholders called the endorsers.
Now each slot has two types of stakeholders associated with it: the slot leader who will issue the
block as before and the slot endorser who will endorse the input to be included in the next slot.
(We remark that one can adapt this discussion to a setting with multiple endorsers; however, we
assume a single input endorser per slot in this description.) While this seems like an insigniﬁcant
modiﬁcation it gives us a room for improvement for the following reason: endorsers’ contributions
will be acceptable even if they are d slots late, where d ∈ N is a parameter of the protocol. (In
particular, the protocol calls for slot leaders to include in their block any inputs endorsed by the
previous d endorsers and not appearing in the existing chain.) Note that blocks and endorsed
inputs are diﬀused independently with each block containing from 0 up to d endorsed inputs.
Note that in case no valid endorser input is available when the slot leader is about to issue
the block, the leader will go ahead and issue an empty block, i.e., a block without any actual
inputs (e.g., transactions in the case of a transaction ledger). Note that slot endorsers—just like
slot leaders—are selected by stake weight and are thus a representative sample of the stakeholder
population. In the case of a transaction ledger, the same transaction may be included by many
52
input endorsers simultaneously. In case that a transaction is multiply present in the blockchain
its ﬁrst occurrence only will be its “canonical” position in the ledger. The enhanced protocol,
π , can be easily seen to have the same persistence and liveness behaviour as π : the
DPOSwE DPOS
modiﬁcation with endorsers does not provide any possibility for the adversary to prevent the chain
from growing, accepting inputs, or being consistent. However, if we measure chain quality in terms
of number of endorsed inputs included this produces a more favorable result: it is easy to see that
the number of endorsed inputs originating from a set of stakeholders S in any k-long portion of
the chain is proportional to the relative stake of S with high probability. This stems from the fact
that it is suﬃcient that a single honest block is created for all the endorsed inputs of the last d
slots to be included in it. Assuming d ≥ ‘ (the ∃CQ parameter from previous sections), any set of
stakeholders S will be an endorser in a subset of the d slots with probability proportional to its
cumulative stake; the result follows.
As in bitcoin, stakeholders that issue blocks are incentivized to participate in the protocol
by collecting transaction fees. Contrary to bitcoin, of course, one does not need to incentivize
stakeholders to invest computational resources to issue blocks. Rather, availability and transaction
veriﬁcation should be incentivized. Nevertheless, they have to be incentivized to be online often.
Any stakeholder, at minimum, must be online and operational in the following circumstances.
• In the slot prior to a slot she is the elected shareholder so that she queries the network and
obtainsthecurrentlylongestblockchainaswellasanyendorsedinputstoincludeintheblock.
• In the slot during which she is the elected shareholder so that she issues the block containing
the endorsed inputs.
• In a slot during the commit stage of an epoch where she is supposed to issue the PVSS
commitment of her random string.
• In a slot during the reveal stage of an epoch where she is supposed to issue the required
opening shares.
• In general, in suﬃcient frequency, to check whether she is an elected shareholder for the next
or current epoch.
• In a slot during which she is the elected input endorser so that she issues the endorsed input
(e.g., the set of transactions) that requires processing all available transactions and verifying
them.
In order to incentivize the above actions in the setting of a transaction ledger, fees can be
collectedfromthosethatissuetransactionstobeincludedintheledgerwhichcanthenbetransfered
to the block issuers. In bitcoin, for instance, fees can be collected by the miner that produces a
block of transactions as a reward. In our setting, similarly, a reward can be given to the parties
that are issuing blocks and endorsing inputs. The reward mechanism does not have to be block
dependent as advocated in [38]. In our setting, it is possible to collect all fees of transactions
included in a sequence of blocks in a pool and then distribute that pool to all shareholders that
participatedduringtheseslots. Forexample,allinputendorsersthatwereactivemayreceivereward
proportional to the number of inputs they endorsed during a period of rounds (independently of
the actual number of transactions they endorsed). Other ways to distribute transaction fees are
also feasible (including the one that is used by bitcoin itself—even though the bitcoin method is
known to be vulnerable to attacks, e.g., the selﬁng-mining attack).
53
The reward mechanism that we will pair with input endorsers operates as follows. Let C be a
chain consisting of blocks B ,B ,.... Consider the sequence of blocks that cover the j-th epoch
0 1
denoted by B ,...,B with timestamps in {jR+1,...,(j +1)R} that contain an r ≥ 0 sequence
1 s
of endorsed inputs that originate from the j-th epoch (some of them may be included as part of
the j +1 epoch). We deﬁne the reward pool P(j) to be equal to the sum of the transaction fees
all
that are included in the endorsed inputs that correspond to the j-th epoch. If a transaction occurs
multiple times (as part of diﬀerent endorsed inputs) or even in conﬂicting versions, only the ﬁrst
occurrence of the transaction is taken into account (and is considered to be part of the ledger at
that position) in the calculation of P(j), where the total order used is induced by the order the
all
endorsed inputs that are included in C. In the sequence of these blocks, we identify by L ,...,L
1 R
the slot leaders corresponding to the slots of the epoch and by E ,...,E the input endorsers that
1 r
actively contributed the sequence of r endorsed inputs. Subsequently, the i-th stakeholder U can
i
claim a reward up to the amount
(cid:18) |{j | U = E }| |{j | U = L }|(cid:19)
β· i j +(1−β)· i j ·P(j),
r R all
where β ∈ [0,1] is a parameter of the protocol. Claiming a reward is performed by issuing a
“coinbase” type of transaction at any point after 2(k +‘) slots in a subsequent epoch to the one
that a reward is being claimed from.
Observe that the above reward mechanism has the following features: (i.) it rewards elected
committee members for just being committee members, independently of whether they issued a
block or not; (ii.) it rewards the input endorsers with the inputs that they have contributed; (iii.)
it rewards entities for epoch j after slot jR+2(k+‘).
We proceed to show that our system is a δ-Nash (approximate) equilibrium, cf. [35, Section
2.6.6]. Speciﬁcally, the theorem states that any coalition deviating from the protocol can add at
most an additive δ to its total rewards.
Atechnicaldiﬃcultyintheaboveformulationisthatthenumberofplayers, theirrelativestake,
as well as the rewards they receive are based on the transactions that are generated in the course of
the protocol execution itself. To simplify the analysis we will consider a setting where the number
of players is static, the stake they possess does not shift over time and the protocol has negligible
cost to be executed. We observe that the total rewards (and hence also utility by our assumption
on protocol costs) that any coalition V of honest players are able to extract from the execution
lasting L = tR+2(k+‘)+1 slots, is equal to
R (E) = Xt P(j) βIEVj (E) +(1−β)SLjV(E)!
V all R r
j
j=1
provided that E satisﬁes CP with parameter k, ∃CQ is satisﬁed with parameter ‘, and HCG is
satisﬁed with parameters (1/2,2k)), and where r is the total endorsed inputs emitted in the j-th
j
epoch (and possibly included at any time up to the ﬁrst ‘ slots of epoch j +1), P(j) is the reward
all
pool of epoch j, SLj (E) is the number of times a member of V was elected to be a slot leader
V
in epoch j and IEj (E) the number of times a member of V was selected to endorse an input in
V
epoch j. We set by convention the value of R (E) to 0 when E is an execution where the basic
V
underlying properties of the blockchain fail (in particular CP with parameter k, ∃CQ is satisﬁed
with parameter ‘, and HCG is satisﬁed with parameters (1/2,2k)). Finally, observe that the actual
rewards obtained by a set of rational players V in an execution E might be diﬀerent from R (E);
V
for instance, the coalition of V may never endorse a set of inputs in which case they will obtain a
smaller number of rewards.
54
Wewillestablishthefactthatourprotocolisaδ-Nashequilibriumbyprovingthatthecoalition
V,evendeviatingfromtheproperprotocolbehavior,itcannotobtainutilitythatexceedsR (E)+δ
V
for some suitable constant δ > 0.
Theorem 8.1. Fix any δ > 0 and polynomially related parameters k,‘,λ; under the same condi-
tions and restrictions as in Theorem 5.5, the honest strategy in the protocol is a δ-Nash equilibrium
against any coalition of players represented as an adversary A, provided that the maximum total
rewards P provided in all possible protocol executions is bounded by a polynomial in λ.
all
Proof. Consider a coalition of rational players V—restricted as in the statement of the theorem—
thatengagesinaprotocolexecutiontogetherwithanumberofotherplayersthatfollowtheprotocol
faithfully for a total number of L epochs. We will show that any deviation from the protocol will
not result in substantially higher rewards for V. Observe that based on Theorem 5.5, no matter
the strategy of V, with probability 1−ε for some function ε negligible in the security parameters
k,‘,λ the protocol will enable all users to obtain the rewards they are entitled to as slot leaders and
input endorsers. The latter stems from the following. First, from liveness, at least one honest block
will be included every ‘ slots and hence, in each epoch, all input endorsers that follow the protocol
will have the opportunity to enter their endorsed inputs as many times they were elected to be.
Second, the rewards received will be proportional to the times each party is an input endorser and
issued a block successfully as well as equal to the number of times it is a slot leader. As a result,
except with error ε, the utility received by coalition V is equal to R . It follows that player V has
V
expected utility at most E[R ]+εP , where P is the maximum amount of rewards produced
V All All
in any possible execution. The result follows by the assumption in the statement of the theorem
since εP ≤ δ for suﬃciently large λ.
All
Remark 3. In the above theorem, for simplicity, we assumed that protocol costs are not aﬀecting
the ﬁnal utility (in essence this means that protocol costs are assumed to be negligible). Nevertheless,
it is straightforward to extend the proof to cover a setting where a negative term is introduced in
the payoﬀ function for each player proportional to the number of times inputs are endorsed and the
number of messages transmitted for the beacon protocol. The proof would be resilient to these mod-
iﬁcations because endorsed inputs and beacon protocol messages cannot be stiﬂed by the adversary
and hence the reward function can be designed with suitable weights for such actions that oﬀsets
their cost. Still note that the rewards provided are assumed to be “ﬂat” for both slots and endorsed
inputs and thus the costs would also have to be ﬂat. We leave for future work the investigation of
a more reﬁned setting where costs and rewards are proportional to the actual computational steps
needed to verify transactions and issue blocks.
Remark 4. The reward function described, only considers the number of times an entity was an
input endorser without considering the amount of work that was put to verify the given transactions.
Furthermore it is not sensitive to whether a slot leader issued a block or not in its assigned time slot.
We next provide some context behind these choices. First suppose that slot leaders do not receive
a reward when they do not issue a block. It is easy to see that when all parties follow the protocol
the parties will receive the proportion from the reward pool that is associated to block issuance
roughly proportional to their stake. Nevertheless, a malicious coalition can easily increase the ratio
of these rewards by performing a block witholding attack (in this case this would amount to a selﬁsh
mining attack). Given that this happens with non-negligible probability a straightforward deﬁnition
of R (E) that respects this assignment is vulnerable to attack and hence a δ-Nash equilibrium
V
theorem cannot be shown. Next, we consider the case of extending the reward function so that input
endorsers that are rewarded based on the transactions they verify (as opposed to the ﬂat reward
55
we considered in the above theorem). Special care is necessary to design this function. Indeed the
straightforward way to implement it, which is if the ﬁrst input endorser to verify a transaction that
is part of the pool can make a higher claim for its fee, then there is a strategy for an adversary
to deviate from the protocol and improve its ratio of rewards: perform block withholding and/or
endorsed input censorship to remove endorsed inputs from the blockchain that originate to honest
parties. Then include the removed transactions in an endorsed input that will be transmitted in the
last possible opportunity. As before, given the attack, the natural way to deﬁne R (E) is susceptible
V
to it and hence a δ-Nash equilibrium theorem cannot be shown. A possible direction for ameliorating
this problem is to share the transaction fee of a transaction between all the input endorsers that
endorsed it. This suggests the following modiﬁcation to the protocol: whenever you are an input
endorser you should attempt to include all transactions that you have collected for a sequence of k
slots and retransmit your endorsed input in case it is removed from the main chain. We leave the
analysis of such class of reward mechanisms for future work.
9 Stake Delegation
As discussed in the previous section, stakeholders must be online in order to generate blocks when
they are selected as slot leaders. However, this might be unattractive to stakeholders with a small
stake in the system. Moreover, requiring that a majority of elected stakeholders participate in the
coin tossing protocol for refreshing randomness introduces a strain on the on the stakeholders and
the network, since it might require broadcasting and storing a large number of commitments and
shares.
We mitigate these issues by providing a method for reducing the size of the group of stakehold-
ers that engage in the coin tossing protocol. Instead of the elected stakeholders directly forming
the committee that will run coin tossing, a group of delegates will act on their behalf. In more
detail, we put forth a delegation scheme, whereby stakeholders will authorize other entities, called
delegates, who may be stakeholders themselves, to represent them in the coin tossing protocol. A
delegatemayparticipateintheprotocolonlyifitrepresentsacertainnumberofstakeholderswhose
aggregate stake exceeds a given threshold. Such a participation threshold ensures that a “fragmen-
tation” attack, that aims to increase the delegate population in order to hurt the performance of
the protocol, cannot incur a large penalty as it is capable to force the size of the committee that
runs the protocol to be small (it is worth noting that the delegation mechanism is similar to mining
pools in proof-of-work blockchain protocols).
9.1 Minimum Committee Size
To appreciate the beneﬁts of delegation, recall that in the basic protocol (π ) a committee
DPoS
member selected by weighing by stake is honest with probability 1/2+(cid:15) (this being the fraction
of the stake held by honest players). Thus, the number of honest players selected by k invocations
of weighing by stake is a binomial distribution. We are interested in the probability of a malicious
majority, which can be directly controlled by a Chernoﬀ bound. Speciﬁcally, if we let Y be the
number of times that a malicious committee member is elected then
Pr[Y ≥ k/2] = Pr[Y ≥ (1+δ)(1/2−(cid:15))k]
≤ exp(−min{δ2,δ}(1/2−(cid:15))k/4)
< exp(−δ2(1/2−(cid:15))k/4)
for δ = 2(cid:15)/(1−2(cid:15)). Assuming (cid:15) < 1/4, it follows that δ < 1.
56
Consider the case that (cid:15) = 0.05; then we have the bound exp(−0.00138 · k) which provides
an error of 1/1000 as long as k ≥ 5000. Similarly, in the case (cid:15) = 0.1, we have the bound
exp(−0.00625k) which provides the same error for k ≥ 1100.
We observe that in order to withstand a signiﬁcant number of epochs, say 215 (which, if we
equate a period with one day, will be 88 years), and require error probability 2−40, we need that
k ≥ 32648.
In cases where the wealth in the system is not concentrated among a small set of stakeholders
the above choice is bound to create a very large committee. (Of course, the maximum size of the
committee is k.)
9.2 Delegation Scheme
The concept of delegation is simple: any stakeholder can allow a delegate to generate blocks on her
behalf. In the context of our protocol, where a slot leader signs the block it generates for a certain
slot, such a scheme can be implemented in a straightforward way based on proxy signatures [12].
A stakeholder can transfer the right to generate blocks by creating a proxy signing key that
allows the delegate to sign messages of the form (st,d,sl ) (i.e., the format of messages signed in
j
Protocol π to authenticate a block). In order to limit the delegate’s block generation power
DPoS
to a certain range of epochs/slots, the stakeholder can limit the proxy signing key’s valid message
space to strings ending with a slot number sl within a speciﬁc range of values. The delegate
j
can use a proxy signing key from a given stakeholder to simply run Protocol π on her behalf,
DPoS
signing the blocks this stakeholder was elected to generate with the proxy signing key. This simple
scheme is secure due to the Veriﬁability and Prevention of Misuse properties of proxy signature
schemes, which ensure that any stakeholder can verify that a proxy signing key was actually issued
by a speciﬁc stakeholder to a speciﬁc delegate and that the delegate can only use these keys to
sign messages inside the key’s valid message space, respectively. We remark that while proxy
signatures can be described as a high level generic primitive, it is easy to construct such schemes
from standard digital signature schemes through delegation-by-proxy as shown in [12]. In this
construction, a stakeholder signs a certiﬁcate specifying the delegates identity (e.g., its public key)
and the valid message space. Later on, the delegate can sign messages within the valid message
space by providing signatures for these messages under its own public key along with the signed
certiﬁcate. As an added advantage, proxy signature schemes can also be built from aggregate
signatures in such a way that signatures generated under a proxy signing key have essentially the
same size as regular signatures [12].
An important consideration in the above setting is the fact that a stakeholder may want to
withdrawhersupporttoastakeholderpriortoitsproxysigningkeyexpiration. Observethatproxy
signing keys can be uniquely identiﬁed and thus they may be revoked by a certiﬁcate revocation
list within the blockchain.
9.2.1 Eligibility threshold
Delegation as described above can ameliorate fragmentation that may occur in the stake distribu-
tion. Nevertheless, this does not prevent a malicious stakeholder from dividing its stake to multiple
accounts and, by refraining from delegation, induce a very large committee size. To address this,
as mentioned above, a threshold T, say 1%, may be applied. This means that any delegate repre-
senting less a fraction less than T of the total stake is automatically barred from being a committee
member. This can be facilitated by redistributing the voting rights of delegates representing less
thanT to otherdelegates ina deterministicfashion (e.g., starting fromthose withthe higheststake
57
and breaking ties according to lexicographic order). Suppose that a committee has been formed,
C ,...,C , from a total of k draws of weighing by stake. Each committee member will hold k
1 m i
such votes where Pm k = k. Based on the eligibility threshold above it follows that m ≤ T−1
i=1 i
(the maximum value is the case when all stake is distributed in T−1 delegates each holding T of
the stake).
10 Attacks Discussion
We next discuss a number of practical attacks and indicate how they are reﬂected by our modeling
and mitigated.
Double spending attacks In a double spending attack, the adversary wishes to revert a trans-
action that is conﬁrmed by the network. The objective of the attack is to issue a transaction, e.g.,
a payment from an adversarial account holder to a victim recipient, have the transaction conﬁrmed
and then revert the transaction by, e.g., including in the ledger a second conﬂicting transaction.
Such an attack is not feasible under the conditions of Theorem 5.5. Indeed, persistence ensures
that once the transaction is conﬁrmed by an honest player, all other honest players from that point
on will never disagree regarding this transaction. Thus it will be impossible to bring the system to
a state where the conﬁrmed transaction is invalidated (assuming all preconditions of the theorem
hold). See the next section for an experimental discussion about double spending.
Grinding attacks In stake grinding attacks, the adversary tries to inﬂuence the slot leader
selection process to improve its chances of being selected to generate blocks (which can be used to
perform other attacks such as double spending). Basically, when generating a block that is taken
as input by the slot leader selection process, the adversary ﬁrst tests several possible block headers
and block contents in order to ﬁnd the one that gives it the best chance of being selected as a
slot leader again in the future. While this attack aﬀects PoS based cryptocurrencies that collect
randomness for the slot leader selection process from raw data in the blockchain itself (i.e. from
block headers and contents), our protocol uses a coin tossing protocol that is proven to generate
unbiased uniform randomness as discussed in Section 5.2. We show that an adversary cannot
inﬂuence the randomness generated in Figure 12, which is guaranteed to be uniformly random,
thus guaranteeing that slot leaders are selected with probability proportional to their stake.
Transaction denial (censorship) attacks In a transaction denial attack, the adversary wishes
to prevent a certain transaction from becoming conﬁrmed. For instance, the adversary may want
to target a speciﬁc account and prevent the account holder from issuing an outgoing transaction.
Such an attack is not feasible under the conditions of Theorem 5.5. Indeed, liveness ensures that,
provided the transaction is attempted to be inserted for a suﬃcient number of slots by the network,
it will be eventually conﬁrmed.
Desynchronization attacks In a desynchronization attack, a shareholder behaves honestly but
is nevertheless incapable of synchronizing correctly with the rest of the network. This leads to
ill-timed issuing of blocks and being oﬄine during periods when the shareholder is supposed to
participate. Such an attack can be mounted by preventing the party’s access to a time server or
any other mechanism that allows synchronization between parties. Moreover, a desynchronization
may also occur due to exceedingly long delays in message delivery. Our model allows parties to
become desynchronized by incorporating them into the adversary. No guarantees of liveness and
58
persistence are provided for desynchronized parties and thus we can get security as long as parties
with less than 50% of stake get desynchronized. If more than 50% parties get desynchronized our
protocol can fail. More general models like partial synchrony [23, 39] are interesting to consider
in the PoS design setting. See the follow up work, Ouroboros Praos, for more information on this
topic [22].
Eclipse attacks In an eclipse attack, message delivery to a shareholder is violated due to a
subversion in the peer-to-peer message delivery mechanism. As in the case of desynchronization
attacks, our model allows parties to be eclipse attacked by incorporating them into the adversary.
No guarantees of liveness or persistence are provided for such parties.
51% attacks A 51% attack occurs whenever the adversary controls more than the majority of
the stake in the system. It is easy to see that any sequence of slots in such a case is with very high
probability forkable and thus once the system ﬁnds itself in such setting the honest stakeholders
may be placed in diﬀerent forks for long periods of time. Both persistence and liveness can be
violated.
Bribery Attacks In bribery attacks [13], an adversary deliberately pays miners (through cryp-
tocurrency or ﬁat money) to work on speciﬁc blocks and forks, aiming at generating an arbitrary
fork that beneﬁts the adversary (e.g. by supporting a double spending attack). Miners of PoW
based cryptocurrencies do not have to own any stake in order to mine blocks, which makes this
attack strategy feasible. In this setting, if the adversary oﬀers a bribe higher than the reward
for correctly generating a block, any rational miner has a clear incentive to accept the bribe and
participate in the attack since it increases the miner’s ﬁnancial outcome. However, in our PoS
based protocol, malicious slot leaders who agree to deliberately attack the system not only risk to
forego any potential proﬁt they would earn from behaving honestly but may also risk to lose equity.
Notice that slot leaders must have money invested in the system in order to be able to generate
blocks and if an attack against the system is observed this might bring currency value down. Even
if the bribe is higher than the reward for correct behavior, the loss from currency devaluation can
easilyoﬀsetanyadditionalproﬁtsmadebyparticipatinginthisattack. Hence, briberyattacksmay
be be less eﬀective against a PoS based consensus protocol than a PoW based one. Currently our
rationality model does not formally encompass this attack strategy and investigating its eﬃcacy
against PoS based consensus protocols is left as a future work.
Long-range attacks An attacker who wishes to double spend at a later point in time can mount
a long-range attack [14] by computing a longer valid chain that starts right after the genesis block
where it is the single stakeholder actively participating in the protocol. Even if this attacker
owns a small fraction of the total stake, it can locally compute this chain generating only the
blocks for slots where it is elected the slot leader and keep generating blocks ahead of current
time until its alternative chain has more blocks than the main chain. Now, the attacker can post
a transaction to the main chain, wait for it to be conﬁrmed (and for goods to be delivered in
exchange for the transaction) and present the longer alternative chain to invalidate its previously
conﬁrmed transaction. This attack is ineﬀective against Ouroboros for two reasons: Protocol π
DLS
will only output valid leader selection data allowing for the protocol to continue if a majority of
the stakeholders participate (or have delegates participate on their behalf) and stakeholders will
reject blocks generated for slots that are far ahead of time. Since the alternative chain is generated
artiﬁcially with blocks and protocol messages generated solely by an attacker who controls a small
59
fraction of the stake, the leader selection data needed to start new epochs will be considered invalid
by other nodes. Even if the attacker could ﬁnd a strategy to generate an alternative chain with
valid leader selection data, presenting this chain and its blocks generated at slots that are far ahead
oftimewouldnotresultinasuccessfulattacksincethoseblocksfaraheadoftimewouldberejected
by the honest stakeholders and the ﬁnal alternative chain would be shorter than the main chain.
Nothing at stake attacks The “nothing at stake” problem refers in general to attacks against
PoS blockchain systems that are facilitated by shareholders continuing simultaneously multiple
blockchains exploiting the fact that little computational eﬀort is needed to build a PoS blockchain.
Provided that stakeholders are frequently online, nothing at stake is taken care of by our analysis
of forkable strings (even if the adversary brute-forces all possible strategies to fork the evolving
blockchain in the near future, there is none that is viable), and our chain selection rule that
instructs players to ignore very deep forks that deviate from the block they received the last time
they were online. It is also worth noting that, contrary to PoW-based blockchains, in our protocol
it is infeasible to have a fork generated in earnest by two shareholders. This is because slots are
uniquely assigned and thus at any given moment there is a single uniquely identiﬁed shareholder
that is elected to advance the blockchain. Players following the longest chain rule will adopt the
newly minted block (unless the adversary presents at that moment an alternative blockchain using
older blocks). It is remarked in [15] that the “tragedy of commons” might lead stakeholders in
some PoS based schemes to adhere to attacks because they do not have the power to deter attacks
by themselves and would incur ﬁnancial losses even if they did not join the attack. This would
lead rational stakeholders to accept small bribes in alternative currencies that might at least obtain
some ﬁnancial gain. However, in the incentive structure of Ouroboros, slot leaders and endorsers
who could potentially join an attack would receive rewards in both the main and the adversarial
chain, resulting in those stakeholders not achieving higher proﬁts by joining the attack.
Past majority attacks As stake moves our assumption is that only the current majority of
stakeholders is honest. This means that past account keys (which potentially do not hold any stake
at present) may be compromised. This leads to a potential vulnerability for any PoS system since a
set of malicious shareholders from the past can build an alternative blockchain exploiting such old
accounts and the fact that it is eﬀortless to build such a blockchain. In light of Theorem 5.5 such
attack can only occur against shareholders who are not frequently online to observe the evolution
of the system or in case the stake shifts are higher than what is anticipated by the preconditions
of the theorem. This can be seen a special instance of the nothing at stake problem, where the
attacker no longer owns any stake in the system and is thus free from any ﬁnancial losses when
conducting the attack.
Selﬁsh-mining In this type of attack, an attacker withholds blocks and releases them strategi-
cally attempting to drop honestly generated blocks from the main chain. In this way the attacker
reduces chain growth and increases the relative ratio of adversarially generated blocks. In conven-
tional reward schemes, as that of bitcoin, this has serious implications as it enables the attacker
to obtain a higher rate of rewards compared to the rewards it would be receiving in case it was
following the honest strategy. Using our reward mechanism however, selﬁsh mining attacks are
neutralized. The intuition behind this, is that input endorsers, who are the entities that receive
rewards proportionally to their contributions, cannot be stiﬂed because of block withholding: any
input endorser can have its contribution accepted for a suﬃciently long period of time after its
endorsement took place, thus ensuring it will be incorporated into the blockchain (due to suﬃcient
60
chain quality and chain growth). Given that input endorsers’ contributions are (approximately)
proportional to their stake this ensures that reward distribution cannot be aﬀected substantially
by block withholding.
11 Experimental Results
We have implemented a prototype instantiation of Ouroboros in Haskell as well as in the Rust-
based Parity Ethereum client in order to evaluate its concrete performance. More speciﬁcally, we
have implementedProtocolπ usingProtocolπ togenerateleader selectionparameters(i.e.,
DPoS DLS
generating fresh randomness for the weighed stake sampling procedure). For this instantiation, we
use the PVSS scheme of [44] implemented over the elliptic curve secp256r1. This PVSS scheme’s
share veriﬁcation information includes a commitment to the secret, which is also used as the
commitment speciﬁed in protocol π ; this eliminates the need for a separate commitment to
DLS
be generated and stored in the blockchain. In order to obtain better eﬃciency, the ﬁnal output ρ
of Protocol π is a uniformly random binary string of 32 bytes. This string is then used as a
DLS
seed for a PRG (ChaCha in our implementation, [10]) and stretched into R random labels of logτ
bits corresponding to each slot in an epoch. The weighing by stake leader selection process is then
implemented by using the random binary string associated to each epoch to perform the sequence
of coin-ﬂips for selecting a stakeholder. The signature scheme used for signing blocks is ECDSA,
also implemented over curve secp256r1.
11.1 Transaction Conﬁrmation Time Under Optimal Network Conditions
We ﬁrst examine the time required for conﬁrming a transaction in a setting where the network is
not under substantial load and transactions are processed as they appear.
Adversary BTC OB Covert OB General
0.10 50 3 5
0.15 80 5 8
0.20 110 7 12
0.25 150 11 18
0.30 240 18 31
0.35 410 34 60
0.40 890 78 148
0.45 3400 317 663
Figure14: Transactionconﬁrmationtimesinminutesthatachieveassurance99.9%againstahypo-
theticaldouble spendingattack withdiﬀerentlevelsofadversarialpowerfor Bitcoinand Ouroboros
(both covert and general adversaries).
In Fig. 14 we lay out a comparison in terms of transaction conﬁrmation time between Bitcoin
and Ouroboros showing how much a veriﬁer has to wait to be sure that the best possible8 double-
spending attack succeeds with probability less than 0.1%. In the case of Bitcoin, we consider a
double-spending attacker that commands a certain percentage of total hashing power and wishes
to revert a transaction. The attacker attempts to double-spend via a block-witholding attack as
described in the same paper (the attacker mines a private fork and releases it when it is long
8The “best possible” is only in the the case of Ouroboros, for Bitcoin we use the best known attack.
61
enough). In the case of Ouroboros we consider a double spending attacker that attempts to brute
force the space of all possible forks for the current slot leader distribution in a certain segment of
the protocol and commands a certain percentage of the total stake. We consider both the covert
and the general adversarial setting for Ouroboros.
Inallofthescenarios,wemeasurethenumberofminutesthatonehastowaitinordertoachieve
probability of double spending less than 0.1%. In Fig. 15 we present a graph that illustrates the
speedup graphically.
Conﬁrmation time speed up of Ouroboros over BTC
Covert
16
General
C 14
T
B
/ 12
B
O
p 10
u
d
e
e 8
p
S
6
4
0.1 0.2 0.3 0.4
Adversarial Strength of Blockwitholding Attacker
Figure 15: Ouroboros vs. Bitcoin speedup of transaction conﬁrmation time against a hypothetical
double spending attacker for assurance level 99.9%. Ouroboros is at least 10 to 5 times faster for
regular adversaries and 16 to 10 times faster for covert adversaries.
We note that the above measurements compare our Ouroboros implementation with Bitcoin
in the way the two systems are parameterized (with 10 minute block production rate for Bitcoin
and 20 second slots for Ouroboros, a conservative parameter selection). Exploring alternative
parameterizationsforBitcoin(suchasmakingtheproof-of-workeasier)canspeedupthetransaction
processing, nevertheless this cannot be done without carefully measuring the impact on overall
security.
11.2 Absolute Performance of Ouroboros
We implemented Ouroboros as an instance of the Rust-based Ethereum Parity client.9 Subse-
quently, experiments were run using Amazon’s Elastic Compute Cloud (EC2) ‘c4.2xlarge‘ instances
in the ‘us-east-1‘ region with a smaller “runner” instance responsible for coordinating each of the
“worker” instances.
Each experiment consists of several steps:
1. Each worker instance builds a clean Docker image containing a speciﬁc revision of our fork of
9Ethcore - Parity. https://ethcore.io/parity.html
62
the Parity software10 containing the Ouroboros proof-of-concept changes based on the Parity
1.6.8 release.
2. Each worker instance is started in an “isolated” mode where none of the nodes talk to each
other. During this period, a Parity account is recovered on each node and a start time for
the network is established.
3. Each worker instance is restarted in a production mode that allows communication between
the nodes and transactions to be mined.
4. A single worker instance is informed about all the other nodes. All nodes become aware of
all other nodes via Parity’s peer-to-peer discovery methods.
5. Each worker instance has a number of transactions generated and ingested.
In each experiment, 650,000 total transactions are generated between the participating nodes
who shared stake equally. The amount transferred in any given transaction is small enough to
avoid any account running out of funds. Each instance generates all the transactions using a hard-
coded shared random seed, then keeps the transactions originating from the local user account. 20
transactionsaresavedinasingleJSONﬁle, readytobedirectlypassedtotheParityRPCendpoint
using the ‘curl‘ command line tool. During ingestion, a single ﬁle of 20 transactions is ingested
and one second is spent idle between each ﬁle to avoid overwhelming the instances with too many
requests.
Various setups were tested, focusing on adjusting the Ouroboros slot duration and the number
of participating nodes. 10, 20, 30, and 40 nodes were tested, ultimately limited by the number of
instances allowed in a single EC2 region. Slot durations of 5, 10, and 20 seconds were also tested.
Variance between experiments was small. In Figure 16 we present the case of 40 nodes and slot
length of 5 seconds that exhibits a median value of 257.6 transaction per second.
12 Acknowledgements
We thank Ioannis Konstantinou who contributed in a preliminary version of our protocol. We
thank Lars Bru¨njes, Duncan Coutts, and Kawin Worrasangasilpa for comments on previous drafts
of the article. We thank Peter Gaˇzi for comments on previous drafts of the article and assisting
us to generalize Theorem 4.30 to viable forks. We thank Saad Quader for noting an inconsistency
in previous deﬁnitions of common preﬁx and divergence and assisting us to adapt Theorem 4.30.
We thank George Agapov for the prototype implementation of our protocol in Haskell and Jake
Goulding for the Parity based implementation.
References
[1] Noga Alon and Joel Spencer. The Probabilistic Method. Wiley, 3rd edition, 2008.
[2] Giuseppe Ateniese, Ilario Bonacina, Antonio Faonio, and Nicola Galesi. Proofs of space:
When space is of the essence. In Michel Abdalla and Roberto De Prisco, editors, Security and
CryptographyforNetworks-9thInternationalConference, SCN2014, Amalﬁ, Italy, September
10Available from https://github.com/input-output-hk/parity/tree/experiment-2
(020fd77dc70d3f25e0e0f44bd6b1e19ccf3790d3)
63
Figure 16: Measuring transactions per second in a 40 node, equal stake deployment with slot
length of 5 seconds.
3-5, 2014. Proceedings, volume 8642 of Lecture Notes in Computer Science, pages 538–557.
Springer, 2014.
[3] Yonatan Aumann and Yehuda Lindell. Security against covert adversaries: Eﬃcient protocols
for realistic adversaries. J. Cryptology, 23(2):281–343, 2010.
[4] Christian Badertscher, Peter Gazi, Aggelos Kiayias, Alexander Russell, and Vassilis Zikas.
Ouroboros genesis: Composable proof-of-stake blockchains with dynamic availability. In
David Lie, Mohammad Mannan, Michael Backes, and XiaoFeng Wang, editors, Proceedings of
the 2018 ACM SIGSAC Conference on Computer and Communications Security, CCS 2018,
Toronto, ON, Canada, October 15-19, 2018, pages 913–930. ACM, 2018.
[5] Christian Badertscher, Peter Gaˇzi, Aggelos Kiayias, Alexander Russell, and Vassilis Zikas.
Ouroboroschronos: Permissionlessclocksynchronizationviaproof-of-stake.Manuscript.,2019.
[6] IddoBentov,ArielGabizon,andAlexMizrahi. Cryptocurrencieswithoutproofofwork. CoRR,
abs/1406.5694, 2014.
[7] Iddo Bentov, Charles Lee, Alex Mizrahi, and Meni Rosenfeld. Proof of activity: Extending
bitcoin’s proof of work via proof of stake [extended abstract]y. SIGMETRICS Performance
Evaluation Review, 42(3):34–37, 2014.
[8] Iddo Bentov, Rafael Pass, and Elaine Shi. The sleepy model of consensus. IACR Cryptology
ePrint Archive, 2016:918, 2016.
[9] Iddo Bentov, Rafael Pass, and Elaine Shi. Snow white: Provably secure proofs of stake. IACR
Cryptology ePrint Archive, 2016:919, 2016.
[10] Daniel J. Bernstein. Chacha, a variant of salsa20. In SASC: The State of the Art of Stream
Ciphers., 2008.
64
[11] Manuel Blum. Coin ﬂipping by telephone. In Allen Gersho, editor, Advances in Cryptology: A
Report on CRYPTO 81, CRYPTO 81, IEEE Workshop on Communications Security, Santa
Barbara, California, USA, August 24-26, 1981., pages 11–15. U. C. Santa Barbara, Dept. of
Elec. and Computer Eng., ECE Report No 82-04, 1981.
[12] AlexandraBoldyreva,AdrianaPalacio,andBogdanWarinschi. Secureproxysignatureschemes
for delegation of signing rights. J. Cryptology, 25(1):57–115, 2012.
[13] Joseph Bonneau. Why buy when you can rent? - bribery attacks on bitcoin-style consensus.
In Jeremy Clark, Sarah Meiklejohn, Peter Y. A. Ryan, Dan S. Wallach, Michael Brenner,
and Kurt Rohloﬀ, editors, Financial Cryptography and Data Security - FC 2016 International
Workshops, BITCOIN, VOTING, and WAHC, Christ Church, Barbados, February 26, 2016,
Revised Selected Papers, volume 9604 of Lecture Notes in Computer Science, pages 19–26.
Springer, 2016.
[14] Vitalik Buterin. Long-range attacks: The serious problem with adaptive proof of
work. https://blog.ethereum.org/2014/05/15/long-range-attacks-the-serious-problem-with-
adaptive-proof-of-work/, 2014.
[15] Vitalik Buterin. Proof of stake faq. https://github.com/ethereum/wiki/wiki/Proof-of-Stake-
FAQ, 2016.
[16] Ran Canetti. Universally composable signature, certiﬁcation, and authentication. In 17th
IEEE Computer Security Foundations Workshop, (CSFW-17 2004), 28-30 June 2004, Paciﬁc
Grove, CA, USA, page 219. IEEE Computer Society, 2004.
[17] Ran Canetti, Yevgeniy Dodis, Rafael Pass, and Shabsi Walﬁsh. Universally composable se-
curity with global setup. In Salil P. Vadhan, editor, Theory of Cryptography, 4th Theory of
Cryptography Conference, TCC 2007, Amsterdam, The Netherlands, February 21-24, 2007,
Proceedings, volume 4392 of Lecture Notes in Computer Science, pages 61–85. Springer, 2007.
[18] Ignacio Cascudo and Bernardo David. SCRAPE: scalable randomness attested by public enti-
ties. In Dieter Gollmann, Atsuko Miyaji, and Hiroaki Kikuchi, editors, Applied Cryptography
and Network Security - 15th International Conference, ACNS 2017, Kanazawa, Japan, July
10-12, 2017, Proceedings, volume 10355 of Lecture Notes in Computer Science, pages 537–556.
Springer, 2017.
[19] David Chaum. Untraceable electronic mail, return addresses, and digital pseudonyms. Com-
mun. ACM, 24(2):84–88, 1981.
[20] David Chaum. The dining cryptographers problem: Unconditional sender and recipient un-
traceability. J. Cryptology, 1(1):65–75, 1988.
[21] George Danezis and Sarah Meiklejohn. Centrally banked cryptocurrencies. In 23nd Annual
Network and Distributed System Security Symposium, NDSS 2016, San Diego, California,
USA, February 21-24, 2016. The Internet Society, 2016.
[22] Bernardo Machado David, Peter Gazi, Aggelos Kiayias, and Alexander Russell. Ouroboros
praos: An adaptively-secure, semi-synchronous proof-of-stake protocol. IACR Cryptology
ePrint Archive, 2017:573, 2017.
[23] Cynthia Dwork, Nancy A. Lynch, and Larry J. Stockmeyer. Consensus in the presence of
partial synchrony. J. ACM, 35(2):288–323, 1988.
65
[24] StefanDziembowski,SebastianFaust,VladimirKolmogorov,andKrzysztofPietrzak. Proofsof
space. InRosarioGennaroandMatthewRobshaw,editors,Advances in Cryptology - CRYPTO
2015-35thAnnualCryptologyConference, SantaBarbara, CA,USA,August16-20, 2015, Pro-
ceedings, Part II,volume9216ofLecture Notes in Computer Science, pages585–605.Springer,
2015.
[25] IttayEyalandEminGunSirer. Majorityisnotenough: Bitcoinminingisvulnerable. InAnge-
los D. Keromytis, editor, Financial Cryptography, volume 7397 of Lecture Notes in Computer
Science. Springer, 2014.
[26] Paul Feldman. A practical scheme for non-interactive veriﬁable secret sharing. In 28th Annual
SymposiumonFoundationsofComputerScience, LosAngeles, California, USA,27-29October
1987, pages 427–437. IEEE Computer Society, 1987.
[27] Bryan Ford. Delegative democracy. http://www.brynosaurus.com/deleg/deleg.pdf, 2002.
[28] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Anal-
ysis and applications. In Elisabeth Oswald and Marc Fischlin, editors, Advances in Cryptology
- EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications
of Cryptographic Techniques, Soﬁa, Bulgaria, April 26-30, 2015, Proceedings, Part II, volume
9057 of Lecture Notes in Computer Science, pages 281–310. Springer, 2015.
[29] Charles M Grinstead and J Laurie Snell. Introduction to Probability. American Mathematical
Society, 2nd edition, 1997.
[30] Aggelos Kiayias and Giorgos Panagiotakos. Speed-security tradeoﬀs in blockchain protocols.
Cryptology ePrint Archive, Report 2015/1019, 2015. http://eprint.iacr.org/2015/1019.
[31] Silvio Micali. ALGORAND: the eﬃcient and democratic ledger. CoRR, abs/1607.01341, 2016.
[32] Tal Moran and Ilan Orlov. Proofs of space-time and rational proofs of storage. Cryptology
ePrint Archive, Report 2016/035, 2016. http://eprint.iacr.org/2016/035.
[33] Rajeev Motwani and Prabhakar Raghavan. Randomized Algorithms. Cambridge University
Press, New York, NY, USA, 1995.
[34] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system.
http://bitcoin.org/bitcoin.pdf, 2008.
[35] NoamNisan,TimRoughgarden,EvaTardos,andVijayV.Vazirani.AlgorithmicGameTheory.
Cambridge University Press, New York, NY, USA, 2007.
[36] Karl J. O’Dwyer and David Malone. Bitcoin mining and its energy footprint. ISSC 2014 /
CIICT 2014, Limerick, June 26–27, 2014.
[37] SunooPark, KrzysztofPietrzak, AlbertKwon, Jo¨elAlwen, GeorgFuchsbauer, andPeterGazi.
Spacemint: A cryptocurrency based on proofs of space. IACR Cryptology ePrint Archive,
2015:528, 2015.
[38] Rafael Pass. Cryptography and game theory. Securty and Cryptography for Networks, 2016,
invited talk., 2016.
[39] RafaelPass,LiorSeeman,andAbhiShelat.Analysisoftheblockchainprotocolinasynchronous
networks. IACR Cryptology ePrint Archive, 2016:454, 2016.
66
[40] Rafael Pass and Elaine Shi. Fruitchains: A fair blockchain. IACR Cryptology ePrint Archive,
2016:916, 2016.
[41] Joseph Poon and Thaddeus Dryja. The bitcoin lightning network: Scalable oﬀ-chain instant
payments. https://lightning.network/lightning-network-paper.pdf, January 2016.
[42] Alexander Russell, Cristopher Moore, Aggelos Kiayias, and Saad Quader. Forkable strings are
rare. Cryptology ePrint Archive, Report 2017/241, March 2017. http://eprint.iacr.org/
2017/241.
[43] Ayelet Sapirshtein, Yonatan Sompolinsky, and Aviv Zohar. Optimal selﬁsh mining strategies
in bitcoin. CoRR, abs/1507.06183, 2015.
[44] Berry Schoenmakers. A simple publicly veriﬁable secret sharing scheme and its application
to electronic voting. In Michael J. Wiener, editor, Advances in Cryptology - CRYPTO ’99,
19th Annual International Cryptology Conference, Santa Barbara, California, USA, August
15-19, 1999, Proceedings, volume 1666 of Lecture Notes in Computer Science, pages 148–164.
Springer, 1999.
A Remarks on Forkable Strings and Divergence
The analysis in the paper demonstrates that if w ∈ {0,1}n is forkable, then there is in fact a ﬂat
fork F ‘ w with the extra property that F has no more than two “components,” which is to say
that there are two non-empty tines p and q with the property that for any non-empty tine r of F,
either r ∼ p or r ∼ q. It is natural to ask whether “two tines suﬃce,” which is to say that there is
always a ﬂat fork F ‘ w which is the union of two tines.
In fact, there are forkable strings which require three tines to fork. Speciﬁcally, consider the
string
w = 02k1k(1001)1k02k.
The ﬂat fork shown in Figure 17 below proves that w is forkable. However, no two tines can
successfully fork w.
w = 0 ··· 0 1 ··· 1 (1 0 0 1) 1 ··· 1 0 ··· 0
Figure 17: A fork F for the string w = 02k1k(1001)1k02k; honest vertices are highlighted with
double borders.
67
