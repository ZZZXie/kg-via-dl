Chainlink 2.0: Next Steps in the Evolution of Decentralized Oracle Networks 
Lorenz Breidenbach1 Christian Cachin2 Benedict Chan1 Alex Coventry1 Steve Ellis1 Ari Juels3 Farinaz Koushanfar4 Andrew Miller5 Brendan Magauran1 Daniel Moroz6 Sergey Nazarov1 Alexandru Topliceanu1 Florian Tram`er7 Fan Zhang8 
15 April 2021 
v1.0 
1Chainlink Labs 
2The author is a faculty member at University of Bern. He co-authored this work in his separate capacity as an advisor to Chainlink Labs. 
3The author is a faculty member at Cornell Tech. He co-authored this work in his separate capacity as Chief Scientist at Chainlink Labs. 
4The author is a faculty member at University of California, San Diego. She co-authored this work in her separate capacity as an advisor to Chainlink Labs. 
5The author is a faculty member at University of Illinois Urbana-Champaign. He co-authored this work in his separate capacity as an advisor on Chainlink. 
6The author is a PhD candidate at Harvard University. He co-authored this work while on leave from Harvard, in his capacity as a researcher at Chainlink Labs. 
7The author is a PhD candidate at Stanford University. He co-authored this work in his separate capacity as an advisor to Chainlink Labs. 
8The author will be joining the faculty of Duke University in fall 2021. He co-authored this work in his current capacity as a researcher at Chainlink Labs. 
1
Abstract 
In this whitepaper, we articulate a vision for the evolution of Chainlink be yond its initial conception in the original Chainlink whitepaper. We foresee an increasingly expansive role for oracle networks, one in which they comple ment and enhance existing and new blockchains by providing fast, reliable, and confidentiality-preserving universal connectivity and off-chain computation for smart contracts. 
The foundation of our plan is what we call Decentralized Oracle Networks, or DONs for short. A DON is a network maintained by a committee of Chainlink nodes. It supports any of an unlimited range of oracle functions chosen for deployment by the committee. A DON thus acts as a powerful abstraction layer, offering interfaces for smart contracts to extensive off-chain resources and highly efficient yet decentralized off-chain computing resources within the DON itself. 
With DONs as a springboard, Chainlink plans to focus on advances in seven key areas: 
• Hybrid smart contracts: Offering a powerful, general framework for aug menting existing smart contract capabilities by securely composing on-chain and off-chain computing resources into what we call hybrid smart contracts. 
• Abstracting away complexity: Presenting developers and users with simple functionality eliminates the need for familiarity with complex underlying protocols and system boundaries. 
• Scaling: Ensuring that oracle services achieve the latencies and throughputs demanded by high-performance decentralized systems. 
• Confidentiality: Enabling next-generation systems that combine blockchains’ innate transparency with strong new confidentiality protections for sensitive data. 
• Order-fairness for transactions: Supporting transaction sequencing in ways that are fair for end users and prevent front-running and other attacks by bots and exploitative miners. 
• Trust-minimization: Creating a highly trustworthy layer of support for smart contracts and other oracle-dependent systems by means of decen tralization, strong anchoring in high-security blockchains, cryptographic techniques, and cryptoeconomic guarantees. 
• Incentive-based (cryptoeconomic) security: Rigorously designing and ro bustly deploying mechanisms that ensure nodes in DONs have strong eco nomic incentives to behave reliably and correctly, even in the face of well resourced adversaries. 
We present preliminary and ongoing innovations by the Chainlink community in each of these areas, providing a picture of the broadening and increasingly powerful capabilities planned for the Chainlink network. 
2
Contents 
1 Introduction 6 1.1 Decentralized Oracle Networks . . . . . . . . . . . . . . . . . . . . . . . 7 1.2 Seven Key Design Goals . . . . . . . . . . . . . . . . . . . . . . . . . . 8 1.3 Organization of this Paper . . . . . . . . . . . . . . . . . . . . . . . . . 19 
2 Security Model and Goals 19 2.1 Current Architectural Model . . . . . . . . . . . . . . . . . . . . . . . . 20 2.2 Consensus Assumptions . . . . . . . . . . . . . . . . . . . . . . . . . . 20 2.3 Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 2.4 Note on Trust Models . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 
3 Decentralized Oracle Network Interface and Capabilities 23 3.1 Networking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 3.2 Computation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 3.3 Storage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 3.4 Transaction-Execution Framework (TEF) . . . . . . . . . . . . . . . . . 27 3.5 Mempool Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 3.6 Stepping Stones: Existing Chainlink Capabilities . . . . . . . . . . . . . 29 
3.6.1 Off-Chain Reporting (OCR) . . . . . . . . . . . . . . . . . . . . 29 3.6.2 DECO and Town Crier . . . . . . . . . . . . . . . . . . . . . . . 30 3.6.3 Existing On-Chain Chainlink Services . . . . . . . . . . . . . . . 31 3.6.4 Node Reputation / Performance History . . . . . . . . . . . . . 33 
4 Decentralized Services Enabled by Decentralized Oracle Networks 34 4.1 Proof of Reserves . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 4.2 Interfacing with Enterprise / Legacy Systems . . . . . . . . . . . . . . 35 4.3 Decentralized Identity . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 4.4 Priority Channels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 4.5 Confidentiality-Preserving DeFi / Mixicles . . . . . . . . . . . . . . . . 41 
5 Fair Sequencing Services 43 5.1 The Front-Running Problem . . . . . . . . . . . . . . . . . . . . . . . . 45 5.1.1 Oracle Front-Running . . . . . . . . . . . . . . . . . . . . . . . 45 5.1.2 Front-Running User Transactions . . . . . . . . . . . . . . . . . 47 5.2 FSS Details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48 5.2.1 Transaction Processing . . . . . . . . . . . . . . . . . . . . . . . 48 5.2.2 Transaction Atomicity . . . . . . . . . . . . . . . . . . . . . . . 51 5.3 Fair Transaction Sequencing . . . . . . . . . . . . . . . . . . . . . . . . 53 5.4 Network-Layer Considerations . . . . . . . . . . . . . . . . . . . . . . . 56 5.5 Entity-Level Fairness Policies . . . . . . . . . . . . . . . . . . . . . . . 57 
3
6 The DON Transaction-Execution Framework 
(DON-TEF) 57 6.1 TEF Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 6.2 Transaction Routing . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 6.3 Syncing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 6.4 Reorgs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 
7 Trust Minimization 65 7.1 Data-Source Authentication . . . . . . . . . . . . . . . . . . . . . . . . 65 7.1.1 The Limitations of Authenticated Data Origination . . . . . . . 67 7.1.2 Confidentiality . . . . . . . . . . . . . . . . . . . . . . . . . . . 67 7.1.3 Combining Source Data . . . . . . . . . . . . . . . . . . . . . . 68 7.1.4 Processing Source Data . . . . . . . . . . . . . . . . . . . . . . . 69 7.2 DON Trust Minimization . . . . . . . . . . . . . . . . . . . . . . . . . . 70 7.2.1 Failover Clients . . . . . . . . . . . . . . . . . . . . . . . . . . . 70 7.2.2 Minority Reports . . . . . . . . . . . . . . . . . . . . . . . . . . 70 7.3 Guard Rails . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 7.4 Trust-Minimized Governance . . . . . . . . . . . . . . . . . . . . . . . . 72 7.5 Public-Key Infrastructure . . . . . . . . . . . . . . . . . . . . . . . . . 73 
8 DON Deployment Considerations 75 8.1 Rollout Approach . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 8.2 Dynamic DON Membership . . . . . . . . . . . . . . . . . . . . . . . . 76 8.3 DON Accountability . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 
9 Economics and Cryptoeconomics 78 9.1 Staking Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81 9.2 Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 9.3 Modeling Assumptions . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 
9.3.1 First-Tier Incentive Model: Rational Actors . . . . . . . . . . . 85 9.3.2 Second-Tier Adjudication Model: Correctness by Assumption . 85 9.3.3 Adversarial Model . . . . . . . . . . . . . . . . . . . . . . . . . 86 9.3.4 How Much Cryptoeconomic Security Is Enough? . . . . . . . . . 87 
9.4 Staking Mechanism: Sketch . . . . . . . . . . . . . . . . . . . . . . . . 87 9.4.1 Further Mechanism Details . . . . . . . . . . . . . . . . . . . . . 89 9.4.2 Quadratic Staking Impact . . . . . . . . . . . . . . . . . . . . . 90 9.4.3 Realization of Second Tier . . . . . . . . . . . . . . . . . . . . . 91 9.4.4 Misreporting Insurance . . . . . . . . . . . . . . . . . . . . . . . 93 
9.5 Single-Round Variant . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94 9.6 Implicit-Incentive Framework (IIF) . . . . . . . . . . . . . . . . . . . . 95 9.6.1 Future Fee Opportunity . . . . . . . . . . . . . . . . . . . . . . 96 9.6.2 Speculative FFO . . . . . . . . . . . . . . . . . . . . . . . . . . 97 9.6.3 External Reputation . . . . . . . . . . . . . . . . . . . . . . . . 98 
4
9.6.4 Open IIF Analytics . . . . . . . . . . . . . . . . . . . . . . . . . 98 9.7 Putting It All Together: Node Operator Incentives . . . . . . . . . . . 99 9.8 The Virtuous Cycle of Economic Security . . . . . . . . . . . . . . . . . 100 9.9 Additional Factors Driving Network Growth . . . . . . . . . . . . . . . 101 
10 Conclusion 102 A Glossary 116 
B DON Interface: Further Details 119 B.1 Networking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119 B.1.1 Integrity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120 B.1.2 Confidentiality . . . . . . . . . . . . . . . . . . . . . . . . . . . 121 B.1.3 Availability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122 B.2 Computation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122 B.2.1 Trusted Execution Environments (TEEs) . . . . . . . . . . . . . 122 B.2.2 TEE Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123 B.2.3 Secure Multi-Party Computation (MPC) . . . . . . . . . . . . . 124 B.3 Storage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125 B.4 Resource Pricing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125 
C Adapter Examples 126 C.1 Oracle-Mediated Data-Source Access (MediatedReport) . . . . . . . . . 126 C.2 Cross-Ledger Reports (XL-Report-Read) . . . . . . . . . . . . . . . . . . 127 C.3 Confidential Switch (ConfSwitch) . . . . . . . . . . . . . . . . . . . . . 128 
D Functional Signatures 129 D.1 Functional Signatures for Combining Data . . . . . . . . . . . . . . . . 130 D.2 Discretized Functional Signatures . . . . . . . . . . . . . . . . . . . . . 130 
E Prospective Bribery 134 F Random vs. Committee-Based Oracle Selection 135 
5
1 Introduction 
Blockchain oracles are often viewed today as decentralized services with one objective: to forward data from off-chain resources onto blockchains. It’s a short step, though, from forwarding data to computing on it, storing it, or transmitting it bidirection ally. This observation justifies a much broader notion of oracles’ functionality. So too do the growing service requirements of smart contracts and increasingly multifaceted technologies that rely on oracle networks. In short, an oracle can and will need to be a general-purpose, bidirectional, compute-enabled interface between and among on chain and off-chain systems. Oracles’ role in the blockchain ecosystem is to enhance the performance, functionality, and interoperability of smart contracts so that they can bring new trust models and transparency to a multiplicity of industries. This transfor mation will come about through broadening use of hybrid smart contracts, which fuse blockchains’ special properties with the unique capabilities of off-chain systems such as oracle networks and thereby achieve far greater reach and power than on-chain systems in isolation. 
In this whitepaper, we articulate a vision for what we call Chainlink 2.0, an evo lution of Chainlink beyond its initial conception in the original Chainlink whitepa per [98]. We foresee an increasingly expansive role for oracle networks, one in which they complement and enhance existing and new blockchains by providing fast, reli able, and confidentiality-preserving universal connectivity and computation for hybrid smart contracts. We believe that oracle networks will even evolve to become utilities for exporting high-integrity blockchain-grade data to systems beyond the blockchain ecosystem. 
Today, Chainlink nodes run by a diverse set of entities come together in oracle net works to relay data to smart contracts in what are known as reports. We can view such oracle nodes as a committee similar to that in a classical-consensus blockchain [72], but with the goal of supporting existing blockchains, rather than providing freestand ing functionality. With verifiable random functions (VRF) and Off-Chain Reporting (OCR), Chainlink is already evolving toward a general-purpose framework and infras tructure for providing the computational resources that smart contracts require for advanced functionality. 
The foundation of our plan for Chainlink 2.0 is what we call Decentralized Oracle Networks, or DONs for short. Since we introduced the term “oracle network” in the original Chainlink whitepaper [98], oracles have developed ever richer functionality and breadth of application. In this paper, we offer a fresh definition of the term according to our future vision for the Chainlink ecosystem. In this view, a DON is a network maintained by a committee of Chainlink nodes. Rooted in a consensus protocol, it supports any of an unlimited range of oracle functions chosen for deployment by the committee. A DON thus acts as a blockchain abstraction layer, providing interfaces to off-chain resources for both smart contracts and other systems. It also provides access to highly efficient yet decentralized off-chain computing resources. In general, a DON supports operations on a main chain. Its goal is to enable secure and flexi 
6
ble hybrid smart contracts, which combine on-chain and off-chain computation with connection to external resources. 
We emphasize that even with the use of committees in DONs, Chainlink itself remains inherently permissionless. DONs act as the foundation of a permissionless framework in which nodes can come together to implement custom oracle networks with their own regimes for node inclusion, which may be permissioned or permissionless. 
With DONs as a foundation, we plan to focus in Chainlink 2.0 on advances in seven key areas: hybrid smart contracts, abstracting away complexity, scaling, confidential ity, order-fairness for transactions, trust minimization, and incentive-based (cryptoeco nomic) security. In this paper introduction, we present an overview of Decentralized Oracle Networks in Section 1.1 and then our seven key areas of innovation in Sec tion 1.2. We describe the organization of the rest of this paper in Section 1.3. 
1.1 Decentralized Oracle Networks 
Decentralized Oracle Networks are designed to enhance and extend the capabilities of smart contracts on a target blockchain or main chain through functions that are not available natively. They do so by providing the three basic resources found in computing systems: networking, storage, and computation. A DON aims to offer these resources with strong confidentiality, integrity, and availability properties,1 as well as accountability. 
DONs are formed by committees of oracle nodes that cooperate to fulfill a specific job or choose to establish a long-lived relationship in order to provide persistent services to clients. DONs are designed in a blockchain-agnostic way. They promise to serve as a powerful and flexible tool for application developers to create off-chain support for their smart contracts on any supported main chain. 
Two types of functionalities realize the capabilities of a DON: executables and adapters. Executables are programs that run continuously and in a decentralized man ner on the DON. While they do not directly store main-chain assets, they have im portant benefits, including high performance and the ability to perform confidential computation. Executables run autonomously on a DON and perform deterministic operations. They work in hand with adapters that link the DON to external resources and may be called by executables. Adapters, as we envision them for DONs, are a generalization of the external adapters in Chainlink today. While existing adapters typically only fetch data from data sources, adapters may operate bidirectionally; in DONs, they may additionally leverage joint computation by DON nodes to achieve additional features, such as encrypting reports for privacy-preserving consumption by an executable. 
To provide a sense of a DON’s basic operation, Fig. 1 shows conceptually how a DON might be used to send reports to a blockchain and thus achieve traditional, exist ing oracle functionality. DONs can provide many additional features, however, beyond 
1The “CIA triad” of information security [123, p. 26, §2.3.5]. 
7
Chainlink’s existing networks. For example, within the general structure of Fig. 1, the executable could record fetched asset-price data on the DON, using such data to compute, e.g., a trailing average for its reports. 

Figure 1: Conceptual figure showing as an example how a Decentralized Oracle Net work can realize basic oracle functionality, i.e., relay off-chain data to a contract. An executable uses adapters to fetch off-chain data, which it computes on, sending output over another adapter to a target blockchain. (Adapters are initiated by code in the DON, represented by small blue boxes; arrows show the direction of data flow for this particular example.) The executable can additionally read and write to local DON storage to keep state and/or communicate with other executables. Flexible network ing, computation, and storage in DONs, all represented here, enable a host of novel applications. 
A major benefit of DONs is their ability to bootstrap new blockchain services. DONs are a vehicle by which existing oracle networks can quickly stand up service applications that would today require the creation of purpose-built networks. We give a number of examples of such applications in Section 4. 
In Section 3, we provide more details on DONs, describing their capabilities in terms of the interface they present to developers and users. 
1.2 Seven Key Design Goals 
Here we briefly review the seven key focuses enumerated above for the evolution of Chainlink, namely: 
8
Hybrid smart contracts: Central to our vision for Chainlink is the idea of securely combining on-chain and off-chain components in smart contracts. We refer to contracts realizing this idea as hybrid smart contracts or hybrid contracts.2 
Blockchains are and will continue to play two critical roles in decentralized-service ecosystems: They are both the loci where cryptocurrency ownership is represented and robust anchors for decentralized services. Smart contracts must therefore be repre sented or executed on chain, but their on-chain capabilities are severely limited. Purely on-chain contract code is slow, expensive, and insular, unable to benefit from real-world data and a variety of functionalities that are inherently unachievable on chain, includ ing various forms of confidential computation, generation of (pseudo)randomness secure against miner / validator manipulation, etc. 
For smart contracts to realize their full potential therefore requires smart contracts to be architected with two parts: an on-chain part (which we typically denote by SC) and an off-chain part, an executable running on a DON (which we typically denote by exec). The goal is to achieve a secure composition of on-chain functionality with the multiplicity of off-chain services that DONs aim to provide. Together, the two parts make up a hybrid contract. We present the idea conceptually in Fig. 2. Already today, Chainlink services3such as data feeds and VRFs are enabling otherwise unachievable smart contract applications, ranging from DeFi to fairly generated NFTs to decentral ized insurance, as first steps toward a more general framework. As Chainlink services expand and grow more performant according to our vision in this whitepaper, so too will the power of smart contract systems across all blockchains. 
Our other six key focuses in this whitepaper may be viewed as acting in the service of the first, overarching one of hybrid contracts. These focuses involve removing visible complexity from hybrid contracts, creating additional off-chain services that enable the construction of ever more capable hybrid contracts, and, in the case of trust minimiza tion, bolstering the security properties achieved by hybrid contracts. We leave the idea of hybrid contracts implicit throughout much of the paper, but any combination of MAINCHAIN logic with a DON may be viewed as a hybrid contract. 
Abstracting away complexity: DONs are designed to make use of decentralized systems easy for developers and users by abstracting away the often complex machinery behind DONs’ powerful and flexible array of services. Existing Chainlink services already have this feature. For example, data feeds in Chainlink today present on chain interfaces that do not require developers to concern themselves with protocol level details, such as the means by which OCR enforces consensus reporting among a 
2The idea of on-chain / off-chain contract composition has arisen previously in various constrained forms, e.g., layer-2 systems, TEE-based blockchains [80], etc. Our goal is to support and generalize these approaches and ensure that they can encompass off-chain data access and other key oracle services. 
3Chainlink services comprise a variety of decentralized services and functionality available through the network. They are offered by the numerous node operators composed into various oracle networks across the ecosystem. 
9

Figure 2: Conceptual figure depicting on-chain / off-chain contract composition. A hybrid smart contract 3 consists of two complementary components: an on-chain component SC 1 , resident on a blockchain, and an off-chain component exec 2 that executes on a DON. The DON serves as a bridge between the two components as well as connecting the hybrid contract with off-chain resources such as web services, other blockchains, decentralized storage, etc. 
decentralized set of nodes. DONs go a step further in the sense that they expand the range of services for which Chainlink can offer developers an abstraction layer with accompanying streamlined interfaces for high-level services. 
We present several application examples in Section 4 that highlight this approach. We envision enterprises, for instance, using DONs as a form of secure middleware to connect their legacy systems to blockchains. (See Section 4.2.) This use of DONs ab stracts away the complexity of general blockchain dynamics (fees, reorgs, etc.). It also abstracts away the features of specific blockchains, thereby enabling enterprises to con nect their existing systems to an ever-broadening array of blockchain systems without a need for specialized expertise in these systems or, more generally, in decentralized systems development. 
Ultimately, our ambition is to push the degree of abstraction achieved by Chainlink to the point of implementing what we refer to as a decentralized metalayer. Such a layer would abstract away the on-chain / off-chain distinction for all classes of developers and users of DApps, allowing seamless creation and use of decentralized services. 
10
To simplify the development process, developers could specify DApp functional ity in the metalayer as a virtual application in a unified machine model. They could then use a decentralized-metalayer compiler to instantiate the DApp automatically as a set of interoperating decentralized functionalities spanning blockchains, DONs, and external services. (One of these external services could be an enterprise system, mak ing the metalayer useful for applications involving legacy enterprise systems.) Such compilation is akin to how modern compilers and software-development kits (SDKs) support generalist programmers in using the full potential of heterogeneous hardware architectures consisting of a general-purpose CPU and specialized hardware like GPUs, machine-learning accelerators, or trusted enclaves. Fig. 3 presents this idea at a con ceptual level. 
Hybrid smart contracts are a first step along the way to this vision and to a con cept we call meta contracts. Meta contracts are applications coded on a decentralized metalayer and implicitly encompass on-chain logic (smart contracts), as well as off chain computation and connectivity among various blockchains and existing off-chain services. Given the need for language and compiler support, new security models, and conceptual and technical harmonization of disparate technologies, however, realization of a true decentralized metalayer is an ambitious goal to which we aspire over a long time horizon. It is nonetheless a helpful ideal model to keep in mind while reading this paper, not detailed here, but something we plan to focus on in our future work on Chainlink. 
Scaling: A goal of preeminent importance in our evolving designs is enabling the Chainlink network to meet the growing scaling needs of the blockchain ecosystem. With network congestion becoming a recurring problem in existing permissionless blockchains [86], new and more performant blockchain designs are coming into use, e.g., [103, 120, 203], as well as complementary layer-2 scaling technologies, e.g., [5, 12, 121, 141, 169, 186, 187]. Oracle services must achieve latencies and throughputs that meet the performance demands of these systems while minimizing on-chain fees (e.g., gas costs) for contract operators and ordinary users alike. With DONs, Chainlink functionality aims to go further and deliver performance high enough for purely web based systems. 
DONs derive much of their performance gain from their use of fast, committee based or permissionless consensus protocols, which they combine with the blockchains they support. We expect many DONs with different configurations to run in paral lel; different DApps and users can navigate tradeoffs in underlying consensus choices according to their application requirements. 
DONs may be viewed in effect as layer-2 technologies. We expect that among other services, DONs will support the Transaction Execution Framework (TEF), which facilitates efficient integration of DONs and thus oracles with other high-performance layer-2 systems—e.g., rollups, systems which bundle transactions off chain to achieve performance improvements. We introduce the TEF in Section 6. 
11

Figure 3: Conceptual figure showing ideal realization of a decentralized metalayer. For ease of development, a developer specifies a DApp, highlighted in pink, as a virtual application in a unified machine model. A decentralized-metalayer compiler automati cally generates corresponding interoperating functionalities: smart contracts (denoted by SC), logic (denoted by exec) on DONs, adapters connecting to target external ser vices, and so forth, as indicated in yellow highlight. 
Fig. 4 shows conceptually how DONs improve blockchain (smart contract) scaling by concentrating transaction and oracle-report processing off chain, rather than on chain. This shift in the main locus of computation reduces transaction latency and fees while boosting transaction throughput. 
Confidentiality: Blockchains provide unprecedented transparency for smart con tracts and the applications they realize. But there is a basic tension between trans parency and confidentiality. Today, for example, users’ decentralized exchange trans 
12

Figure 4: Conceptual figure showing how Decentralized Oracle Networks improve the scaling of blockchain-enabled smart contracts. Figure A shows a conventional oracle architecture. Transactions are sent directly to the blockchain, as are oracle reports. Thus the blockchain, highlighted in yellow, is the main locus for transaction process ing. Figure B shows use of a DON to support contracts on the blockchain. A DON executable processes transactions along with data from external systems and forwards results—e.g., bundled transactions or contract state changes resulting from the trans actions’ effects—to the blockchain. The DON, highlighted in yellow, is thus the main locus for transaction processing. 
actions are recorded on chain, making it easy to monitor exchange behavior, but also making users’ financial transactions publicly visible. Similarly, data relayed to smart contracts remains on chain. This makes such data conveniently auditable, but acts as a disincentive for data providers wishing to furnish smart contracts with sensitive or proprietary data. 
We believe that oracle networks will play a pivotal role in catalyzing next-generation systems that combine blockchains’ innate transparency with new confidentiality pro tections. In this paper, we show how they will do so using three main approaches: 
• Confidentiality-preserving adapters: Two technologies with planned deployment in Chainlink’s networks, DECO [234] and Town Crier [233], enable oracle nodes to retrieve data from off-chain systems in ways that protect user privacy and data confidentiality. They will play a key role in the design of adapters for DONs. (See Section 3.6.2 for details on these two technologies.) 
• Confidential computation: DONs can simply conceal their computation from re lying blockchains. Using secure multi-party computation and/or trusted execu tion environments, stronger confidentiality is also possible in which DON nodes compute over data into which they themselves do not have visibility. 
13
• Support for confidential layer-2 systems: The TEF is designed to support a va riety of layer-2 systems, many of which use zero-knowledge proofs to provide various forms of transaction confidentiality. 
We discuss these approaches in Section 3 (with additional details in Section 6, Ap pendix B.1, and Appendix B.2). 
Fig. 5 presents a conceptual view of how sensitive data might flow from exter nal sources to a smart contract by means of confidentiality-preserving adapters and confidential computation in a DON. 

Figure 5: Conceptual diagram of confidentiality-preserving operations in a DON on sensitive data (highlighted in yellow). Sensitive source data (black circles) in web servers is extracted to the DON using confidentiality-preserving adapters (blue, double arrowed lines). The DON receives derived data (hollow circles) from these adapters— the result of applying either a function or, e.g., secret-sharing, to the sensitive source data. An executable on the DON may apply confidential computation to derived data to construct a report (double circle), which it sends over an adapter to the blockchain. 
We believe that powerful tools for handling confidential data will open up a whole range of applications. Among these are private decentralized (and centralized) fi nance, decentralized identity, credit-based on-chain lending, and more efficient and user-friendly know-your-customer and accreditation protocols, as we discuss in Sec tion 4. 
Order-fairness for transactions: Today’s blockchain designs have a dirty little open secret: They are ephemerally centralized. Miners and validators can order trans 
14
actions however they choose. Transaction order can also be manipulated by users as a function of the network fees they pay (e.g., gas prices in Ethereum) and to some extent by taking advantage of fast network connections. Such manipulation can, for example, take the form of front-running, in which a strategic actor such as a miner observes a user’s transaction and inserts its own exploitative transaction into an earlier position in the same block—effectively stealing money from the user by leveraging ad vance knowledge of the user’s transaction. For example, a bot may place a buy order before a user’s. It can then take advantage of the asset price increase induced by the user’s trade. 
Front-running by some bots that harms ordinary users—analogous to high-frequency trading on Wall Street—is already prevalent and well documented [90], as are related attacks such as back-running [159] and automated transaction mimicking [195]. Pro posals to systematize order exploitation by miners have even surfaced recently [110]. 
Layer-2 technologies such as rollups don’t solve the problem, but merely re-centralize ordering, placing it in the hands of the entity that creates a rollup. One of our goals is to introduce into Chainlink a service called Fair Sequencing Services (FSS) [137]. FSS helps smart contract designers ensure fair ordering for their transactions and avoid front-running, back-running, and related attacks on user trans actions as well as other types of transactions, such as oracle report transmission. FSS enables a DON to implement ideas such as the rigorous, temporal notion of order fairness introduced in [144]. As an incidental benefit, FSS can also lower users’ network fees (e.g., gas costs). 
Briefly, in FSS, transactions pass through the DON, rather than propagating di rectly to a target smart contract. The DON orders the transactions and then forwards them to the contract. 

Figure 6: Example of how FSS is beneficial. Fig. A shows how a miner, exploiting its centralized power to order transactions, may swap a pair of transactions: transaction1 arrives before2 , but the miner instead sequences it after2 . In contrast, Fig.B shows how a DON decentralizes the ordering process among DON nodes. If a quorum of honest nodes receive 1 before 2 , the FSS causes 1 to appear before 2 on chain— preventing miner reordering by attaching contract-enforceable sequence numbers. 
Fig. 6 compares standard mining with FSS. It shows how in standard mining, 15
the process of transaction ordering is centralized with the miner and thus subject to manipulation, such as reordering a pair of transactions with respect to their arrival times. In contrast, in FSS, the process is decentralized among DON nodes. Assuming a quorum of honest nodes, FSS helps enforce policies such as temporal ordering of transactions, reducing opportunities for manipulation by miners and other entities. Additionally, since users need not compete for preferential ordering based on gas price, they can pay relatively low gas prices (while transactions from the DON can be batched for gas savings). 
Trust minimization: Our general aim in the design of DONs is to facilitate a highly trustworthy layer of support for smart contracts and other oracle-dependent systems by means of decentralization, cryptographic tools, and cryptoeconomic guarantees. A DON itself is decentralized, and users can choose from any available DON that supports the main chain on which they wish to operate or spawn additional DONs with committees of nodes they trust. 
For some applications, however, particularly smart contracts, Chainlink users may favor a trust model that treats the main chain supported by a DON as more trustworthy than the DON itself. For such users, we already have or plan to incorporate into the architecture of the Chainlink network a number of mechanisms that enable contracts on a main chain to strengthen the security assurances provided by DONs, while at the same time also enforcing protections against the possibility of corrupted data sources such as the web servers from which the DON obtains data. 
We describe these mechanisms in Section 7. They fall under five main headings: 
• Data-source authentication: Tools that enable data providers to digitally sign their data and thereby strengthen the chain of custody between the origin and relying contract. 
• DON minority reports: Flags issued by a minority subset of DON nodes that observes majority malfeasance in the DON. 
• Guard rails: Logic on a main chain that detects anomalous conditions and pauses or halts contract execution (or invokes other remediations). 
• Trust-minimized governance: Use of gradual-release updates to facilitate com munity inspection, as well as decentralized emergency interventions for rapid response to system failures. 
• Decentralized entity authentication: Use of public-key infrastructure (PKI) to identify entities in the Chainlink network. 
Fig. 7 presents a conceptual schematic of our trust-minimization goals. 
Incentive-based (cryptoeconomic) security: Decentralization of report genera tion across oracle nodes helps ensure security even when some nodes are corrupted. 
16

Figure 7: Conceptual depiction of Chainlink’s trust-minimization goal, which is to minimize users’ need for correct behavior of the DON and data sources such as web servers. Yellow highlights in the figure indicate trust-minimization loci: the DON and individual or minority sets of web servers. Pink highlights indicate system components that are highly trustworthy by assumption: contracts on the blockchain and a majority of web servers, i.e., web servers in the aggregate. 
Equally important, though, is ensuring that nodes have a financial incentive to be have correctly. Staking, i.e., requiring nodes to provide deposits of LINK and slashing (confiscating) these deposits in case of misbehavior, will play a key role in Chain link. It is an important incentive design already used in a number of blockchains, e.g., [81, 103, 120, 204]. 
Staking in Chainlink, however, looks very different from staking in standalone blockchains. Staking in blockchains aims to prevent attacks on consensus. It has a different goal in Chainlink: to ensure timely delivery of correct oracle reports. A well designed staking system for an oracle network should render attacks such as bribery unprofitable for an adversary, even when the target is a smart contract with high monetary value. 
In this paper, we present a general approach to staking in Chainlink with three key innovations: 
17
1. A powerful adversarial model that encompasses attacks overlooked in existing approaches. One example is what we call prospective bribery. This is a form of bribery that determines which nodes receive bribes on a conditional basis, e.g., offers guaranteed bribes in advance to nodes that a staking mechanism selects at random for particular roles (such as triggering report adjudication). 
2. Super-linear staking impact, meaning informally that to be successful, an ad versary must have a budget $B greater than the combined deposits of all oracle nodes. More precisely, we mean that as a function of n, $B(n)   $dn in a network of n oracle nodes each with a fixed deposit amount $d (more formally, $B(n) is asymptotically larger in n than $dn). Fig. 8 gives a conceptual view of this property. 
3. The Implicit-Incentive Framework (IIF), an incentive model we have devised to encompass empirically measurable incentives beyond explicit deposited staking funds, including nodes’ future fee opportunities. The IIF extends the notion of stake beyond explicit node deposits. 

Figure 8: Conceptual diagram depicting super-linear scaling in Chainlink staking. The bribe $B(n) required by an adversary grows faster in n than the combined deposits $dn of all oracle nodes. 
We show how the IIF and super-linear staking impact together induce what we call a virtuous cycle of economic security for oracle networks. When new users enter 
18
the system, increasing potential future earnings from running Chainlink nodes, the marginal cost of economic security drops for current and future users. In a regime of elastic demand, this diminished cost incentivizes additional users to make use of the network, continuously perpetuating adoption in an ongoing virtuous cycle. 
Note: While this whitepaper outlines important elements of our vision for the evolu tion of Chainlink, it is informal and includes few detailed technical specifics. We plan to release focused technical papers on additional features and approaches as they evolve. Furthermore, it is important to emphasize that many elements of the vision presented here (scaling improvements, confidentiality technologies, FSS, etc.) can and will be deployed in preliminary form even before advanced DONs become a basic feature of Chainlink. 
1.3 Organization of this Paper 
We present our security model and notation in Section 2 and outline the Decentralized Oracle Network API in Section 3. In Section 4, we present a number of examples of applications for which DONs provide an appealing deployment platform. Readers can learn most of the key concepts of the paper by reading up to this point. 
The remainder of the paper contains further details. We describe Fair Sequencing Services (FSS) in Section 5 and the Transaction-Execution Framework (TEF) in Sec tion 6. We describe our approach to trust minimization in Section 7. We consider some important DON deployment requirements, namely incremental rollout of features, dy namic ledger membership, and accountability in Section 8. Finally, in Section 9, we give an overview of our developing approach to incentive design. We conclude in Section 10. 
To help readers who have limited familiarity with the concepts in this paper, we provide a glossary in Appendix A. We present further detail on the DON interface and functionality in Appendix B and present some example adapters in Appendix C. In Appendix D, we describe a cryptographic primitive for trust-minimized data-source authentication called functional signatures and introduce a new variant called dis cretized functional signatures. We discuss some considerations bearing on committee selection for DONs in Appendix F. 
2 Security Model and Goals 
A Decentralized Oracle Network is a distinct distributed system that we expect will initially be implemented typically—although not necessarily—by a committee-based consensus protocol and run by a set of oracle nodes. A DON is designed primarily to augment the capabilities of a smart contract on a main chain with oracle reports and other services, but it can provide those same supporting services to other non blockchain systems, and thus need not be associated with a particular main chain. 
19
The model and properties we consider are therefore largely independent of the use of the particular applications of a DON. 
2.1 Current Architectural Model 
It is important to emphasize that Chainlink today is not a monolithic service, but rather a permissionless framework within which it is possible to launch distinct, independent networks of oracle nodes [77]. Networks have heterogeneous sets of node operators and designs. They may also differ in terms of the types of services they provide, which can include, e.g., data feeds, Proof of Reserves, verifiable randomness, and so forth. Other differences can include the degree of decentralization, size of the network in terms of locked value it supports, and various service-level parameters, such as data frequency and accuracy. 
Chainlink’s permissionless model encourages the growth of an ecosystem in which providers specialize in the services they are best able to furnish to the community. This model is likely to result in lower costs to users and higher service quality than a model that requires all nodes and networks to provide a full range of services, an approach that can easily devolve into system-wide adoption of the services representing the least common denominator of resources available to nodes. 
As Chainlink evolves toward DON-based designs in Chainlink 2.0, we continue to support the model of a permissionless, open framework, keeping in view the goal of providing users with a range of service choices that globally result in the best match with particular application requirements. 
2.2 Consensus Assumptions 
We use the term Decentralized Oracle Network to encompass the full functionality of the oracle system we describe: both the data structure that oracle nodes maintain and the core API layered on top of it. 
We use the term ledger (lower case), denoted by L, to mean the underlying data structure maintained by a DON and used to support the particular services it provides. We emphasize that our DON framework does not treat L as a freestanding system like a blockchain: Its purpose is to support blockchains and other systems. Blockchains are, of course, one way of realizing a trustworthy ledger, but there are others. We expect DONs in many cases to realize their underlying ledgers using Byzantine Fault Tolerant (BFT) systems, which considerably predate blockchains such as Bitcoin [174]. We use BFT-type notation and properties throughout the paper for convenience, although we emphasize that DONs can be realized using permissionless consensus protocols. 
Conceptually, a ledger L is a bulletin board on which data is linearly ordered. We view a ledger generally as having a few key properties commonly ascribed to blockchains [115]. A ledger is: 
• Append-only: Data, once added, cannot be removed or modified. 20
• Public: Anyone can read its contents, which are consistent across time in the view of all users.4 
• Available: The ledger can always be written to by authorized writers and read by anyone in a timely way. 
Alternative properties are possible in the ledger for a DON when realized by a committee. For instance, ledger write access might be restricted to certain users, as might read access for some applications, i.e., the ledger need not be public as defined above. Similarly, ledger rules might permit modification or redaction of data. We don’t explicitly consider such variants in this paper, however. 
The modular design of DONs can support any of a wide variety of modern BFT protocols, e.g., Hotstuff [231]. The exact choice will depend on trust assumptions and network characteristics among the oracle nodes. A DON could in principle alternatively use a highly performant permissionless blockchain for its ledger in its role supporting an equally scalable layer-2 or blockchain system. Similarly, hybridization is also possible: The DON could in principle be composed of nodes that are validators in an existing blockchain, e.g., in Proof-of-Stake systems in which committees are selected to execute transactions, e.g., [8, 81, 120, 146, 204]. This particular mode of operation requires that nodes operate in a dual-use manner, i.e., operate both as blockchain nodes and DON nodes. (See Section 8.2 for a discussion of techniques to ensure continuity in changing committees and Appendix F for some caveats on random committee selection.) 
In practice, in modern BFT algorithms, nodes digitally sign messages on the ledger. We assume for convenience that L has an associated public key pkL and that its contents are signed by the corresponding private key. This general notation applies even when data on L are signed using threshold signatures.5 Threshold signatures are convenient, as they enable a persistent identity for a DON even with changes of membership in the nodes running it. (See Appendix B.1.3.) We thus assume that skL is secret-shared in a (k, n)-threshold manner for some security parameter k, e.g., k = 2f + 1 and n = 3f + 1, where f is the number of potentially faulty nodes. (By choosing k in this way, we ensure that faulty nodes can neither learn skL nor mount a denial-of-service attack preventing its use.) 
A message on L takes the form M = (m, z), where m is a string and z a unique sequential index number. Where applicable, we write messages in the form m = hMessageType : payloadi. The message type MessageType is syntactic sugar that in dicates the function of a particular message. 
4In cases where a blockchain without finality realizes a ledger, inconsistency is typically abstracted away by disregarding insufficiently deep blocks or “pruning” [115]. 
5In practice, some code bases, e.g., LibraBFT [205], a variant of Hotstuff, have currently adopted multi-signatures, rather than threshold signatures, trading off reduced communication complexity for simpler engineering. With some added cost, oracle nodes can append threshold signatures to messages written to L even if the consensus protocol used for L doesn’t employ them. 
21
2.3 Notation 
We denote the set of n oracle nodes running the ledger by O = {Oi}ni=1. Such a set of nodes is often called a committee. For simplicity, we assume that the set of oracles implementing DON functionality, i.e., services on top of L, is identical with that maintaining L, but they can be distinct. We let pki denote the public key of player Oi, and skithe corresponding private key. 
Most BFT algorithms require at least n = 3f + 1 nodes, where f is the number of potentially faulty nodes; remaining nodes are honest, in the sense that they follow the protocol exactly as specified. We refer to the committee O as honest if it meets this requirement, i.e., has greater than a 2/3-fraction of honest nodes. Unless otherwise stated, we assume that O is honest (and a static model of corruption). We use pkO / skO interchangeably with pkL / skL, depending on the context. 
We let σ = Sigpk[m] denote a signature on message m with respect to pk, i.e., using corresponding private key sk. Let verify(pk, σ, m) → {false, true} denote a corre sponding signature verification algorithm. (We leave key generation implicit through out the paper.) 
We use the notation S to denote a data source and S to denote the full set of nS sources in a given context. We denote by MAINCHAIN a smart-contract enabled blockchain supported by a DON. We use the term relying contract to denote any smart contract on MAINCHAIN that communicates with a DON, and use the notation SC to denote such a contract. 
We generally assume that a DON supports a single main chain MAINCHAIN, al though it can support multiple such chains, as we show in examples in Section 4. A DON can and typically will support multiple relying contracts on MAINCHAIN. (As noted above, a DON can alternatively support non-blockchain services.) 
2.4 Note on Trust Models 
As noted above, DONs may be built atop committee-based consensus protocols, and we expect they will commonly use such protocols. There are many strong arguments that one of the two alternatives, committee-based or permissionless blockchains, provides stronger security than the other. 
It is important to recognize that the security of committee-based vs. permissionless decentralized systems is incommensurable. Compromising a PoW or a PoS blockchain via 51% attack requires that an adversary obtain majority resources ephemerally and potentially anonymously, for example by renting hash power in a PoW system. Such attacks in practice have already impacted several blockchains [200, 34]. In contrast, compromising a committee-based system means corrupting a threshold number (typi cally one-third) of its nodes, where the nodes may be publicly known, well resourced, and trustworthy entities. 
On the other hand, committee-based systems (as well as “hybrid” permissionless systems that support committees) can support more functionality than strictly per 
22
missionless systems. This includes the ability to maintain persistent secrets, such as signing and/or encryption keys—one possibility in our designs. 
We emphasize that DONs can in principle be built atop either a committee-based or permissionless consensus protocol and DON deployers may ultimately choose to adopt either approach. 
Bolstering trust models: A key feature of Chainlink today is the ability of users to select nodes based on decentralized records of their performance histories, as discussed in Section 3.6.4. The staking mechanism and Implicit-Incentive Framework we intro duce in Section 9 together constitute a broadly scoped and rigorous mechanism-design framework that will empower users with a greatly expanded ability to gauge the secu rity of DONs. This same framework will also make it possible for DONs themselves to enforce various security requirements on participating nodes and ensure operation within strong trust models. 
It is also possible using tools described in this paper for DONs to enforce spe cial trust-model requirements, such as compliance with regulatory requirements. For example, using techniques discussed in Section 4.3, nodes can present evidence of node-operator characteristics, e.g., territory of operation, that can be used to help enforce compliance with, e.g., the General Data Protection Regulation (GDPR) Ar ticle 3 (“Territorial Scope”) [105]. Such compliance can otherwise be challenging to meet in decentralized systems [45]. 
Additionally, in Section 7 we discuss plans to strengthen the robustness of DONs through trust-minimization mechanisms on the main chains they support. 
3 Decentralized Oracle Network Interface and Ca pabilities 
Here we briefly sketch the capabilities of DONs in terms of the simple but powerful interface they are designed to realize. 
Applications on a DON are composed of executables and adapters. An executable is a program whose core logic is a deterministic program, analogous to a smart contract. An executable also has a number of accompanying initiators, programs that call entry points in the executable’s logic when predetermined events occur—e.g., at certain times (like a cron job), when a price crosses a threshold, etc.—much like Keepers (see Sec tion 3.6.3). Adapters provide interfaces to off-chain resources and may be called by either the initiators or core logic in executables. As their behavior may depend on that of external resources, initiators and adapters may behave non-deterministically. 
We describe the DON developer interface and the functioning of executables and adapters in terms of the three resources typically used to characterize computing sys tems: networking, compute, and storage. We give a brief overview of each of these resources below and provide more details in Appendix B. 
23
3.1 Networking 
Adapters are interfaces through which executables running on a DON can send and receive data from off-DON systems. Adapters may be viewed as a generalization of the adapters used in Chainlink today [20]. Adapters may be bidirectional—i.e., they cannot just pull, but push data from a DON to a web server. They may also leverage distributed protocols as well as cryptographic functionality such as secure multi-party computation. 

Figure 9: Adapters connecting a DON, denoted DON1, with a range of different re sources, including another DON, denoted DON2, a blockchain (main chain) and its mempool, external storage, a web server, and IoT devices (via a web server). 
Examples of external resources for which adapters might be created are shown in Fig. 9. They include: 
• Blockchains: An adapter can define how to send transactions to a blockchain and how to read blocks, individual transactions, or other state from it. An adapter can also be defined for a blockchain’s mempool. (See Section 3.5.) 
• Web servers: Adapters can define APIs through which data may be retrieved from web servers, including legacy systems that are not specially adapted for interfacing with DONs. Such adapters can also include APIs to send data to such servers. The web servers to which a DON connects may serve as gateways to additional resources, such as Internet-of-Things (IoT) devices. 
24
• External storage: An adapter can define methods to read and write to storage services outside the DON, such as a decentralized file system [40, 188] or cloud storage. 
• Other DONs: Adapters can retrieve and transmit data between DONs. 
We expect that initial deployments of DONs will include a set of building block adapters for such commonly used external resources and will further allow DON-specific adapters to be published by DON nodes. As smart contract developers write adapters today, we expect that they will build even more powerful adapters using this advanced functionality. 
We expect that ultimately it will be possible for users to create new adapters in a permissionless manner. 
Some adapters must be constructed in a way that ensures the persistence and avail ability of external resources controlled by a DON. For example, cloud storage may require maintenance of a cloud services account. Additionally, a DON can perform decentralized management of private keys on behalf of users (as in, e.g., [160]) and/or executables. Consequently, the DON is capable of controlling resources, such as cryp tocurrency, that may be used, e.g., for sending transactions on a target blockchain. 
See Appendix B.1 for further details on DON adapters, as Appendix C for a few example adapters. 
3.2 Computation 
An executable is the basic unit of code on a DON. An executable is a pair exec = (logic, init). Here, logic is a deterministic program with a number of designated entry points (logic1, logic2, . . . , logic`) and init is a set of corresponding initiators (init1, init2, . . . , inite). To ensure the full auditability of the DON, an executable’s logic uses the underlying ledger L for all inputs and outputs. Thus, for instance, any adapter data serving as input to an executable must be stored first on L. 
Initiators: Initiators in Chainlink today cause event-dependent job executions on Chainlink nodes [21]. Initiators in DONs function in much the same way. A DON ini tiator, however, is specifically associated with an executable. An initiator may depend on an external event or state, on the current time, or on a predicate on DON state. With their dependency on events, initiators may of course behave non-deterministically (as of course may adapters). An initiator can execute within individual DON nodes and so need not rely on an adapter. (See Example 1 below.) 
Initiators are an important feature distinguishing executables from smart contracts. Because an executable can run in response to an initiator, it can effectively operate autonomously, as of course by extension can a hybrid contract incorporating the exe cutable. One form of initiators today are Chainlink Keepers, which provide transaction 
25
automation services, triggering smart contract execution—such as liquidation of un dercollateralized loans and execution of limit-order trades—based on oracle reports. Conveniently, initiators in DONs may also be viewed as a way of specifying the service agreements that apply to an executable, as they define the circumstances under which the DON must call it. 
The following example illustrates how initiators work within an executable: 
Example 1 (Deviation-triggered price feed). A smart contract SC may require fresh price-feed data (see Section 3.6.3) whenever there is a substantial change, e.g., 1%, in the exchange rate between a pair of assets, e.g., ETH-USD. Volatility-sensitive price feeds are supported in Chainlink today, but it is instructive to see how they can be realized on a DON by means of an executable execfeed. 
The executable execfeed maintains the most recent ETH-USD price r on L, in the form of a sequence of hNewPrice : j, ri entries, where j is an index incremented with each price update. 
An initiator init1 causes each node Oi to monitor the current ETH-USD price for deviations of at least 1% from the most recently stored price r with index j. Upon detection of such a deviation, Oi writes its current view ri of the new price to L using an entry of the form hPriceView : i, j + 1, rii. 
A second initiator init2 fires when at least k such PriceView-entries with new price values for index j + 1 created by distinct nodes have accumulated on L. Then, init2 invokes an entry point logic2to compute the median ρ of the first k fresh, valid price view values and writes a fresh value hNewPrice : j + 1, ρi to L . (Operationally, nodes may take turns as designated writers.) 
A third initiator init3 watches for NewPrice entries on L. Whenever a new report hNewPrice : j, ri appears there, it invokes an entry point logic3that pushes (j, r) to SC using an adapter. 
As we have noted, an executable is similar in its capabilities to a smart contract. Apart from its higher performance, though, it differs from a typical main chain contract in two essential ways: 
1. Confidentiality: An executable can perform confidential computation, i.e., a se cret program may process cleartext inputs, or a published program may process secret input data, or a combination of both. In a simple model, secret data can be accessed by DON nodes, which conceal intermediate results and disclose only processed and sanitized values to MAINCHAIN. It is also possible to conceal sen sitive data from DONs themselves: DONs are meant to support approaches such as multi-party computation, e.g., [42, 157], and trusted execution environments (TEEs) [84, 133, 152, 229] for this purpose.6 
6By extension, keeping executables themselves secret with respect to DON nodes is also possible, although this is only practical today for non-trivial executables using TEEs. 
26
2. Supporting role: An executable is meant to support smart contracts on a main chain, rather than replace them. An executable has several limitations that a smart contract does not: 
(a) Trust model: An executable operates within the trust model defined by the DON: Its correct execution relies on the honest behavior of O. (A main chain can, however, provide some guard rails against DON malfeasance, as discussed in Section 7.3.) 
(b) Asset access: A DON can control an account on a blockchain—and thus control assets on it through an adapter. But a DON cannot authoritatively represent assets created on a main chain, e.g., Ether or ERC20 tokens, since their native chain maintains the authoritative record of their ownership. 
(c) Lifecycle: DONs may be stood up intentionally with limited lifetimes, as defined by on-chain service level agreements between DONs and the owners of relying contracts. Blockchains, in contrast, are meant to function as permanent archival systems. 
See Appendix B.2 for further details on DON computation. 
3.3 Storage 
As a committee-based system, a DON can store moderate amounts of data persistently on L at much lower cost than a permissionless blockchain. Additionally, via adapters, DONs can reference external decentralized systems for data storage, e.g., Filecoin [85], and can thereby connect such systems to smart contracts. This option is particularly attractive for bulk data as a means of addressing the pervasive problem of “bloat” in blockchain systems. 
DONs can thus store data locally or externally for use in their specifically sup ported services. A DON can additionally make use of such data in a confidential way, computing on data that is: (1) secret-shared across DON nodes or encrypted under a key managed by DON nodes in ways suitable for secure multi-party computation or partial or fully homomorphic encryption; or (2) protected using a trusted execution environment. 
We expect that DONs will adopt a simple memory-management model common to smart-contract systems: An executable may only write to its own memory. Executables may, however, read from the memory of other executables. 
See Appendix B.3 for further details on DON storage. 
3.4 Transaction-Execution Framework (TEF) 
DONs are intended to support contracts on a main chain MAINCHAIN (or on multi ple main chains). The Transaction-Execution Framework (TEF), discussed in detail 
27

in Section 6, is a general-purpose approach to the efficient execution of a contract SC across MAINCHAIN and a DON. The TEF is intended to support FSS and layer-2 technologies—simultaneously, if desired. Indeed, it is likely to serve as the main vehicle for use of FSS (and for that reason, we do not further discuss FSS in this section). 
Briefly, in TEF an original target contract SC designed or developed for MAINCHAIN is refactored into a hybrid contract. This refactoring produces the two interoperating pieces of the hybrid contract: a MAINCHAIN contract SCa that we refer to for clarity in the context of TEFs as an anchor contract and an executable execs on a DON. The contract SCa custodies users’ assets, executes authoritative state transitions, and also provides guard rails (see Section 7.3) against failures in the DON. The executable execs sequences transactions and provides associated oracle data for them. It can bundle transactions for SCa in any of a number of ways—e.g., using validity-proof-based or optimistic rollups, confidential execution by the DON, etc. 
We expect to develop tools that make it easy for developers to partition a contract SC written in a high-level language into pieces of MAINCHAIN and DON logic, SCa and execs respectively, that compose securely and efficiently. 
Using TEF to integrate high-performance transaction schemes with high-performance oracles is integral to our oracle scaling approach. 
3.5 Mempool Services 
An important application-layer feature that we intend to deploy on DONs in support of FSS and the TEF are Mempool Services (MS). MS may be viewed as an adapter, but one with first-class support. 
MS provides support for legacy-compatible transaction processing. In this use, MS ingests from a main chain’s mempool those transactions intended for a target contract SC on MAINCHAIN. MS then passes these transactions to an executable on the DON, where they are processed in the desired way. MS data can be used by the DON to compose transactions that can then be passed directly to SC from the DON or to another contract that calls SC. For example, the DON can forward transactions harvested via MS, or it can use MS data to set gas prices for transactions it sends to MAINCHAIN. 
Because it monitors the mempool, MS can obtain transactions from users inter acting directly with SC. Thus users may continue to generate their transactions using legacy software, i.e., applications unaware of the existence of MS and MS-configured contracts. (In this case, SC must be changed to ignore the original transactions and accept only those processed by the MS, so as to avoid double-processing.) 
For use with a target contract SC, MS can be used with FSS and/or the TEF. 28

3.6 Stepping Stones: Existing Chainlink Capabilities 3.6.1 Off-Chain Reporting (OCR) 
Off-Chain Reporting (OCR) [60] is a mechanism in Chainlink for oracle report aggrega tion and transmission to a relying contract SC. Recently deployed for Chainlink price feed networks, it represents a first step along the path to full DONs. 
At its core, OCR is a BFT protocol designed to operate in a partially synchronous network. It ensures liveness and correctness in the presence of f < n/3 arbitrarily faulty nodes, guaranteeing the properties of Byzantine reliable broadcast, but it is not a complete BFT consensus protocol. Nodes do not maintain message logs that are consistent in the sense of representing a ledger that is identical in all of their views, and the leader of the protocol may equivocate without violating safety. 
OCR is currently designed for a particular message type: medianized aggregation of (at least 2f + 1) values reported by participating nodes. It provides a key assurance on the reports it outputs for SC, called attested reports: The median value in an attested report is equal to or lies between values reported by two honest nodes. This property is the key safety condition for OCR. The leader may have some influence on the median value in an attested report, but only subject to this correctness condition. OCR can be extended to message types that aggregate values in different ways. 
While the Chainlink network’s liveness and correctness goals today do not require OCR to be a full-blown consensus protocol, they do require OCR to provide some addi tional forms of functionality not present in conventional BFT protocols, most notably: 
1. All-or-nothing off-chain report broadcast: OCR ensures that an attested report is made quickly available to all honest nodes or none of them. This is a fairness property that helps ensure that honest nodes have an opportunity to participate in attested report transmission. 
2. Reliable transmission: OCR ensures, even in the presence of faulty or malicious nodes, that all OCR reports and messages are transmitted to SC within a certain, pre-defined interval of time. This is a liveness property. 
3. Contract-based trust minimization: SC filters out potentially erroneous OCR generated reports, e.g., if their reported values deviate significantly from other recently received ones. This is a form of extra-protocol correctness enforcement. 
All three of these properties will play a natural role in DONs. All-or-nothing off chain (DON) broadcast is an important building block for cryptoeconomic assurances around reliable transmission, which is in turn an essential adapter property. Trust minimization in SC is a type of guard rail, as discussed in Section 7.3. 
OCR also provides a basis for operational deployment and refinement of BFT pro tocols in Chainlink’s oracle networks and thus, as noted above, a path to the full functionality of DONs. 
29
3.6.2 DECO and Town Crier 
DECO [234] and Town Crier [233] are a pair of related technologies currently being developed in Chainlink networks. 
Most web servers today allow users to connect over a secure channel using a protocol called Transport Layer Security (TLS) [94]. (HTTPS indicates a variant of HTTP that is enabled with TLS, i.e., URLs prefixed with “https” denote use of TLS for security.) Most TLS-enabled servers have a notable limitation, though: They don’t digitally sign data. Consequently, a user or Prover cannot present the data she receives from a server to a third party or Verifier, such as an oracle or smart contract, in a way that ensures the data’s authenticity. 
Even if a server were to digitally sign data, there remains a problem of confiden tiality. A Prover may wish to redact or modify sensitive data before presenting it to a Verifier. Digital signatures are designed specifically to invalidate modified data, how ever. They thus prevent a Prover from making confidentiality-preserving alterations to data. (See Section 7.1 for more discussion.) 
DECO and Town Crier are designed to allow a Prover to obtain data from a web server and present it to a Verifier in a way that ensures integrity and confidentiality. The two systems preserve integrity in the sense that they ensure that data presented by the Prover to the Verifier originates authentically from the target server. They support confidentiality in the sense of allowing the Prover to redact or modify data (while still preserving integrity). 
A key feature of both systems is that they do not require any modifications to a target web server. They can operate with any existing TLS-enabled server. In fact, they are transparent to the server: From the viewpoint of the server, the Prover is establishing an ordinary connection. 
The two systems have similar goals, but differ in their trust models and implemen tations as we now briefly explain. 
DECO makes fundamental use of cryptographic protocols to achieve its integrity and confidentiality properties. While establishing a session with a target server us ing DECO, the Prover engages at the same time in an interactive protocol with the Verifier. This protocol enables the Prover to prove to the Verifier that it has received a given piece of data D from the server during its current session. The Prover can alternatively present the Verifier with a zero-knowledge proof of some property of D and thus not reveal D directly. 
In a typical use of DECO, a user or a single node can export data D from a private session with a web server to all of the nodes in a DON. As a result, the full DON can attest to the authenticity of D (or a fact derived from D via a zero-knowledge proof). In addition to the example applications given later in the paper, this capability can be used to amplify high-integrity access to a data source by a DON. Even if only one node has direct access to a data source—due, for instance, to an exclusive arrangement with a data provider—it remains possible for the entire DON to attest to the correctness of 
30
reports emitted by that node. 
Town Crier relies on the use of a trusted execution environment (TEE) such as Intel SGX. Briefly, a TEE functions as a kind of black box that executes applications in a tamperproof and confidential way. In principle, even the owner of the host on which the TEE is running can neither (undetectably) alter a TEE-protected application nor view the application’s state, which may include secret data. 
Town Crier can achieve all of the functionality of DECO and more. DECO con strains the Prover to interaction with a single Verifier. In contrast, Town Crier enables a Prover to generate a publicly verifiable proof on data D fetched from a target server, i.e., a proof that anyone, even a smart contract, can verify directly. Town Crier can also securely ingest and make use of secrets (e.g., user credentials). 
The main limitation of Town Crier is its reliance on TEEs. Production TEEs have recently been shown to have a number of serious vulnerabilities, although the technol ogy is in its infancy and will undoubtedly mature. See Appendices B.2.1 and B.2.2 for further discussion of TEEs. 
For a few example applications of DECO and Town Crier, see Sections 4.3, 4.5 and 9.4.3 and Appendix C.1. 
3.6.3 Existing On-Chain Chainlink Services 
Chainlink oracle networks provide a number of main services across a multiplicity of blockchains and other decentralized systems today. Further evolution as described in this whitepaper will endow these existing services with additional capabilities and reach. Three examples are: 
Data feeds: Today, the majority of Chainlink users relying on smart contracts make use of data feeds. These are reports on the current value of key pieces of data according to authoritative off-chain sources. For example, price feeds are feeds reporting the prices of assets—cryptocurrencies, commodities, forex, indexes, equities, etc.—according to exchanges or data-aggregation services. Such feeds today already help secure billions of dollars in on-chain value through their use in DeFi systems such as Aave [147] and Synthetix [208]. Other examples of Chainlink data feeds include weather data for parametric crop insurance [75] and election data [93], among a number of others. 
The deployment of DONs and other technologies described in this paper will en hance provision of data feeds in Chainlink networks in many ways, including: 
• Scaling: OCR and subsequently DONs aim to enable Chainlink services to scale dramatically across the many blockchains they support. For example, we expect that DONs will help increase the number of data feeds provided by nodes using Chainlink from 100s to 1000s and beyond. Such scaling will help the Chainlink ecosystem achieve its goal of furnishing data relevant to smart contracts compre hensively and both meeting and anticipating existing and future needs. 
31
• Enhanced security: By storing intermediate reports, DONs will retain records of node behaviors for high-fidelity monitoring and measurement of their perfor mance and accuracy, enabling strong empirical grounding of reputation systems for Chainlink nodes. FSS and the TEF will enable price feeds to be incorporated with transaction data in flexible ways that prevent attacks such as front-running. (Explicit) staking will bolster existing cryptoeconomic protection of the security of data feeds. 
• Feed agility: As blockchain-agnostic systems (indeed, more broadly, consumer agnostic systems), DONs can facilitate the provision of data feeds to a multiplicity of relying systems. A single DON can push a given feed simultaneously to a set of different blockchains, eliminating the need for per-chain oracle networks and enabling rapid deployment of existing feeds on new blockchains and of additional feeds across currently serviced blockchains. 
• Confidentiality: The ability to perform generalized computation in a DON en ables computations on sensitive data to take place off chain, avoiding on-chain exposure. Additionally, using DECO or Town Crier, it is possible to achieve even stronger confidentiality, allowing report generation based on data that isn’t exposed even to DON nodes. See Section 4.3 and Section 4.5 for examples. 
Verifiable Random Functions (VRFs): Several types of DApps require a verifi ably correct source of randomness to enable verification of their own fair operation. Non-Fungible Tokens (NFTs) are an example. The rarity of NFT features in Aaveg otchi [23] and Axie Infinity [35] is determined by Chainlink VRF, as is the distribution of NFTs by means of ticket-based drawings in Ether Cards [102]; the wide variety of gaming DApps whose outcomes are randomized; and unconventional financial instru ments, e.g., no-loss savings games such as PoolTogether [89], which allocate funds to random winners. Other blockchain and non-blockchain applications also require secure sources of randomness, including selection of decentralized-system committees and the execution of lotteries. 
While block hashes can serve as a source of unpredictable randomness, they are vul nerable to manipulation by adversarial miners (and to some extent by users submitting transactions). Chainlink VRF [78] offers a considerably more secure alternative. An oracle has an associated private / public key pair (sk, pk) whose private key is main tained off chain and whose public key pk is published. To output a random value, it applies sk to an unpredictable seed x furnished by a relying contract (e.g., a block hash and DApp-specific parameters) using a function F, yielding y = Fsk(x) along with a proof of correctness. (See [180] for the VRF available on Chainlink.) What makes a VRF verifiable is the fact that with knowledge of pk, it is possible to check the correct ness of the proof and therefore of y. The value y is consequently unpredictable to an adversary that cannot predict x or learn sk and infeasible for the service to manipulate. 
32
Chainlink VRF may be viewed as just one of a family of applications that in volve custodianship of private keys off chain. More generally, DONs can offer secure, decentralized storage of individual keys for applications and/or users, and combine this capability with generalized computation. The result is a host of applications, of which we give some examples in this paper, including key management for Proof of Reserves (see Section 4.1) and for users’ decentralized credentials (and other digital assets) (see Section 4.3). 
Keepers: Chainlink Keepers [87] enable developers to write code for decentralized execution of off-chain jobs, generally to trigger execution of relying smart contracts. Before the advent of Keepers, it was common for developers to operate such off-chain logic themselves, creating centralized points of failure (as well as considerable du plicated development effort). Keepers instead provide an easy-to-use framework for decentralized outsourcing of these operations, enabling shorter development cycles and strong assurance of liveness and other security properties. Keepers can support any of a wide variety of triggering goals, including price-dependent liquidation of loans or execution of financial transactions, time-dependent initiation of airdrops or payments in systems with yield harvesting, and so forth. 
In the DON framework, initiators may be viewed as a generalization of Keep ers in several senses. Initiators may make use of adapters, and thus can leverage a modularized library of interfaces to on-chain and off-chain systems, permitting rapid development of secure, sophisticated functionality. Initiators initiate computation in executables, which themselves offer the full versatility of DONs, permitting the wide range of decentralized services we present in this paper for on-chain and off-chain ap plications. 
3.6.4 Node Reputation / Performance History 
The existing Chainlink ecosystem natively documents the performance histories of contributing nodes on chain. This feature has given rise to a collection of reputation oriented resources that ingest, filter, and visualize performance data on individual node operators and data feeds. Users can reference these resources to make informed decisions in their selection of nodes and to monitor the operation of existing networks. Similar capabilities will help users choose DONs. 
For example, permissionless marketplaces today such as market.link allow node operators to list their oracle services and attest to their off-chain identities through services such as Keybase [4], which bind the profile of a node in Chainlink to its owner’s existing domain names and social media accounts. Additionally, performance analytics tools, such as those available at market.link and reputation.link, allow users to view statistics on the historical performance of individual nodes, including their average response latency, the deviation of values in their reports from consensus values relayed on chain, revenue generated, jobs fulfilled, and more. These analytics tools also allow users to track the adoption of various oracle networks by other users, a form of 
33
implicit endorsement of the nodes securing such networks. The result is a flat “web of trust” in which, by using particular nodes, high-value decentralized applications create a signal of their trust in those nodes that other users can observe and factor into their own node-selection decisions. 
With DONs (and initially with OCR) comes a shift in transaction processing and contract activity more generally off chain. A decentralized model for recording node performance remains possible within the DON itself. Indeed, the high performance and data capacity of DONs make it possible to construct records in a fine-grained way and also to perform decentralized computation on these records, yielding trust worthy summaries that can be consumed by reputation services and checkpointed on MAINCHAIN. 
While it is possible for a DON in principle to misrepresent the behavior of con stituent nodes if a large fraction of nodes is corrupted, we note that the collective performance of a DON itself in delivering on-chain data is visible on MAINCHAIN and thus cannot be misrepresented. Additionally, we plan to explore mechanisms that incentivize accurate internal reporting of node behaviors in a DON. For example, by re porting the subset of high-performing nodes that most quickly return data contributing to a report relayed on chain, a DON creates an incentive for nodes to contest incorrect reports: Incorrectly including nodes in this subset means incorrectly excluding nodes that should have been included and therefore invalidly penalizing them. Repeated re porting failures by a DON would also create an incentive for honest nodes to leave the DON. 
Decentralized compilation of accurate performance histories and the consequent ability of users to identify high-performing nodes and for node operators to build reputations are important distinguishing features of the Chainlink ecosystem. We show in Section 9 how we can reason about them as a key piece of a rigorous and expansive view of the economic security provided by DONs. 
4 Decentralized Services Enabled by Decentralized Oracle Networks 
To illustrate the versatility of DONs and how they enable a host of new services, we present five examples of DON-based applications in this section and describe the hybrid contracts that realize them: (1) Proof of Reserves, a form of cross-chain service; (2) Interfacing with enterprise / legacy systems, that is, creating a middleware-based abstraction layer that facilitates development of blockchain applications with minimal blockchain-specific code or expertise; (3) Decentralized identity, tools enabling users to obtain and manage their own identity documents and credentials; (4) Priority channels, a service that ensures timely inclusion of critical-infrastructure transactions (e.g., oracle reports) on a blockchain; and (5) Confidentiality-preserving DeFi, that is, financial smart contracts that conceal the sensitive data of participating parties. Here, we 
34
use SC to denote the MAINCHAIN part of a hybrid contract and describe the DON component separately or in terms of an executable exec. 
4.1 Proof of Reserves 
For many applications, it is useful to relay state between or among blockchains. A popular application of such services is cryptocurrency wrapping. Wrapped coins such as WBTC [15] are becoming a popular asset in Decentralized Finance (DeFi). They involve depositing the “wrapped” backing asset on its source blockchain MAINCHAIN(1) and creating a corresponding token on a different, target blockchain MAINCHAIN(2). For example, WBTC is an ERC20 token on the Ethereum blockchain that corresponds to BTC on the Bitcoin blockchain. 
Because contracts on MAINCHAIN(2) do not have direct visibility into MAINCHAIN(1), they must rely explicitly or implicitly on an oracle to report on deposits of the wrapped asset in a smart contract, producing what is sometimes called a Proof of Reserves. In WBTC [15], for example, custodian BitGo holds BTC and issues WBTC, with the Chainlink network providing Proofs of Reserve [76]. 
A DON can itself provide a Proof of Reserves. With a DON, however, it is possible to go further. A DON can manage secrets and, through use of appropriate adapters, can transact on any desired blockchain. Consequently, it is possible for the DON to act as one among a number of custodians—or even as a sole, decentralized custodian—for a wrapped asset. DONs can thereby serve as a platform to enhance the security of existing services that use Proofs of Reserves. 
For example, suppose that MAINCHAIN(1) is Bitcoin and MAINCHAIN(2) is Ethereum. On MAINCHAIN(2), a contract SC issues tokens representing wrapped BTC. The DON controls a BTC address addr(1) 

addr(1) 
Uto addr(1) 
DON. To wrap BTC, then, a user U sends X BTC from 
addr(1) 
DON along with a MAINCHAIN(2)-address addr(2) 
U. The DON monitors 

DON via an adapter to MAINCHAIN(1). On observing U’s deposit, with suffi ciently high-probability confirmation, it sends a message to SC via an adapter to MAINCHAIN(2). This message instructs SC to mint X tokens for addr(2) 
U. 
For U to release X tokens, the reverse happens. On MAINCHAIN(1), however, addr(1) 
DON sends X BTC to addr(1) 
U(or to another address, if thus requested by the user). 
These protocols can be adapted, of course, to work with exchanges, rather than directly with users. 
4.2 Interfacing with Enterprise / Legacy Systems 
DONs can serve as bridges between and among blockchains, as in the example of Proof of Reserves, but another objective is for them to act as bidirectional bridges between blockchains and legacy systems [176] or blockchain-like systems such as central bank digital currencies [30]. 
Enterprises face a number of challenges in connecting their existing systems and processes to decentralized systems, including: 
35
• Blockchain agility: Blockchain systems change rapidly. An enterprise may con front the rapid new appearance or rise in popularity of blockchains on which counterparties wish to conduct transactions, but for which the enterprise has no support in its existing infrastructure. In general, blockchains’ dynamism makes it difficult for individual enterprises to remain abreast of the full ecosystem. 
• Blockchain-specific development resources: For many organizations, hiring or in cubating cutting-edge blockchain expertise is difficult, particularly in view of the challenge of agility. 
• Private-key management: Managing private keys for blockchains or cryptocurren cies requires operational expertise distinct from that of traditional cybersecurity practices and unavailable to many enterprises. 
• Confidentiality: Enterprises are leery of exposing their sensitive and proprietary data on chain. 
To address the first three of these difficulties, developers can simply use a DON as a secure middleware layer to enable enterprise systems to read from or write to blockchains. The DON can abstract away detailed technical considerations such as gas dynamics, chain reorganization, and so forth, for both developers and users. By presenting a streamlined blockchain interface to enterprise systems, a DON can thus considerably simplify the development of blockchain-aware enterprise applications, re moving the burden from enterprises of acquiring or incubating blockchain-specific de velopment resources. 
Such use of DONs is especially attractive in that it enables enterprise developers to create smart-contract applications that are largely blockchain agnostic. As a result, the larger the set of blockchains for which a DON is instrumented to act as middleware, the larger the set of blockchains to which enterprise users can gain easy access. Developers can port applications from existing blockchains to new ones with minimal modification to their internally developed applications. 
To address the additional problem of confidentiality, developers can appeal to the tools we introduce in this paper and expect to deploy in support of DON applications. These include DECO and Town Crier Section 3.6.2 as well as confidentiality-preserving API modifications discussed in Section 7.1.2 and a number of application-specific ap proaches covered in the remainder of this section. These DON systems can provide high-integrity, on-chain attestations about enterprise system state without revealing sensitive enterprise source data on chain. 
4.3 Decentralized Identity 
Decentralized identity is a general term for the notion that users should be able to obtain and manage their own credentials, rather than relying on third parties to do so. Decentralized credentials are attestations to attributes or assertions of the holder, 
36
which are often called claims. Credentials are digitally signed by entities, often called issuers, that can authoritatively associate claims with users. In most proposed schemes, claims are associated with a Decentralized Identifier (DID), a universal identifier for a given user. Credentials are bound to a public key whose private key the user holds. The user can thus prove possession of a claim using her private key. 
Visionary as decentralized identity is, existing and proposed schemes, e.g., [14, 92, 129, 216], have three severe limitations: 
• Lack of legacy compatibility: Existing decentralized identity systems rely on a community of authorities, called issuers, to produce DID credentials. Because existing web services do not generally digitally sign data, issuers must be launched as special-purpose systems. Because there is no incentive to do this without a decentralized-identity ecosystem, a chicken-and-the-egg problem results. In other words, it’s unclear how to bootstrap an issuer ecosystem. 
• Unworkable key management: Decentralized identity systems require users to manage private keys, something that experience with cryptocurrency has shown to be an unworkable onus. It is estimated that some 4,000,000 Bitcoin have been lost forever because of key management failures [194], and many users store their crypto assets with exchanges [193], thereby undermining decentralization. 
• Lack of privacy-preserving Sybil resistance: A basic security requirement of ap plications such as voting, fair allocation of tokens during token sales, etc. is that users be unable to assert multiple identities. Existing decentralized identity pro posals require users to reveal their real-world identities in order to achieve such Sybil resistance, thereby undermining important privacy assurances. 
It is possible to address these problems using a combination of a committee of nodes performing distributed computation within a DON and the use of tools such as DECO or Town Crier, as shown in a system called CanDID [160]. 
DECO or Town Crier can by design turn existing web services without modification into confidentiality-preserving credential issuers. They enable a DON to export relevant data for this purpose into a credential while concealing sensitive data that should not appear in the credential. 
In addition, to facilitate key recovery for users, thus addressing the key-management problem, a DON can allow users to store private keys in secret-shared form. Users can recover their keys by proving to the nodes in the DON—similarly, using Town Crier or DECO—an ability to log into accounts with a set of predetermined web providers (e.g., Twitter, Google, Facebook). The benefit of using Town Crier or DECO, as opposed to OAUTH, is user privacy. Those two tools enable a user to avoid revealing to the DON a web provider identifier—from which real-world identities can often be derived. 
Finally, to provide Sybil resistance, as shown in [160], it is possible for a DON to perform a privacy-preserving transformation of unique real-world identifiers for users (e.g., Social Security Numbers (SSNs)) into on-chain identifiers upon user registration. 
37
The system can thereby detect duplicate registrations without sensitive data such as SSNs being revealed to individual DON nodes.7 
A DON can provide any of these services on behalf of external decentralized identity systems on permissionless or permissioned blockchains, e.g., instances of Hyperledger Indy [129]. 
Example application: KYC: Decentralized identity holds promise as a means to streamline requirements for financial applications on blockchains while improving user privacy. Two challenges it can help address are accreditation and compliance obliga tions under anti-money-laundering / know-your-customer (AML / KYC) regulations. 
AML regulations in many countries require financial institutions (and other busi nesses) to establish and verify the identities of individuals and businesses with which they perform transactions. KYC forms one component of a financial institution’s broader AML policy, which also typically involves monitoring user behaviors and watch ing fund flows, among other things. 
KYC typically involves user presentation of identity credentials in some form (e.g., entry into an online web form, holding up an identity document in front of a user’s face in a video session, etc.). Secure creation of and presentation of decentralized credentials could in principle be a beneficial alternative in several respects, namely by: (1) Making the KYC process more efficient for users and financial institutions, because once a credential is obtained, it could be presented seamlessly to any financial institution; (2) Reducing fraud by reducing opportunities for identity theft through compromise of personally identifiable information (PII) and spoofing during video verification; and (3) Reducing the risk of PII compromise in financial institutions, as users retain control of their own data. 
Given the multi-billion-dollar penalties paid by financial institutions for AML com pliance failures, and the many financial institutions spending millions of dollars annu ally on KYC, improvements could yield considerable savings for financial institutions and, by extension, for consumers [196]. While the traditional financial sector is slow to adopt new compliance tools, DeFi systems are increasingly embracing it [43]. 
Example application: Under-collateralized loans: Most DeFi applications that support lending today originate only fully collateralized loans. These are loans made to borrowers who deposit cryptocurrency assets of value exceeding that of the loans. Interest has arisen recently in what the DeFi community generally refers to as under collateralized loans. These, by contrast, are loans for which the corresponding collateral has value that is less than that of the principal of the loan. Under-collateralized loans resemble loans often made by traditional financial institutions. Rather than relying on deposited collateral as a guarantee of loan repayment, they instead base lending decisions on the credit histories of borrowers. 
7This transformation relies on a distributed pseudorandom function (PRF). 38
Under-collateralized loans constitute a nascent but growing part of the DeFi lend ing market. They rely upon mechanisms like those employed by traditional financial institutions, such as legal contracts [91]. An essential requirement for their growth will be the ability to furnish data on user creditworthiness—a key factor in conven tional lending decisions—to DeFi systems in a way that provides strong integrity, i.e., assurance of correct data. 
A DON-enabled decentralized identity system would enable would-be borrowers to generate high-assurance credentials attesting to their creditworthiness while preserving the confidentiality of sensitive information. Specifically, borrowers can generate these credentials based on records from authoritative online sources while exposing only the data attested to by the DON, without exposing other, potentially sensitive data. For example, a borrower can generate a credential indicating that her credit score with a set of credit bureaus exceeds a particular threshold (e.g., 750), without revealing her precise score or any other data in her records. Additionally, if desired, such credentials can be generated anonymously, i.e., the user’s name can be treated as sensitive data and itself not exposed to oracle nodes or in her decentralized credential. The credential itself can be used on chain or off chain, depending on the application. 
In summary, a borrower can provide essential information to lenders on their credit histories with strong integrity and without risk of exposure of unnecessary, sensitive data. 
A borrower can also provide a variety of other confidentiality-preserving credentials helpful in making lending decisions. For example, credentials can attest to a borrower’s possession of (off-chain) assets, as we show in our next example. 
Example application: Accreditation: Many jurisdictions limit the class of in vestor to which unregistered securities may be sold. For example, in the U.S., SEC Regulation D stipulates that to be accredited for such investment opportunities, an individual must possess a net worth of $1 million, meet certain minimum income re quirements, or have certain professional qualifications [209, 210]. Current accreditation processes are cumbersome and inefficient, often requiring a letter of attestation from an accountant, or similar evidence. 
A decentralized identity system would enable users to generate credentials from existing online financial services accounts that prove compliance with accreditation regulations, facilitating a more efficient and privacy-preserving KYC process. The privacy-preserving properties of DECO and Town Crier, moreover, would allow these credentials to be generated with a strong assurance of integrity without directly reveal ing details of a user’s financial status. For example, a user could generate a credential proving that she has a net worth of at least $1 million without revealing any additional information about her financial status. 
4.4 Priority Channels 
Priority channels are a useful new service that is easy to build using a DON. Their 39
goal is to deliver select, high-priority transactions in a timely way on MAINCHAIN during periods of network congestion. Priority channels may be viewed as a form of futures contract on block space and thus as a cryptocommodity, a term coined as part of Project Chicago [61, 136]. 
Priority channels are intended specifically for miners to enable infrastructure ser vices, such as oracles, governance functions for contracts, etc.—not for ordinary user level activities such as financial transactions. In fact, as designed here, a priority channel implemented by less than 100% of the mining power in the network can only provide loose bounds on delivery times, preventing its use for highly speed-dependent goals such as front-running. 

Figure 10: A priority channel is a guarantee by a miner M—or, more generally, a set of miners M—to a user U that her transaction τ will be mined within D blocks of inclusion in the mempool. A contract SC can use DON monitoring to enforce the service terms of the channel. 
A priority channel takes the form of an agreement between a miner or set of miners (or mining pools) M that provides the channel and a user U that pays a fee for access. M agrees that when U submits a transaction τ to the mempool (with any gas price, 
40
but a pre-agreed-upon gas limit), M will place it on chain within the next D blocks.8 The idea is depicted schematically in Fig. 10. 
Priority-channel contract description: A priority channel may be realized as a hybrid smart contract roughly as follows. We let SC denote the logic on MAINCHAIN and that on the DON by exec. 
SC accepts a deposit / stake $d from M and an advance payment $p from U. A DON executable exec monitors the mempool, triggering on placement of a transaction by U. It sends a success message to SC if U submits a transaction that M mines in a timely way and a failure message in case of a service failure. 
SC sends payment $p to M given a success message and sends all remaining funds, including $d, to U if it receives a failure message. Upon successful termination, it releases deposit $d to M. 
The miner M can of course provide priority channels simultaneously to multiple users and can open a priority channel with U for a pre-agreed-upon number of messages. 
4.5 Confidentiality-Preserving DeFi / Mixicles 
Today, DeFi applications [1] provide little to no confidentiality for users: All transac tions are visible on chain. Various zero-knowledge-based approaches, e.g., [149, 217], can provide transaction privacy, and the TEF is general enough to support them. But these approaches are not comprehensive, and do not, for example, typically conceal the asset on which a transaction is based. 
The broad set of computational tools we ultimately intend to support in DONs will enable privacy in a number of different ways that can plug such gaps, helping comple ment the privacy assurances of other systems. For example, Mixicles, a confidentiality preserving DeFi instrument proposed by Chainlink Labs researchers [135], can conceal the asset type backing a financial instrument, and fit very naturally into the DON framework. 
Mixicles are most easily explained in terms of their use to realize a simple binary option. A binary option is a financial instrument in which two users, which we’ll refer to here for consistency with [135] as players, bet on an event with two possible outcomes, e.g., whether or not an asset exceeds a target price at a predesignated time. The following example illustrates the idea. 
Example 2. Alice and Bob are parties to a binary option based on the value of an asset called Carol’s Bubble Token (CBT). Alice bets that CBT will have a market price of at least 250 USD at time T = noon on 21 June 2025; Bob bets the reverse. Each player deposits 100 ETH by a prespecified deadline. The player with the winning position receives 200 ETH (i.e., gains 100 ETH). 
8D must of course be large enough to ensure that M can comply with high probability. For instance, if M controls 20% of the mining power in the network, it might choose D = 100, ensuring a failure probability of ≈ 2 × 10−10, i.e., less than one in a billion. 
41
Given an existing Chainlink oracle network O, it is easy to implement a smart contract SC that realizes the agreement in Example 2. The two players each deposit 100 ETH in SC. Sometime after T, a query q is sent to O requesting the price r of CBT at time T. O sends a report r of this price to SC. SC then sends money to Alice if r ≥ 250 and Bob if not. This approach, however, reveals r on chain—making it easy for an observer to deduce the asset underlying the binary option. 
In the terminology of Mixicles, it is helpful to think conceptually of the outcome of SC in terms of a Switch that transmits a binary value computed as a predicate switch(r). In our example, switch(r) = 0 if r ≥ 250; given this outcome, Alice wins. Otherwise switch(r) = 1 and Bob wins. 
A DON can realize a basic Mixicle as a hybrid contract by running an executable exec that computes switch(r) and reports it on chain to SC. We show this construction in Fig. 11. 

Figure 11: Diagram of basic Mixicle in Example 2. To provide on-chain secrecy for report r, and thus the asset underlying the binary option, the oracle sends to the contract SC via Switch only the binary value switch(r). 
We specify an adapter ConfSwitch in Appendix C.3 that makes it easy to achieve this goal in a DON. The basic idea behind ConfSwitch is quite simple. Instead of reporting the value r, ConfSwitch reports only the binary switch value switch(r). SC can be designed to make a correct payment based on switch(r) alone, and switch(r) by itself reveals no information about the underlying asset—CBT in our example. Additionally, by placing a ciphertext on (q, r) on the ledger encrypted under pkaud, the public key of an auditor, the adapter ConfSwitch creates a confidentiality-preserving audit trail. 
The basic Mixicle we’ve chosen for simplicity to describe here conceals only the asset and bet behind the binary option in our example. A full-blown Mixicle [135] can provide two forms of confidentiality. It conceals from observers: (1) What event the players bet on (i.e., q and r) but also (2) Which player won the bet. 
Since Mixicles are executed on MAINCHAIN, either one player would need to relay switch(r) from the DON to MAINCHAIN, or an executable exec could be created that 
42
is triggered on output by ConfSwitch and calls another adapter to send switch(r) to MAINCHAIN. 
A third, subtle type of confidentiality is also worth considering. In a basic imple mentation of ConfSwitch, O is running the adapter on the DON and thus learns the asset—CBT in our example—and thus the nature of the binary option. As discussed in Appendix C.3, however, it is additionally possible to use DECO or Town Crier to conceal even this information from O. In this case, the O learns no more information than a public observer of SC. 
For further details on Mixicles, we refer readers to [135]. 
5 Fair Sequencing Services 
One important service that we expect DONs will offer that leverages their network ing, computation, and storage capabilities is called Fair Sequencing Services (FSS). Although FSS may be viewed simply as an application realized within the DON frame work, we highlight it as a service that we believe will be in high demand across blockchains, and which we expect the Chainlink network to support actively. 
When executed on public blockchain networks, many of today’s DeFi applications reveal information that can be exploited by users to their own benefit, analogous to the kind of insider leaks and manipulation opportunities that are pervasive in existing markets [64, 155]. FSS instead paves the way toward a fair DeFi ecosystem. FSS helps developers to build DeFi contracts that are protected from market manipulation resulting from information leakage. Given the problems we highlight below, FSS is especially attractive for layer-2 services and fits within the framework for such services that we discuss in Section 6. 
The challenge: In existing permissionless systems, transactions are ordered entirely at the discretion of miners. In permissioned networks, the validator nodes may exert the same power. This is a form of largely unrecognized ephemeral centralization in otherwise decentralized systems. A miner can (temporarily) censor transactions for its own benefit [171] or reorder them to maximize its own gain, a notion called miner extractable value (MEV) [90]. The term MEV is slightly deceptive: It does not refer only to value that miners can capture: Some MEV can be captured by ordinary users. Because miners have more power than ordinary users, however, MEV represents an up per bound on the amount of value any entity can obtain through adversarial reordering and complementary transaction insertion. Even when miners order transactions simply based on fees (gas), without manipulation, users themselves can manipulate gas prices to advantage their transactions over those of less sophistication. 
Daian et al. [90] document and quantify ways in which bots (not miners) take advantage of gas dynamics in a way that harms users of DeFi systems today and how MEV even threatens the stability of the underlying consensus layer in a blockchain. Other examples of transaction-order manipulation surface regularly, e.g., [50, 154]. 
43
New transaction-processing methods such as rollups are a very promising approach to the scaling problems of high-throughput blockchains. They do not, however, address the problem of MEV. Instead, they shift it to the entity that generates the rollup. That entity, whether the operator of a smart contract or a user furnishing a (zk-)rollup with a validity proof, has the power to order and insert transactions. In other words, rollups swap MEV for REV: Rollup-Extractable Value. 
MEV affects upcoming transactions that have been submitted to the mempool but are not yet committed on chain. Information about such transactions is broadly available in the network. Miners, validators, and ordinary network participants can therefore exploit this knowledge and create dependent transactions. In addition, min ers and validators may influence the order of those transactions that they commit themselves and exploit this to their advantage. 
The problem of undue influence by leaders on transaction ordering in consensus protocols has been known in the literature since the 1990s [71, 190], but no satisfying solutions have been realized in practice so far [97]. The main reason is that pro posed solutions—at least until very recently—cannot readily be integrated with public blockchains, as they rely on the content of transactions remaining secret until after their ordering has been determined. 
Fair Sequencing Services (FSS) overview: DONs will provide tools to decentral ize transaction ordering and implement it according to a policy specified by a relying contract creator, ideally one that is fair, and not advantaging actors who wish to manipulate transaction ordering. Collectively, these tools constitute FSS. 
FSS includes three components. The first is monitoring of transactions. In FSS, oracle nodes in O both monitor the mempool of MAINCHAIN and (if desired) permit off-chain submission of transactions through a specialized channel. The second is se quencing of transactions. The nodes in O order transactions for a relying contract according to a policy defined for that contract. The third is posting of transactions. After the transactions are ordered, the nodes in O jointly send the transactions to the main chain. 
The potential benefits of FSS include: 
• Order-fairness: FSS includes tools to help developers ensure that transactions input to a particular contract are ordered in a way that does not give an unfair advantage to well-resourced and/or technically savvy users. Ordering policies can be specified for this purpose. 
• Reduction or elimination of information leaks: By ensuring that network partic ipants cannot exploit knowledge about upcoming transactions, FSS can abate or eliminate attacks like front-running that are based on information available in the network before transactions are committed. Preventing exploitation of such leakage ensures that adversarial transactions which depend on original pending transactions cannot enter the ledger before the original transactions are commit ted. 
44
• Reduced transaction cost: By eliminating players’ need for speed in submitting their transactions to a smart contract, FSS can greatly reduce the cost of trans action processing. 
• Priority ordering: FSS can automatically give critical transactions special priority ordering. For example, in order to prevent front-running attacks against oracle reports, e.g., [79], FSS can insert an oracle report into a stream of transactions retroactively. 
An overarching goal of the FSS in DONs is to empower DeFi creators to realize fair financial systems, that is, systems that don’t advantage particular users (or miners) over others on the basis of speed, insider knowledge, or ability to perform technical manipulation. While a crisp, general notion of fairness is elusive, and perfect fairness in any reasonable sense is unachievable, FSS aims to provide developers with a powerful set of tools so that they can enforce policies that help meet their design goals for DeFi. 
We note that while the main goal of FSS is to act as a fair sequencing service for the MAINCHAIN that DONs target, some of the same fairness desiderata that FSS guarantees can also be appropriate for (decentralized) protocols that are run among DON parties. Thus, FSS can be viewed more broadly as a service provided by a subset of DON nodes to fairly sequence not only transactions sent by users of MAINCHAIN but also transactions (i.e., messages) shared among other DON nodes. In this section, we will focus primarily on the goal of sequencing MAINCHAIN transactions. 
Section organization: In Section 5.1, we describe two high-level applications that mo tivate the design of FSS: preventing front-running of oracle reports and preventing front-running of user transactions. We then provide more details on the design of FSS in Section 5.2. Section 5.3 describes examples of fair ordering guarantees and means to achieve them. Finally, Section 5.4 and Section 5.5 discuss network-level threats to such policies and means to address them, respectively for network flooding and Sybil attacks. 
5.1 The Front-Running Problem 
To explain the goals and design of FSS, we describe two general forms of front-running attacks and the limitations of existing solutions. Front-running exemplifies a class of transaction-ordering attacks: There are a number of related attacks such as back running and sandwiching (front-running plus back-running) [237] that we don’t cover here, but which FSS also helps address. 
5.1.1 Oracle Front-Running 
In their traditional role of providing off-chain data to blockchain applications, oracles become a natural target for front-running attacks. 
45
Consider the common design pattern of using an oracle to supply various price feeds to an on-chain exchange: periodically (say every hour), the oracle collects price data for different assets and sends these to an exchange contract. These price-data transactions present obvious arbitrage opportunities: For example, if the newest oracle report lists a much higher price for some asset, an adversary could front-run the oracle report to buy up assets and immediately resell them once the oracle’s report is processed. 
Speed bumps and retroactive pricing: A natural solution to the oracle front running problem is to give oracle reports special priority over other transactions. For example, oracle reports could be sent with high fees to encourage miners to process them first. But this will not prevent front-running if the arbitrage opportunity is high, nor can it prevent arbitrage by the miners themselves. 
Some exchanges have thus resorted to implementing more heavyweight “speed bumps,” such as queuing user transactions for a number of blocks before processing them, or retroactively adjusting prices when a new oracle report arrives. The disadvan tages of these solutions are that they add complexity to the exchange implementation, increase storage requirements and thus transaction costs, and disrupt the user experi ence as asset exchanges are only confirmed after a significant time period. 
Piggybacking: Before moving on to FSS, we discuss piggybacking, a quite simple and elegant solution to the oracle front-running problem. It is not applicable to address front-running in other scenarios, however. 
In short, instead of periodically sending reports to the on-chain contract, oracles publish signed reports that users append to their transactions when buying or selling on-chain assets. The exchange then simply checks that the report is valid and fresh (e.g., the oracle can sign a range of blocks for which the report is valid), and extracts the relevant price feed from it. 
This simple approach has a number of advantages over the above “speed bump” approach: (1) The exchange contract need not keep state of price feeds, which should lead to lower transaction costs; (2) As oracle reports are posted on chain on a by need basis, oracles can generate more frequent updates (e.g., every minute), thereby minimizing arbitrage opportunities from front-running a report9; (3) Transactions can be validated immediately, as they always include a fresh price feed. 
The approach is not perfect, however. First, this piggybacking solution puts the onus on the exchange’s users to fetch up-to-date oracle reports and attach them to their transactions. Second, while piggybacking minimizes arbitrage opportunities, it cannot fully prevent them without affecting the liveness of the on-chain contract. Indeed, if an oracle report is valid until some block number n, then a transaction submitted to block n + 1 would require a new valid report. Due to inherent delays in the propagation of reports from oracles to users, the new report that is valid for block n + 1 would have 
9Arbitrage is only worthwhile if the exploitable difference in asset prices exceeds the extraneous fees required to buy and sell the assets, e.g., those collected by miners and the exchange. 
46
to be publicized some period before block n + 1 is mined, say at block n − k, thereby creating a sequence of k blocks where a short-lived arbitrage opportunity exists. We now describe how FSS gets around these limitations. 
Prioritizing oracle reports with FSS: FSS can address the oracle front-running problem by building upon the above piggybacking solution, but pushing the additional work of augmenting transactions with oracle reports to the Decentralized Oracle Net work. 
At a high level, oracle nodes collect transactions destined for an on-chain exchange, agree on a real-time price feed, and post the price feed along with the collected trans actions to the main-chain contract. Conceptually, one can think of this approach as a “data-augmented transaction batching”, where the oracle ensures that an up-to-date price feed is always added to transactions. 
FSS solutions can be implemented transparently to the exchange’s users, and with minimal changes to contract logic, as we describe in more detail in Section 5.2. Ensuring that fresh oracle reports are always prioritized over user transactions is just one example of an ordering policy that FSS can adopt and enforce. Policies of FSS for ensuring order fairness are described more generally in Section 5.3. 
5.1.2 Front-Running User Transactions 
We now turn to front-running in generic applications, where the defense method above does not work. The problem can be captured broadly through the following scenario: An adversary sees some user transaction tx1 sent into the P2P network and injects its own adversarial transaction tx2, so that tx2 is processed before tx1 (e.g., by paying a higher transaction fee). For instance, this kind of front-running is common among bots that exploit arbitrage opportunities in DeFi systems [90] and has affected users of various decentralized applications [101]. Imposing a fair order among the transactions processed on the blockchain addresses this problem. 
More fundamentally, seeing the details of tx1 is sometimes not even necessary and knowledge of its mere existence may allow an adversary to front-run tx1 through its own tx2 and defraud the innocent user that created tx1. For example, the user might be known to trade a particular asset at regular times. Preventing such attacks requires mitigations that avoid leakage of metadata as well [62]. Some solutions for this problem exist, but they introduce delays and usability concerns. 
From network-order to finalized-order with FSS: Opportunities for front-running arise because existing systems have no mechanisms to ensure that the order in which transactions appear on chain respects the order of events and the information flow outside the network. This represents a problem arising from deficiencies in the imple mentation of applications (e.g., trading platforms) on a blockchain. Ideally, one would ensure that transactions are committed on the blockchain in the same order as they were created and sent to the blockchain’s P2P network. But since the blockchain network 
47
is distributed, no such order can be captured. FSS therefore introduces mechanisms to safeguard against violations of fairness, which arise only because of the distributed nature of the blockchain network. 
5.2 FSS Details 

Figure 12: Order-fair mempool with two different transaction paths: direct and mempool-based. 
Fig. 12 shows a general schematic of the FSS. For ensuring fairness, the DON pro viding FSS must interfere with the flow of transactions as they enter MAINCHAIN. Adjustments to clients, to smart contracts on MAINCHAIN, or to both may be neces sary. At a high level, processing of transactions by FSS can be decomposed into three phases, described below: (1) Transaction monitoring; (2) Transaction sequencing; and (3) Transaction posting. Depending on the ordering method used for transaction se quencing, additional protocol steps are needed, as described in the next section. 
5.2.1 Transaction Processing 
Transaction monitoring: We envision two different approaches for FSS to monitor user transactions destined for a specific smart contract, direct and mempool-based: 
• Direct: The direct approach is conceptually simplest, but requires changes to user clients so that transactions are sent directly to the Decentralized Oracle 
48
Network nodes, rather than to the nodes of the main chain. The DON collects user transactions destined to a specific smart contract SC and orders them based on some ordering policy. The DON then sends the ordered transactions to the smart contract on the main chain. Some ordering mechanisms also require the di rect approach because the user that creates a transaction must cryptographically protect it before sending it to FSS. 
• Mempool-based: To facilitate the integration of FSS with legacy clients, the DON can use Mempool Services (MS) to monitor the main chain’s mempool and collect transactions. 
Direct transmission is likely to be the preferred implementation for many contracts, and we believe it should be fairly practical in many cases. 
We briefly discuss how existing DApps could be minimally modified to support direct transmission while preserving a good user experience. We describe approaches using Ethereum and MetaMask [6] since these are the most popular choices today, but the mentioned techniques should extend to other chains and wallets. A recent Ethereum Improvement Proposal, “EIP-3085: Wallet add Ethereum chain RPC method” [100], will make it easy to target custom Ethereum chains (using a different CHAIN ID than that of MAINCHAIN to prevent replay attacks) from MetaMask and other browser based wallets. After implementation of this proposal, a DApp seeking to use a DON would simply add a single method call to their front-end to be able to directly transmit transactions to any DON exposing an Ethereum-compatible API. In the meantime, “EIP-712: Ethereum typed structured data hashing and signing” [49] provides a slightly more involved but already widely deployed alternative, where a DApp user can use MetaMask to sign structured data specifying a DON transaction. The DApp can send this signed structured data to the DON. 
Finally, we note that hybrid approaches are also possible. For example, legacy clients can continue to send transactions into the main chain’s mempool, but critical transactions (e.g., oracle reports) are sent to DON nodes directly (in particular, the set of nodes providing oracle reports such as price-feed updates and the set of nodes providing FSS may overlap or be identical). 
Transaction sequencing: The main purpose of FSS is to guarantee that user trans actions are ordered according to a pre-defined policy. The nature of this policy will depend on the application’s needs and the types of unfair transaction orderings that it aims to prevent. 
Since FSS on the DON is capable of processing data and maintaining local state, they may impose an arbitrary sequencing policy based on the information that is available at the oracles. 
The particular ordering policies and their implementation are discussed subse quently in Section 5.3. 
49
Transaction posting: After collecting and ordering user transactions, received ei ther directly from users or collected from the mempool, the DON sends these trans actions to the main chain. As such, a DON’s interactions with the main chain remain subject to (potentially unfair) transaction ordering governed by the main chain’s min ers. To harness the benefits of decentralized transaction ordering, the target smart contract SC thus has to be designed to treat the DON as a “first-class” citizen. We distinguish two approaches: 
• DON-only contracts: The simplest design option is to have the main chain smart contract SC only accept transactions that have been processed by the DON. This ensures that the smart contract processes transactions in the order proposed by the DON, but de-facto restricts the smart contract to operating in a committee based system (i.e., the DON committee now has ongoing power to determine the ordering and inclusion of transactions). 
• Dual-class contracts: A preferred, more granular design has the main chain smart contract SC accept transactions originating both from the DON and from legacy users,10 but places traditional “speed bumps” on transactions that were not pro cessed by the DON. For example, transactions from the DON may be processed immediately, whereas legacy transactions get “buffered” by the smart contract for a fixed period of time. Other standard mechanisms for preventing front-running such as commit-reveal schemes or VDFs [53] could also be applied to legacy transactions. This ensures that DON-ordered transactions do get processed in the order agreed upon, without giving the DON the unwanted power to censor transactions. 
As the imposition of transaction ordering by FSS requires that transactions are ag gregated “off-chain,” this solution is naturally combined with other aggregation tech niques that aim to reduce on-chain processing costs. For example, after collecting and ordering transactions, the DON may send these transactions to the main chain as a single “batched transaction” (e.g., a rollup), thereby reducing the aggregate transaction fee. 
Enforcing the transaction order: Whether in a DON-only or dual-class design, the main chain smart contract SC and the DON have to be co-designed so as to guar antee that the DON’s transaction ordering is upheld. Here also, we envision different design options: 
• Sequence numbers: The DON can append a sequence number to each transac tion, and send these transactions into the main chain’s mempool. The main 
10If the DON’s transaction monitoring is based on the mempool, legacy transactions must be dis tinguishable from DON transactions so that they are not collected by the DON, e.g., via a special tag embedded in the transaction or by specifying a particular gas price, e.g. DON transactions have gas prices below a certain threshold. 
50
chain smart contract SC ignores transactions that arrive “out-of-sequence.” We note that in this setting, the main-chain miners can decide to ignore the DON’s transaction ordering, thereby causing transactions to fail. It is possible by keep ing (expensive) state for SC to enforce correct transaction ordering, somewhat analogously to how TCP buffers out-of-order packets until missing packets are received. 
• Transaction nonces: For many blockchains, and in particular for Ethereum, the above sequence-numbering approach can leverage built-in transaction nonces to enforce that the main-chain smart contract SC processes transactions in sequence. Here, the DON nodes send transactions to the main chain through a single main chain account, protected with a key shared among the DON nodes. The account’s transaction nonce ensures that transactions are mined and processed in the cor rect order. 
• Aggregate transactions: The DON can aggregate multiple transactions in a rollup (or in a bundle similar to a rollup). The main-chain smart contract needs to be designed to handle such aggregate transactions. 
• Aggregate transactions with a main chain proxy: Here, the DON similarly bun dles transactions into one “meta-transaction” for the main chain, but relies on a custom proxy smart contract to unpack the transactions and relay them to the target contract SC. This technique can be useful for legacy compatibility. Meta transactions act like rollups but differ in that they consist of an uncompressed list of transactions posted once to the main chain. 
The last design has the advantage of seamlessly supporting user transactions that are themselves proxied through a main chain contract before reaching the DON’s target contract SC. For example, consider a user who sends a transaction to some wallet contract, which in turn sends an internal transaction to SC. Assigning a sequence number to such a transaction would be tricky, unless the user’s wallet contract is specially designed to forward the sequence number with every internal transaction to SC. Similarly, such internal transactions cannot be easily aggregated into a meta transaction that is sent directly to SC. We discuss further design considerations for such proxied transactions below. 
5.2.2 Transaction Atomicity 
Our discussion thus far has implicitly assumed that transactions interact with a single on-chain smart contract (e.g., a user sends a buy request to an exchange). Yet, in systems such as Ethereum, a single transaction can consist of multiple internal trans actions, e.g., one smart contract calling a function in another contract. Below, we describe two high-level strategies for sequencing “multi-contract” transactions, while preserving the atomicity of the transaction (i.e., the sequence of actions prescribed by the transaction are all executed in the correct order, or not at all). 
51
Strong atomicity: The simplest solution is to apply FSS, as described above, di rectly to entire “multi-contract” transactions. That is, users send their transactions into the network and FSS monitors, sequences, and posts these transactions to the main chain. 
This approach is technically simple, but has one potential limitation: If a user transaction interacts with two contracts SC1 and SC2 that both want to leverage fair sequencing services, then the sequencing policy of these two contracts has to be con sistent. That is, given two different transactions tx1 and tx2 that each interacts with both SC1 and SC2, it must not be the case that the policy of SC1 orders tx1 before tx2 whereas the policy of SC2 prescribes the opposite order. 
For the vast majority of scenarios of interest, we envision that the sequencing poli cies adopted by different contracts will be consistent. For example, both SC1 and SC2 may want transactions to be ordered by their approximate arrival time in the mempool, and SC1 may further want certain oracle reports to always be delivered first. As the latter oracle report transactions do not interact with SC2, the policies are consistent. 
Weak atomicity: In its full generality, FSS could be applied at the level of individual internal transactions. 
Consider transactions of the form tx = {tx˜ pre,tx˜ SC,tx˜ post}, consisting of some initial transaction(s) tx˜ pre, which results in an internal transaction tx˜ SC to SC, which in turn issues internal transaction(s) tx˜ post. The sequencing policy of SC might determine how the internal transaction tx˜ SC has to be ordered with respect to other transactions sent to SC, but leave open the sequencing order for tx˜ pre and tx˜ post. 
Given the intrinsics of transaction processing in systems such as Ethereum, devel oping a sequencing service that targets specific internal transactions is not straightfor ward. With a specially designed contract SC, this may be realizable as follows: 
1. The transaction tx is sent into the network and mined (without any sequencing performed by FSS). The initial tx˜ pre is executed, and calls tx˜ SC. 
2. SC does not execute tx˜ SC and returns. 
3. FSS monitors internal transactions to SC, sequences them, and posts them back to SC (i.e., by sending transactions tx˜ SC directly to SC). 
4. SC processes the transactions tx˜ SC received from FSS, and issues internal trans actions tx˜ post that result from tx˜ SC. 
With this approach, transactions are not executed fully atomically (i.e., the original transaction tx gets broken up into multiple on-chain transactions), but the ordering of internal transactions is preserved. 
This solution entails a number of design constraints. For example, tx˜ pre cannot assume that tx˜ SC and tx˜ post will be executed. Moreover, SC should be designed so as to execute transactions tx˜ SC and tx˜ post on behalf of a certain user, even though they were 
52
sent by FSS. For these reasons, the more coarse-grained “Strong Atomicity” solution above is likely preferable in practice. 
For respecting more complex dependencies, involving multiple transactions and their respective internal transactions, the transaction scheduler of FSS may contain elaborate functions that resemble those found in transaction managers of relational database managers. 
5.3 Fair Transaction Sequencing 
Here we discuss two notions of fairness for transaction sequencing and the correspond ing implementations, which may be realized by FSS: order-fairness based on a policy imposed by FSS and secure causality preservation, which requires additional crypto graphic methods in FSS. 
Order-fairness: Order-fairness is a notion of temporal fairness in consensus protocols that has first been introduced formally by Kelkar et al. [144]. 
Kelkar et al. aim to achieve a form of natural policy in which transactions are ordered based on the time they are first received by the DON (or the P2P network, in the case of a mempool-based FSS). In a decentralized system, however, different nodes may see transactions arrive in a different order. Establishing a total order on all transactions is the very problem solved by the consensus protocol underlying MAINCHAIN. Kelkar et al. [144] therefore introduce a weaker notion that can be achieved with the help of a Decentralized Oracle Network, called “block-order fairness.” It groups the transactions that the DON has received during a time interval into a “block” and inserts all transactions of the block concurrently and at the same position (i.e., height) into MAINCHAIN. They are thus ordered together and must be executable in parallel, without creating any conflicts among them. Roughly speaking, order fairness then states that if a large fraction of nodes see transaction τ1 before τ2, then τ1 will be sequenced before or in the same block as τ2. By imposing such a coarse granularity on transaction order, the opportunities for front-running and other order related attacks are greatly reduced. 
Kelkar et al. propose a family of protocols called Aequitas [144], which address different deployment models, including synchronous, partially synchronous, and asyn chronous network settings. Aequitas protocols impose significant communication over head relative to basic BFT consensus and are therefore not ideal for practical use. We believe, however, that practical variants of Aequitas will emerge that can be used for transaction sequencing in FSS and other applications. Some related schemes have already been proposed that have less accompanying formalism and weaker properties, e.g., [36, 151, 236], but better practical performance. These schemes can be supported in FSS as well. 
It is also worth noting that the term “fairness” appears elsewhere in the blockchain literature with a different meaning, namely fairness in the sense of opportunity for 
53
miners proportional to their committed resources [106, 181] or for validators in terms of equal opportunity [153]. 
Secure causality preservation: The most widely known approach to prevent front running and other ordering violations in distributed platforms relies on cryptographic techniques. Their common feature is to hide the transaction data itself, waiting until the order at the consensus layer has been established, and to reveal the transaction data later for processing. This preserves the causal order among the transactions that are executed by the blockchain. The relevant security notions and cryptographic protocols have been developed considerably before the advent of blockchains [71, 190]. 
The security conditions of “input causality” [190] and “secure causality preserva tion” [71, 97] require formally that no information about a transaction becomes known before the position of this transaction in the global order has been determined. An ad versary must not be able to infer any information until that time, in a cryptographically strong sense. 
One can distinguish four cryptographic techniques to preserve causality: 
• Commit-reveal protocols [29, 142, 145]: Instead of a transaction being announced in the clear, only a cryptographic commitment to the transaction is broadcast. Af ter all committed but hidden transactions have been ordered (in early blockchain systems on MAINCHAIN itself, but here by FSS), the sender must open the com mitment and reveal the transaction data within a predetermined time interval. The network then verifies that the opening satisfies the earlier commitment. The origins of this method date prior to the advent of blockchains. 
Although it is particularly simple, the approach introduces considerable draw backs and is not easy to employ for two reasons. First, since only the commit ment exists at the level of the ordering protocol, the semantics of the transaction cannot be validated during consensus. An additional round-trip to the client is required. More severely, though, weighs the possibility that no opening may ever arrive, which could amount to a denial-of-service attack. Furthermore, it is difficult to determine whether the opening is valid in a consistent, distributed manner because all participants must agree on whether the opening arrived in time. 
• Commit-reveal protocols with delayed recovery [145]: One challenge with the commit-reveal approach is that a client may commit to a transaction specu latively and reveal it later only if subsequent transactions make it profitable. A recent variant of the commit-reveal approach improves the resilience against this kind of misbehavior. In particular, the TEX protocol [145] addresses this problem using a clever approach in which encrypted transactions include a decryption key obtainable by computing a verifiable delay function (VDF) [53, 221]. If a client fails to decrypt her transaction in a timely way, others in the system will decrypt it on her behalf by solving a moderately hard cryptographic puzzle. 
54
• Threshold encryption [71, 190]: This method exploits that the DON may perform threshold-cryptographic operations. Assume FSS maintains an encryption public key pkO and the oracles share the corresponding private key among themselves. Clients then encrypt transactions under pkO and send them to FSS. FSS orders transactions on the DON, then decrypts them, and finally injects them into MAINCHAIN in the fixed order. Encryption therefore ensures that ordering is not based on the transaction content, but that the data itself is available when needed. 
This method was originally proposed by Reiter and Birman [190] and later re fined by Cachin et al. [71], where it was integrated with a permissioned consensus protocol. More recent work has explored the use of threshold cryptography as a consensus-level mechanism for generic messages [33, 97] and for general compu tations with shared data [41]. 
Compared to commit-reveal protocols, threshold encryption prevents simple denial of-service attacks (although care is required given the computational cost of de cryption). It lets the DON proceed autonomously, at its own speed and without waiting for further client actions. Transactions may be validated immediately af ter they have been decrypted. Moreover, clients encrypt all transactions with one key for the DON and the communication pattern remains the same as with other transactions. Managing the threshold key securely and with changing nodes in O, however, may pose additional difficulties. 
• Committed secret sharing [97]: Instead of encrypting the transaction data under a key held by the DON, the client may also secret-share it for the nodes in O. Using a hybrid, computationally secure secret sharing scheme, the transaction is encrypted first using a symmetric cipher with a random key. Only the corre sponding symmetric key is shared and the ciphertext is submitted to the DON. The client must send one key share to each node in O using a separately en crypted message. The remaining protocol steps are the same as with threshold encryption, except that the transaction data is decrypted with the symmetric algorithm after reconstructing the per-transaction key from its shares. 
This method does not require setup or management of a public-key cryptosystem associated with the DON. However, the clients must be aware of the nodes in O and communicate in a secure context with each one of them, which places additional burden on the clients. 
Although the cryptographic methods offer complete protection against information leaking from submitted transactions to the network, they do not conceal metadata. For example, an IP address or an Ethereum address of the sender could still be used by an adversary to perform front-running and other attacks. Various privacy-enhancing techniques deployed at the network layer, e.g., [52, 95, 107], or the transaction layer, e.g., [13, 65], would be needed to accomplish this goal. The impact of a particular piece of metadata, namely to which contract a transaction is sent, can be (partially) concealed 
55
through multiplexing many contracts on the same DON. Cryptographic concealment of transactions per se also doesn’t prevent prioritization of transactions by corrupted DON nodes in collusion with transaction senders. 
Secure causality as guaranteed by cryptographic protocols complement the order fairness guarantees for any policy, and we intend to explore a combination of the two methods, where this is possible. If an adversary cannot gain significant advantage from observing metadata, the secure causality-preservation protocols could be used alongside a na¨ıve ordering approach as well. For example, oracle nodes can write transactions to L as soon as they receive them, without duplication. Transactions would then be ordered according to their appearance on L and subsequently decrypted. 
We also plan to consider the use of TEEs as a way to help enforce fair ordering; for example, Tesseract [44] may be viewed as achieving a form of causal ordering, but one strengthened by the ability of the TEE to process transactions in explicit form while retaining their confidentiality. 
5.4 Network-Layer Considerations 
So far, our description of FSS has mainly focused on the problem of enforcing that the finalized order of transactions matches their observed order in the network. Hereafter, we consider fairness issues that could arise at the network layer itself. 
High-frequency traders in conventional electronic marketplaces invest considerable resources to obtain superior network speed [64], and traders in cryptocurrency ex changes exhibit similar behavior [90]. Network speed confers an advantage both in observing the transactions of other parties and in submitting competing transactions. One remedy deployed in practice and popularized in the book Flash Boys [155] is the “speed bump” introduced initially in the IEX exchange [128] and later in other exchanges [179] (with mixed results [19]). This mechanism imposes a delay (350 mi croseconds in IEX) on access to the market, with the aim of neutralizing advantages in speed. Empirical evidence, e.g. [128], supports its efficacy in decreasing certain trading costs for ordinary investors. FSS can be used simply to implement an asymmetrical speed bump—one that delays incoming transactions. 
Budish, Cramton, and Shim [64] argue that exploitation of advantages in speed is inescapable in continuous-time markets, and argue for a structural remedy in the form of batch-auction-based markets. But this approach has not taken hold broadly in existing trading platforms. 
Conventional trading systems are centralized, typically receiving transactions through a single network connection. In a decentralized system, by contrast, it is possible to observe transaction propagation from multiple vantage points. Consequently, it is pos sible to observe behaviors such as network flooding in a P2P network. We intend to explore network-layer approaches to FSS that help developers to specify policies prohibiting such undesirable network behaviors. 
56
5.5 Entity-Level Fairness Policies 
Order-fairness and secure causality aim at enforcing an ordering on transactions that respects the time when they were created and first submitted to the network. A limita tion of this notion of fairness is that it does not prevent attacks in which an adversary gains an advantage by flooding a system with many transactions, a strategy observed in the wild as a way to perform effective transaction sniping in token sales [159] and to create congestion resulting in liquidation of collateralized debt positions (CDPs) [48]. In other words, order-fairness enforces fairness with respect to transactions, not players. 
As shown in the CanDID system [160], it is possible to use oracle tools such as DECO or Town Crier in conjunction with a committee of nodes (such as a DON) to achieve various forms of Sybil-resistance while protecting privacy. Users can register identities and provide evidence of their uniqueness without disclosing the identities themselves. Sybil-resistant credentials offer a possible approach to enriching transaction-ordering policies in a way that would limit opportunities for flooding attacks. For example, a token sale might permit only one transaction per registered user, where registration requires a proof of uniqueness of a national identifier, such as a Social Security Number. Such an approach isn’t foolproof, but may prove a useful policy to mitigate transaction flooding attacks. 
6 The DON Transaction-Execution Framework (DON-TEF) 
DONs will provide oracle and decentralized-resource support for layer-2 solutions within what we call the Decentralized Oracle Network Transaction-Execution Framework (DON TEF) or TEF for short. 
Today, the frequency of updates to DeFi contracts is limited by main chain latencies, e.g., the 10-15 second average block interval in Ethereum [104]—as well as the cost of pushing large amounts of data on chain and limited computational/tx throughput— motivating scaling approaches such as sharding [148, 158, 232] and layer-2 execution [5, 12, 121, 141, 169, 186, 187]. Even blockchains with much faster transaction times, e.g., [120], have proposed scaling strategies that involve off-chain computation [168]. TEF is meant to act as a layer-2 resource for any such layer-1 / MAINCHAIN systems. 
Using TEF, DONs can support faster updates in a MAINCHAIN contract while retaining the key trust assurances provided by the main chain. TEF can support any of a number of layer-2 execution techniques and paradigms, including rollups,11 optimistic rollups, Validium, etc., as well as a threshold trust model in which DON nodes execute transactions. 
The TEF is complementary to FSS and intended to support it. In other words, any application running in the TEF can use FSS. 
11Often called “zk-rollups,” a misnomer, as they do not necessarily need zero-knowledge proofs. 57
6.1 TEF Overview 
The TEF is a design pattern for the construction and execution of a performant hybrid smart contract SC. 
In accordance with the main idea behind hybrid smart contracts, TEF involves a decomposition of SC into two pieces: (1) What we call in the TEF context an anchor contract SCa on MAINCHAIN and (2) DON logic exect that we call the TEF executable. We use SC here to denote the logical contract implemented by the combination of SCa and exect. (As noted above, we expect to develop compiler tools to decompose a contract SC automatically into these components.) 
The TEF executable exectis the engine that processes users’ transactions in SC. It can execute in a performant way, as it runs on the DON. It has several functions: 
• Transaction ingestion: exect receives or fetches users’ transactions. It can do so directly, i.e., through transaction submission on the DON, or via the MAINCHAIN mempool using MS. 
• Fast transaction execution: exect processes transactions involving assets within SC. It does so locally, i.e., on the DON. 
• Fast and low-cost oracle / adapter access: exect has native access to oracle reports and other adapter data leading to, e.g., faster, cheaper, and more accurate asset pricing than MAINCHAIN execution. Moreover, off-chain oracle access reduces the oracle’s operational cost, hence the cost of using the system, by avoiding expensive on-chain storage. 
• Syncing: exect periodically pushes updates from DON onto MAINCHAIN, updat ing SCa. 
The anchor contract is the MAINCHAIN front end of SC. As the higher-trust com ponent of SC, it serves several purposes: 
• Asset custody: Users’ funds are deposited into, held in, and withdrawn from SCa. 
• Syncing verification: SCa may verify the correctness of state updates when exect syncs, e.g., SNARKs attached to rollups. 
• Guard rails: SCa may include provisions to protect against corruption or failures in exect. (See Section 7 for more details.) 
In TEF, users’ funds are custodied on MAINCHAIN, meaning the DON is itself non custodial. Depending on the choice of syncing mechanism (see below), users may need to trust the DON only for accurate oracle reports and timely syncing with MAINCHAIN. The resulting trust model is very similar to that for order-book-based DEXes, e.g., [2], which today generally include an off-chain component for order matching and an on chain component for clearing and settlement. 
58
To use the vocabulary of payment systems, one may think of exect as the component of SC responsible for clearing, while SCa handles settlement. See Fig. 13 for a schematic depiction of TEF. 

Figure 13: TEF schematic. In this example, transactions pass through the mempool of MAINCHAIN via MS to the DON. 
TEF benefits: TEF carries three main benefits: 
• High performance: SC inherits the DON’s much higher throughput than MAINCHAIN for both transactions and oracle reports. Additionally, exect can process transac tions faster and respond to oracle reports in a more timely way than an imple mentation on MAINCHAIN alone. 
• Lower fees: The process of syncing is less time-sensitive than transaction pro cessing, and transactions can be sent from the DON to MAINCHAIN in batches. Consequently, the per-transaction on-chain fees (e.g., gas costs) with this ap proach are much lower than for a contract that runs only on MAINCHAIN. 
• Confidentiality: The confidentiality mechanisms of the DON can be brought to bear on SC. 
59
TEF limitations: One limitation of TEF is that it does not support instantaneous withdrawals, as they occur only on MAINCHAIN: Upon sending a withdrawal request to SCa, a user may need to wait for exect to perform a state update that includes the withdrawal transaction before it can be approved. We discuss some partial remedies, however, in Section 6.2. 
Another limitation of TEF is that it does not support atomic composition of DeFi contracts on MAINCHAIN, specifically the ability to route assets through multiple DeFi contracts in a single transaction. TEF can, however, support such atomicity among DeFi contracts running on the same DON. We also discuss some ways to address this problem in Section 6.2. 
6.2 Transaction Routing 
Transactions for SC can be sent by users directly to the DON or can be routed through the mempool in MAINCHAIN (via FSS). There are four distinct transaction types, each of which requires different handling: 
Within-contract transactions: Because it sidesteps the complications of gas dy namics, TEF provides SC more flexibility in its handling of transactions than would be available in a layer-1 contract. For example, while a mempool transaction in Ethereum can be overwritten by a fresh transaction with a higher gas price, SC can treat a trans action that operates on assets within SC as authoritative as soon as it becomes visible in the mempool. Consequently, SC need not wait for a transaction to be confirmed within a block, resulting in considerably reduced latency. 
Proxying: A user may wish to send a transaction τ to SC via a wallet contract or other contract on MAINCHAIN. It is possible for the DON to simulate execution of τ on MAINCHAIN to determine whether it results in a follow-on transaction to SC. If so, τ can be sequenced with other transactions for SC that do. There are a few possibilities for how the DON identifies such transactions: (1) The DON can simulate all transactions in the mempool (an expensive approach); (2) Certain contracts or contract types, e.g., wallets, can be listed for monitoring by the DON; or (3) Users can annotate transactions for DON inspection. 
Matters become more complicated when a single transaction interacts with two contracts, SC1 and SC2, both of which use Fair Sequencing Services and have incom patible ordering policies. The DON might, for example, sequence τ at the latest time that is compatible with both. 
Deposits: A transaction depositing a MAINCHAIN asset into SC needs to be con firmed in a block before SC can treat it as valid. When it detects the mining of a transaction that sends assets (e.g., Ether) into SCa, exect can instantly confirm the 
60
deposit. For example, it can apply a current oracle-reported price on the DON to the asset. 
Withdrawals: As noted above, a limitation of TEF is that withdrawals cannot al ways be executed instantaneously. In a rollup-type execution model, the withdrawal request must be sequenced with other transactions, i.e., rolled up, in order to be safely processed. There are, however, some partial remedies to this limitation. 
If the DON can quickly compute a rollup validity proof up to the withdrawal trans action, then observing a user’s transaction τ in the mempool exect can send a state update transaction τ0for τ at a higher gas price, a kind of beneficial front-running. Provided that τ isn’t mined before τ0reaches the mempool, τ0 will precede τ , and τ will effect an approved withdrawal. 
In a TEF variant where the DON is relied upon to compute state updates (see the threshold signing variant below), the DON can alternatively determine off-chain whether τ ought to be approved given the state of SC upon its execution. The DON can then send a transaction τ0that approves withdrawal τ—without effecting a full state update. 
If this approach isn’t possible, or in cases where it doesn’t succeed, a DON-initiated transaction τ0can send funds to the user in response to τ so that the user need not initiate an additional transaction. 
6.3 Syncing 
The TEF executable exect periodically pushes updates from DON to MAINCHAIN, updating the state of SCa in a process we refer to as syncing. Syncing may be thought of as propagation of layer-2 transactions to layer-1, so TEF can draw on any of a number of existing techniques for this purpose, including rollups [5, 12, 16, 69], optimistic rollups [10, 11, 141], Validium [201], or basic threshold signing, e.g., threshold BLS, Schnorr, or ECDSA [24, 54, 116, 202]. In principle, trusted execution environments can also attest to the correctness of state changes, offering a much more performant alternative to rollups, but with a hardware-dependent trust model. (See, e.g., [80].) 
Below we compare these syncing options with respect to three key properties in TEF: 
• Data availability: Where is the state of SC stored? At least three options are available in TEF: on the MAINCHAIN, on a DON, or by some third-party storage providers such as IPFS. They achieve different security guarantees, availability levels, and performance profiles. Briefly, storing state on the MAINCHAIN enables on-chain auditability and eliminates reliance on any party for state availability; on the other hand, storing state off-chain can reduce storage cost and improve throughput, at the cost of trusting storage providers (DON or third parties) for data availability. Of course, flexible models that combine these options are also possible. We indicate the required form of data availability in Table 1. 
61
• Correctness guarantees: How does SCa ascertain the correctness of the updates pushed by exect? This affects the computational load on exect and SCa and the syncing latency (see below). 
• Latency: Syncing latency has three contributing factors: (1) The time taken for exect to generate a syncing transaction τsync; (2) The time taken for τsync to be confirmed on MAINCHAIN; and (3) The time for τsync to take effect on SCa. In TEF, latency is particularly important for withdrawals (but less so for within-contract transactions) because withdrawals necessarily require an (at least partial) state sync. 

Syncing options 
Data 
availability 
Correctness 
guarantees Latency 

Rollup [5, 12, 16, 69] On-chain Validity proofs Time taken to generate validity proofs (e.g., min 
utes in current systems) 
Validium [201] Off-chain Validity proofs Same as above 

Optimistic rollup [10, 11, 141] 
On-chain Fraud proofs Length of the challenge period (e.g., days or 
weeks) 

Threshold signing [24, 54, 116, 202] 
Trusted execution en vironments [80] 
Flexible Threshold signa tures by DON 
Flexible Hardware-based attestations 
Instantaneous Instantaneous 

Table 1: Various syncing options in TEF and their properties. 
Table 1 summarizes these properties in the five main syncing options in TEF. (Note that we do not intend to compare these technologies as standalone layer-2 scaling solutions. For that we refer readers to e.g., [121].) 
Now we discuss each syncing option. 
Rollups: A rollup [69] is a protocol in which the state transition effected by a batch of transactions is computed off-chain. The state change is then propagated onto MAINCHAIN. 
To implement rollups, the anchor smart contract SCa stores a compact represen tation Rstate (e.g., a Merkle root) of the actual state. To sync, exect sends τsync = (T, R0state) to SCa where T is the set of the transactions it processed since the last 
62
sync and R0state is the compact representation of the new state calculated by applying transactions in T to the previous state Rstate. 
There are two popular variants that differ in how SCa verifies state updates in τsync. The first, (zk-)rollups, attach a succinct argument of correctness, sometimes called a validity proof, for the transition Rstate → R0state. To implement this variant, exect computes and submits the validity proof (e.g., a zk-SNARK proof) along with τsync, proving that R0state is the result of applying T to the current state of SCa. The anchor contract accepts the state update only after it has verified the proof. 
Optimistic rollups do not include arguments of correctness, but have staking and challenge procedures that facilitate distributed verification of state transitions. For this rollup variant, SCa tentatively accepts τsync assuming it is correct (hence the optimism) but τsync does not take effect until after a challenge period, during which any party monitoring MAINCHAIN can identify erroneous state updates and inform SCa to take necessary actions (e.g., to rollback the state and inflict a penalty on exect.) 
Both rollup variants achieve on-chain data availability, as transactions are posted on-chain, from which the full state can be constructed. The latency of zk-rollups is dominated by the time needed to generate validity proofs, which typically is on the order of minutes in existing systems [16] and will likely see improvements over time. Optimistic rollups, on the other hand, have a higher latency (e.g., days or weeks) because the challenge period needs to be long enough for fraud proofs to work. The implication of slow confirmation is subtle and sometimes specific to the scheme, so that a thorough analysis is out of scope. For instance, certain schemes consider payment transactions as “trustless final” [109] before the state update is confirmed, since a regular user could verify a rollup much more quickly than the MAINCHAIN. 
Validium: Validium is a form of (zk-)rollup that makes data available off-chain only and does not maintain all data on MAINCHAIN. Specifically, exect sends only the new state and the proof but not transactions to SCa. With Validium-style syncing, exect and the DON that executes it are the only parties that store the complete state and that execute transactions. As with zk-rollups, syncing latency is dominated by validity proof generation time. Unlike zk-rollups, however, Validium style syncing reduces the storage cost and increases the throughput. 
Threshold signing by DON: Assuming a threshold of DON nodes is honest, a simple and fast syncing option is to have DON nodes collectively sign the new state. This approach can support both on-chain and off-chain data availability. Note that if users trust DON for oracle updates, they do not need to trust it more for accepting state updates, as they are already in a threshold trust model. Another benefit of threshold signing is low latency. Support for new transaction signature formats as proposed in EIP-2938 [70] and known as account abstraction would make threshold signing considerably easier to implement, as it would eliminate the need for threshold ECDSA, which involves considerably more complex protocols (e.g., [116, 117, 118]) 
63
than alternatives such as threshold Schnorr [202] or BLS [55] signatures. 
Trusted Execution Environments (TEEs): TEEs are isolated execution environ ments (usually realized by hardware) that aim to provide strong security protections for programs running inside. Some TEEs (e.g., Intel SGX [84]) can produce proofs, known as attestations, that an output is correctly computed by a specific program for a particular input12. A TEE-based variant of TEF syncing can be implemented by replacing proofs in (zk-)rollups or Validium with TEE attestations using techniques from [80]. 
Compared to zero-knowledge proofs used in rollups and Validium, TEEs are much more performant. Compared to threshold signing, TEEs remove the complexity of generating threshold ECDSA signatures as there need in principle be only one TEE involved. Using TEEs does, however, introduce extra hardware-dependent trust as sumptions. One can also combine TEEs with threshold signing to create resilience against compromise of a fraction of TEE instances, although this protective measure reintroduces the complexity of generating threshold ECDSA signatures. 
Additional flexibility: These syncing options can be refined to provide more flexi bility in the following ways. 
• Flexible triggering: TEF application can determine the conditions under which syncing is triggered. For example, syncing can be batch-based, e.g., occur after every N transactions, time-based, e.g., every 10 blocks, or event-based, e.g., occur whenever target asset prices move significantly. 
• Partial syncing: It is possible and in some cases desirable (e.g., with rollups, partial syncing can reduce latency) for exect to provide fast syncing of small amounts of state, performing full syncing perhaps only periodically. For example, exect can approve a withdrawal request by updating a user’s balance in SCa without otherwise updating MAINCHAIN state. 
6.4 Reorgs 
Blockchain reorganizations resulting from network instability or even from 51%-attacks can pose a threat to the integrity of a main chain. In practice, adversaries have used them to mount double-spending attacks [34]. While such attacks on major chains are challenging to mount, they remain feasible for some chains [88]. 
Because it operates independently of MAINCHAIN, a DON offers the interesting possibility of observing and providing some protections against reorgs associated with attacks. 
For example, a DON can report to a relying contract SC on MAINCHAIN the ex istence of a competing fork of some threshold length τ . The DON can additionally 
12Supplementary details can be found in Appendix B.2.1. They are not required for understanding. 64
provide proof—in either a PoW or PoS setting—of the existence of such a fork. The contract SC can implement suitable defensive actions, such as suspending further trans action execution for a period of time (e.g., to allow exchanges to blacklist double-spent assets). Note that although an adversary mounting a 51%-attack can seek to censor reports from a DON, a countermeasure in SC is to require periodic reports from the DON in order to process transactions (i.e., a heartbeat) or to require a fresh report to validate a high-value transaction. 
While such forking alerts are in principle a general service the DON can provide for any of a number of purposes, our plan is to incorporate them with the TEF. 
7 Trust Minimization 
As a decentralized system with participation from a heterogeneous set of entities, the Chainlink network provides strong protection against failures in both liveness (avail ability) and safety (report integrity). Most decentralized systems, however, vary in the degree to which their constituent components are themselves decentralized. This is true even of large systems, where limited decentralization among miners [32] and intermediaries [51] has long been present. 
The goal of any decentralization effort is trust minimization: We seek to reduce the adverse effects of systemic corruption or failure within the Chainlink network, even that due to a malicious DON. Our guiding principle is the Principle of Least Privilege [197]. System components and actors within the system should have privileges strictly scoped to allow only for the successful completion of their assigned roles. 
Here we lay out several concrete mechanisms for Chainlink to adopt in its drive toward ever-greater trust minimization. We characterize these mechanisms in terms of the loci, i.e., system components, in which they are rooted, shown in Fig. 14. We address each locus in a respective subsection. 
7.1 Data-Source Authentication 
Current operating models for oracles are constrained by the fact that few data sources digitally sign the data they omit, in large part because TLS does not natively sign data. TLS does make use of digital signatures in its “handshake” protocol (to establish a shared key between a server and client). HTTPS-enabled servers thus have certificates on public keys that can in principle serve to sign data, but they do not generally use these certificates to support data signing. Consequently, the security of a DON, as in today’s oracle networks, relies on oracle nodes faithfully relaying data from a data source to a contract. 
An important long-term component of our vision for trust minimization in Chain link involves stronger data-source authentication through support of tools and stan dards for data signing. Data signing can help enforce end-to-end integrity guarantees. In principle, if a contract accepts as input a piece of data D signed directly by a data 
65

Figure 14: Loci of trust-minimizing mechanisms discussed in this section. 1 Data sources provide data to the 2 DON, which relays a function of the data to a dependent  
3 smart contract. Additionally, the DON or the oracle network includes 4 node management smart contracts on MAINCHAIN for, e.g., compensating nodes, guard rails, and so forth. 
source, then the oracle network cannot feasibly tamper with D. Various encouraging efforts to enable such signing of data have emerged, including OpenID Connect, which is designed primarily for user authentication [9], TLS-N, an academic project aiming to extend TLS [191] by repurposing TLS certificates, and TLS Evidence Extensions [63]. While OpenID Connect has seen some adoption, however, TLS Evidence Extensions and TLS-N have yet to see adoption. 
Another potential avenue of data-source authentication is to use publishers’ own Signed HTTP Exchanges (SXG) [230], which they can cache on content-delivery net works as part of the Accelerated Mobile Pages (AMP) protocol [225]. The Chrome mo bile browser displays the content from AMP-cached SXGs as if they were served from their publishers’ own network domains instead of the cache-server domain. This brand ing incentive, coupled with the relative ease of enabling it using services like Cloud Flare’s Real URL [83] and Google’s amppackager [124], may lead to widespread adop tion of SXGs in cached news content, which would enable a simple, tamper-resistant way for Chainlink oracles to trigger on newsworthy events reported in valid SXGs. While AMP-cached SXGs from news publishers would not be useful for high-tempo applications like reports on trading data, they could be a secure source for custom contracts pertaining to real-world events like extreme weather or election outcomes. 
We believe that simple deployment, mature tools, and flexibility will be vital to accelerating data-source signing. Enabling data providers to use Chainlink nodes as an authenticated API front end seems a promising approach. We intend to create an 
66
option for nodes to function in this mode, with or without participation in the network as a full-blown oracle. We refer to this capability as authenticated data origination (ADO). By using Chainlink nodes with ADO, data sources will be able to benefit from the experience and tools developed by the Chainlink community in adding digital signing capabilities to their existing suite of off-chain APIs. Should they choose to run their nodes as oracles, they can additionally open up potential new revenue streams under the same model as existing data providers, e.g., Kraken [28], Kaiko [140], and others, that run Chainlink nodes to sell API data on chain. 
7.1.1 The Limitations of Authenticated Data Origination 
Digital signing by data sources, while it can help strengthen authentication, isn’t suf ficient per se to accomplish all of the natural security or operational goals of an oracle network. 
To begin with, a given piece of data D must still be relayed in a robust and timely way from a data source to smart contract or other data consumer. That is, even in an ideal setting in which all data is signed using keys pre-programmed into dependent contracts, a DON would still be needed to communicate the data reliably from sources to contracts. 
Additionally, there are a number of cases in which contracts or other oracle-data consumers want access to authenticated output of various functions computed over source data for two main reasons: 
• Confidentiality: A data source API may provide sensitive or proprietary data that needs to be redacted or sanitized before it is made publicly visible on chain. Any modification to signed data, however, invalidated the signature. Put another way, na¨ıve ADO and data sanitization are incompatible. We show in Example 3 how the two can be reconciled through an enhanced form of ADO. 
• Data source faults: Both errors and failures can affect data sources, and digi tal signatures address neither problem. From its inception [98], Chainlink has already included a mechanism to remediate such faults: redundancy. The re ports issued by oracle networks typically represent the combined data of multiple sources. 
We now discuss schemes we are exploring in the ADO setting to enhance the con fidentiality of source data and to combine data from multiple sources securely. 
7.1.2 Confidentiality 
Data sources may not anticipate and make available the full gamut of APIs desired by users. Specifically, users may wish to access pre-processed data to help ensure confidentiality. The following example illustrates the problem. 
67
Example 3. Alice wishes to obtain a decentralized identity (DID) credential stating that she is over 18 years of age (and thus can, for instance, take out a loan). To do so, she needs to prove this fact about her age to a DID credential issuer. 
Alice hopes to use data from her state’s Department of Motor Vehicles (DMV) website for the purpose. The DMV has a record of her birthdate and will emit a digitally signed attestation A on it of the following form: 
A = {Name: Alice, DoB: 02/16/1999}. 
In this example, the attestation A may be sufficient for Alice to prove to the DID credential issuer that she’s over 18. But it needlessly leaks sensitive information: Alice’s exact DoB. Ideally, what Alice would like from the DMV instead is a signature on a simple statement A0that “Alice is over 18 years of age.” In other words, she wants the output of a function G on her birthdate X, where (informally), A0 = G(X) = True if CurrentDate − X ≥ 18 years; otherwise, G(X) = False. 
To generalize, Alice would like to be able to request from the data source a signed attestation A0 of the form: 
A0 = {Name: Alice, Func:G(X), Result: True}, 
where G(X) denotes a specification of a function G and its input(s) X. We envision that a user should be able to provide a desired G(X) as input with her request for a corresponding attestation A0. 
Note that the data source’s attestation A0 must include the specification G(X) to ensure that A0is correctly interpreted. In the above example, G(X) defines the meaning of the Boolean value in A0 and thus that True signifies the subject of the attestation is over 18 years of age. 
We refer to flexible queries in which a user can specify G(X) as functional queries. In order to support use cases like that in Example 3, as well as those involving queries directly from contracts, we intend to include support for functional queries involving simple functions G as part of ADO. 
7.1.3 Combining Source Data 
To reduce on-chain costs, contracts are generally designed to consume combined data from multiple sources, as illustrated in the following example. 
Example 4 (Medianizing price data). To provide a price feed, i.e., the value of one asset (e.g., ETH) with respect to another (e.g., USD), an oracle network will generally obtain current prices from a number of sources, such as exchanges. The oracle network typically sends to a dependent contract SC the median of these values. 
In an environment with data signing, a correctly functioning oracle network obtains from data sources S = {S1, . . . , SnS} a sequence of values V = {v1, v2, . . . , vnS} from nS sources with accompanying source-specific signatures Σ = {σ1, σ2, . . . , σnS}. Upon verifying the signatures, it transmits the price v = median(V ) to SC. 
68
Unfortunately, there is no simple way for an oracle network to transmit the median value v in Example 4 to SC along with a succinct proof σ∗that v was correctly computed over signed inputs. 
A na¨ıve approach would be to encode in SC the public keys of all nS data sources. The oracle network would then relay (V, Σ) and allow SC to compute the median of V . This, however, would result in a proof σ of size O(nS)—i.e., σ∗ would not be succinct. It would also incur high gas costs for SC, which would need to verify all signatures in Σ. 
Use of SNARKs, in contrast, enables a succinct proof of correctly combined au thenticated source values. It may be workable in practice, but imposes fairly high computational costs on the prover, and somewhat high gas costs on chain. Use of Town Crier is also a possibility, but requires the use of TEEs, which does not suit all users’ trust models. 
A helpful concept in which to frame solutions to the general problem of signing com bined data from sources is a cryptographic tool known as functional signatures [59, 132]. Briefly, functional signatures allow a signer to delegate signing capability, such that the delegatee can only sign messages in the range of a function F chosen by the signer. We show in Appendix D how this functional constraint can serve to bound the range of report values emitted by a DON as a function of the values signed by data sources. We also introduce a new primitive, called a discretized functional signature, that in cludes a relaxed requirement for accuracy, but is potentially much more performant than approaches such as SNARKs. 
The problem of combining data sources in a way that includes source authentication of outputs also applies to data aggregators, e.g., CoinCap, CoinMarketCap, CoinGecko, CryptoCompare, etc., which obtain data from a multiplicity of exchanges, which they weight based on volumes, using methodologies that they in some cases make public and are in other cases proprietary. An aggregator that wishes to publish a value with source authentication faces the same challenge as a collection of nodes aggregating source data. 
7.1.4 Processing Source Data 
Sophisticated smart contracts are likely to depend on custom aggregate statistics over primary data sources, such as volatility in recent price history over many assets, or text and photographs from news about pertinent events. 
Because computation and bandwidth are relatively cheap in a DON, these statistics— even complex machine-learning models with many inputs—can be processed economi cally, as long as any output value destined for a blockchain is sufficiently concise. 
For computationally intensive jobs where DON participants may have differing views on complex inputs, extra rounds of communication between the DON partici pants may be required to establish consensus on the inputs before computing the result. As long as the final value is fully determined by the inputs, once input consensus is es tablished each participant can simply compute the value and broadcast it to the other 
69
participants with their partial signature, or send it to an aggregator. 
7.2 DON Trust Minimization 
We envision two main ways of minimizing the trust placed in components of the DON: failover clients and minority reports. 
7.2.1 Failover Clients 
Adversarial models in the cryptography and distributed systems literature typically consider an adversary capable of corrupting (i.e., compromising) a subset of nodes, e.g., fewer than one-third for many BFT protocols. It is commonly observed, however, that if all nodes run identical software, an adversary that identifies a fatal exploit could in principle compromise all nodes more or less simultaneously. This setting is often referred to as a software monoculture [47]. 
Various proposals for automatically diversifying software and software configura tions have been put forth to address the problem, e.g., [47, 113]. As noted in [47], however, software diversity is a complex issue and requires careful consideration. Soft ware diversification, for example, can result in worse security than a monoculture if it increases a system’s attack surface and thus its possible vectors of attack in excess of the security benefits it offers. 
We believe that support for robust failover clients—i.e., clients to which nodes can switch in the face of a catastrophic event—is an especially attractive form of software diversification. Failover clients do not increase the number of potential vectors of attack, as they are not deployed as mainline software. They offer clear benefits, however, as a second line of defense. We intend to support failover clients in DONs as a key means of reducing their dependence for security on a single client. 
Chainlink already has in place a robust system of failover clients. Our approach involves maintaining previous, battle-tested client versions. Today, for example, Chain link nodes with Off-Chain Reporting (OCR) as their primary client include support for Chainlink’s previous FluxMonitor system if needed. Having been in use for some time, FluxMonitor has received security audits and field testing. It provides the same functionality as OCR, just at higher cost—a cost only incurred on an as-needed basis. 
7.2.2 Minority Reports 
Given a sufficiently large minority set Ominority—a fraction of honest nodes that ob serve malfeasance by the majority—it can be helpful for them to generate a minority report. This is a parallel report or flag, relayed to a dependent contract SC on-chain by Ominority. SC can make use of this flag according to its own contract-specific policy. For example, for a contract in which safety is more important than liveness or respon siveness, a minority report might cause the contract to request supplementary reports from another DON, or trigger a circuit breaker (see the next section). 
70
Minority reports can play an important role even when the majority is honest, because any report-aggregation scheme, even if it uses functional signatures, must operate in a threshold manner, to ensure resilience against oracle or data failure. In other words, it must be possible to produce a valid report based on the inputs of kS < nS oracles, for some threshold kS. This means a corrupted DON has some latitude in manipulating report values by selecting its preferred kS values among the nS reported in V by the full set of oracles, even if all sources are honest. 
For example, suppose that nS = 10 and kS = 7 in a system that uses a functional signature to authenticate computation of median over V for the USD price of ETH. Suppose that five sources report a price of $500, while the other five report $1000. Then by medianizing the lowest 7 reports, the DON can output a valid value v = $500, and by medianizing the highest, it can output v = $1000. 
By enhancing the DON protocol so that all nodes are aware of which data was available, and which data was used to construct a report, nodes could detect and flag statistically significant tendencies to favor one set of reports over another, and produce a minority report as a result. 
7.3 Guard Rails 
Our trust model for DONs treats MAINCHAIN as a higher-security, higher-privilege system than DONs. (While this trust model may not always hold true, it is easier to adapt the resulting mechanism to situations where the DON is the higher security platform than vice versa.) 
A natural trust minimization strategy thus involves the implementation of moni toring and failsafe mechanisms in smart contracts—either in a MAINCHAIN front end for a DON or directly in a dependent contract SC. We refer to these mechanisms as guard rails, and enumerate some of the most important here: 
• Circuit breakers: SC may pause or halt state updates as a function either of char acteristics of the state updates themselves (e.g., large variance across sequential reports) or based on other inputs. For example, a circuit breaker might trip in cases where oracle reports vary implausibly over time. A circuit breaker might also be tripped by a minority report. Thus, circuit breakers can prevent DONs from making grossly erroneous reports. 
Circuit breakers can provide time for additional interventions to be considered or exercised. One such intervention is escape hatches. 
• Escape hatches: Under adverse circumstances, as identified by a set of custodi ans, community token holders, or other bodies of trustees, a contract may invoke an emergency facility sometimes called an escape hatch [163]. An escape hatch causes SC to shut down in some manner and/or terminates pending and possibly future transactions. For example, it may return custodied funds to users [17]), 
71
may terminate contract terms [162], or may cancel pending and/or future trans actions [173]. Escape hatches can be deployed in any type of contract, not just one that relies on a DON, but they are of interest as a potential buffer against DON malfeasance. 
• Failover: In systems where SC relies on the DON for essential services, it is pos sible for SC to provide failover mechanisms that ensure service continuation even in the case of DON failure or misbehavior. For example, in the TEF (Section 6), the anchor contract SCa may provide dual interfaces where both on-chain and off-chain execution interfaces are supported for certain critical operations (e.g., withdrawal), or for ordinary transactions, with a suitable delay to prevent front running of DON transactions. In cases where data sources sign data, users could also furnish reports to SCa when the DON fails to do so. 
Fraud proofs, as proposed for various forms of optimistic rollup (see Section 6.3), are similar in flavor and complementary to the mechanisms we enumerate above. They too provide a form of on-chain monitoring and protection against potential failures in off-chain system components. 
7.4 Trust-Minimized Governance 
Like all decentralized systems, the Chainlink network requires governance mechanisms to adjust parameters over time, respond to emergencies, and guide its evolution. Some of these mechanisms currently reside on MAINCHAIN, and may continue to do so even with the deployment of DONs. One example is the payment mechanism for oracle node providers (DON nodes). DON front end contracts on MAINCHAIN contain additional mechanisms, such as guard rails, that may be subject to periodic modification. 
We foresee two classes of governance mechanisms: evolutionary and emergency. 
Evolutionary governance: Many modifications to the Chainlink ecosystem are such that their implementation is not a matter of urgency: Performance improvements, feature enhancements, (non-urgent) security upgrades, and so forth. As Chainlink pro gressively moves toward even more participants in its governance, we expect many or most such changes to be ratified by the community of a specific DON affected by those changes. In the interim, and perhaps ultimately as a parallel mechanism, we believe that a notion of temporal least privilege can be a useful means of implementing evolu tionary governance. Very simply, the idea is for changes to deploy gradually, ensuring the community an opportunity to respond to them. For example, migration to a new MAINCHAIN contract can be constrained so that the new contract must be deployed at least thirty days before activation. 
72
Emergency governance: Exploitable or exploited vulnerabilities in MAINCHAIN contracts or other forms of liveness or safety failures may require immediate interven tion to ensure against catastrophic outcomes. Our intention is to support a multisig intervention mechanism in which, to ensure against malfeasance by any organization, signers will be dispersed across organizations. Ensuring consistent availability of signers and timely access to appropriate chains of command for authorization of emergency changes will clearly require careful operational planning and regular review. These challenges are similar to those involved in testing other cybersecurity incident-response capabilities [134], with a similar need to combat common problems like vigilance decre ment [223]. 
The governance of DONs differs from that of many decentralized systems in its potential degree of heterogeneity. Each DON may have distinct data sources, executa bles, service-level requirements such as uptime, and users. The Chainlink network’s governance mechanisms must be flexible enough to accommodate such variations in operational goals and parameters. We are actively exploring design ideas and plan to publish research on this topic in the future. 
7.5 Public-Key Infrastructure 
With progressive decentralization will come the need for a robust identification of network participants, including DON nodes. In particular, Chainlink requires a strong Public-Key Infrastructure (PKI). A PKI is a system that binds keys to identities. For example, a PKI undergirds the Internet’s system of secure connections (TLS): When you connect to a website via HTTPS (e.g., https://www.chainlinklabs.com) and a lock appears in your browser, that means that the public key of the domain owner has been bound to that owner by an authority—specifically, through a digital signature in a so-called certificate. A hierarchical system of certificate authorities (CAs), whose top level root authorities are hardwired into popular browsers, helps ensure that certificates are issued only to the legitimate owners of domains. 
We expect that Chainlink will eventually make use of decentralized name services, initially the Ethereum Name Service (ENS) [22], as the foundation for our PKI. As its name suggests, ENS is analogous to DNS, the Domain Name System that maps (human-readable) domain names to IP addresses on the internet. ENS, however, in stead maps human-readable Ethereum names to blockchain addresses. Because ENS operates on the Ethereum blockchain, barring key compromise, tampering with its namespace is in principle as difficult as tampering with the contract administering it and/or the underlying blockchain. (DNS, in contrast, has historically been vulnerable to spoofing, hijacking, and other attacks.) 
We have registered data.eth with ENS on the Ethereum mainnet, and intend to establish it as a root namespace under which the identities of oracle data services and other Chainlink network entities reside. 
Domains in ENS are hierarchical, meaning that each domain may contain references to other names under it. Subdomains in ENS can serve as a way to organize and 
73
delegate trust. 
The main role of data.eth will be to serve as an on-chain directory service for data feeds. Traditionally, developers and users of oracles have used off-chain sources (e.g., websites like docs.chain.link or data.chain.link, or social networks such as Twitter) to publish and obtain oracle data feed addresses (such as the ETH-USD price feed). With a highly trustworthy root namespace such as data.eth, it is possible in stead to establish a mapping of eth-usd.data.eth to, e.g., the smart contract address of an on-chain oracle network aggregator for the ETH-USD price feed. This would create a secure path for anyone to refer to the blockchain as the source of truth for that data feed of that price/name pair (ETH-USD). Consequently, such use of ENS realizes two benefits unavailable in off-chain data sources: 
• Strong security: All changes and updates to the domain are recorded immutably and secured cryptographically, as opposed to text addresses on a website, which enjoy neither of these two security properties. 
• Automated on-chain propagation: Updates to the underlying address of a data feed’s smart contract can trigger notifications that propagate to dependent smart contracts and can, for example, automatically update dependent contracts with the new addresses.13 
Namespaces like ENS, however, do not automatically validate legitimate ownership of asserted names. Thus, for example, if the namespace includes the entry 
h“Acme Oracle Node Co.”, addri, 
then a user obtains the assurance that addr belongs to the claimant of the name Acme Oracle Node Co. Without additional mechanisms around namespace administration, however, she does not obtain assurance that the name belongs to an entity legitimately called Acme Oracle Node Co. in a meaningful real world sense. 
Our approach to validation of names, i.e., ensuring their ownership by correspond ing, legitimate real-world entities, relies on several components. Today, Chainlink Labs effectively acts as a CA for the Chainlink network. While Chainlink Labs will continue to validate names, our PKI will evolve into a more decentralized model in two ways: 
• Web-of-trust model: The decentralized counterpart of a hierarchical PKI is of ten referred to as a web-of-trust.14 Variants have been proposed since the 1990s, e.g., [98], and a number of researchers have observed that blockchains can facil itate use of the idea, e.g., [227] by recording certificates in a globally consistent ledger. We are exploring variants of this model to validate the identities of entities in the Chainlink network in a more decentralized way. 
13A dependent contract can optionally include a predetermined delay to allow for manual inspection and intervention by dependent-contract administrators. 
14A term coined by Phil Zimmermann for PGP [238]. 
74
• Linkage to validating data: Today, a substantial amount of oracle node perfor mance data is visible on-chain, and thus archivally bound to node addresses. Such data may be viewed as enriching an identity in the PKI by providing his torical evidence of its (reliable) participation in the network. Additionally, tools for decentralized identity based on DECO and Town Crier [160] enable nodes to accumulate credentials derived from real-world data. As just one example, a node operator can attach a credential to its PKI identity that proves possession of a Dun and Bradstreet rating. These supplementary forms of validation can supplement staking in creating assurance of the security of the network. An or acle node with an established real-world identity may be viewed as having stake in a system deriving from its reputation. (See Section 4.3 and Section 9.6.3.) 
A final requirement for the Chainlink PKI is secure bootstrapping, i.e., securely publishing the root name for the Chainlink network, currently data.eth (analogously to hardwiring of top-level domains in browsers). In other words, how do Chainlink users determine that data.eth is indeed the top-level domain associated with the Chainlink project? The solution to this problem for the Chainlink network is multi-pronged and may involve: 
• Adding a TXT record [224] to our domain record for chain.link that specifies data.eth as the root domain for the Chainlink ecosystem. (Chainlink thus im plicitly leverages the PKI for internet domains to validate its root ENS domain.) 
• Linking to data.eth from Chainlink’s existing website, e.g., from https://docs.chain.link. (Another implicit use of the PKI for internet do mains.) 
• Making the use of data.eth known via various documents, including this whitepa per. 
• Posting data.eth publicly on our social-media channels, such as Twitter, and the Chainlink blog [18]. 
• Placing a large quantity of LINK under the control of the same registrant address as data.eth. 
8 DON Deployment Considerations 
While not a part of our core design, there are several important technical considerations in the realization of DONs that deserve treatment here. 
75
8.1 Rollout Approach 
This paper lays out an ambitious vision of advanced Chainlink functionality whose realization will require solutions to many challenges along the way. This whitepaper identifies some challenges, but unanticipated ones are sure to arise. 
We plan to implement elements of this vision in an incremental fashion over an extended period of time. Our expectation is that DONs will initially launch with support for specific pre-built components built collaboratively by teams within the Chainlink community. The intention is that broader uses of DONs, e.g., the ability to launch arbitrary executables, will see support at a later time. 
One reason for such caution is that composition of smart contracts can have com plex, unintended, and dangerous side effects, as recent flash-loan-based attacks have for instance shown [127, 189]. Similarly, composition of smart contracts, adapters, and executables will require extreme care. 
In our initial deployment of DONs, we plan to include only a pre-built set of tem platized executables and adapters. This will enable study of the compositional security of these functionalities using formal methods [46, 170] and other approaches. It will also simplify pricing: Functionality pricing can be established by DON nodes on a per functionality basis, rather than through generalized metering, an approach adopted in, e.g., [156]. We also expect the Chainlink community to take part in the creation of additional templates, combining various adapters and executables into increasingly useful decentralized services that can be run by hundreds, if not thousands of individual DONs. 
Additionally, this approach can help prevent state bloat, i.e., the need for DON nodes to retain an unworkable amount of state in working memory. This problem is already arising in permissionless blockchains, motivating approaches such as “stateless clients” (see, e.g., [206]). It can be more acute in higher throughput systems, motivating an approach in which a DON deploys only state-size-optimized executables. 
As DONs evolve and mature and include robust guard rails, as discussed in Sec tion 7, cryptoeconomic and reputation-based security mechanisms as discussed in Sec tion 9, and other features that provide a high degree of assurance for DON users, we also expect to develop a framework and tools to facilitate broader launch and use of DONs by the community. Ideally, these tools will enable a collection of node operators to come together as an oracle network and launch their own DONs in a permissionless or self-service manner, meaning that they can do so unilaterally. 
8.2 Dynamic DON Membership 
The set of nodes running a given DON may change over time. There are two approaches to key management for skL given dynamic membership in O. 
The first is to update shares of skL held by the nodes upon changes in membership, while keeping pkL unchanged. This approach, explored in [41, 161, 198], has the merit of not requiring that relying parties update pkL. 
76
The classical technique of share resharing, introduced in [122], provides a simple and efficient way of realizing such share updates. It enables a secret to be transferred between one set of nodes O(1) and a second, possibly intersecting one O(2). In this approach, each node O(1) 
i performs a (k(2), n(2)) secret sharing of its secret share across 
nodes in O(2) for n(2) = |O(2)| and desired (possibly new) threshold k(2). Various verifi able secret sharing (VSS) schemes [108] can provide security against an adversary that actively corrupts nodes, i.e., introduces malicious behavior into the protocol. Tech niques in [161] aim to do so while reducing communication complexity and providing resilience against failures in cryptographic hardness assumptions. 
A second approach is to update the ledger key pkL. This has the benefit of forward security: Compromise of old shares of pkL (i.e., former committee nodes) would not result in compromise of the current key. Updates to pkL, however, carry two drawbacks: (1) Data encrypted under pkL needs to be re-encrypted during a key refresh and (2) Key updates need to be propagated to relying parties. 
We intend to explore both approaches, as well as hybridizations of the two. 
8.3 DON Accountability 
As with existing Chainlink oracle networks, DONs will include mechanisms for account ability, i.e., recording, monitoring, and enforcing correct node behavior. DONs will have much more substantial data capacity than many existing permissionless blockchains, particularly given their ability to connect to external decentralized storage. Conse quently, they will be able to record nodes’ performance history in detail, allowing for more fine-grained accountability mechanisms. For example, off-chain computation of asset prices may involve inputs that are discarded before a median result is sent on chain. In a DON, these intermediate results could be recorded. Misbehavior or per formance lapses by individual nodes in a DON can thus be remedied or penalized on the DON in a fine-grained way. We have additionally discussed approaches to building guard rails in Section 7.3 that address the contract-specific impact of systemic failures. 
It is also important, however, to have failsafe mechanisms for DONs themselves, i.e., protections against systemic, potentially catastrophic DON failures, specifically forking / equivocation and service-level agreement (SLA) failures, as we now explain. 
Forking / equivocation: Given sufficiently many faulty nodes, a DON can fork or equivocate, producing two distinct, inconsistent blocks or sequences of blocks in L. Because a DON digitally signs the contents of L, however, it is possible to leverage a main chain MAINCHAIN to prevent and/or penalize equivocation. 
The DON can periodically checkpoint state from L in an audit contract on MAINCHAIN. If its future state deviates from a checkpointed state, a user / auditor can present proof of this misbehavior to the audit contract. Such proof can be used to generate an alert or penalize DON nodes via slashing in the contract. This latter approach introduces an incentive design problem similar to that for specific oracle feeds, and can build on our work outlined in Section 9. 
77
Enforcing service-level agreements: While DONs are not necessarily meant to run indefinitely, it is important that they adhere to service level agreements (SLAs) with their users. Basic SLA enforcement is possible on a main chain. For example, DON nodes might commit to maintaining the DON until a certain date, or to provid ing advance notice of service termination (e.g., three months’ notice). A contract on MAINCHAIN can provide basic cryptoeconomic SLA enforcement. 
For example, the SLA contract can slash DON-deposited funds if checkpoints are not provided at required intervals. A user can deposit funds and challenge the DON to prove that a checkpoint correctly represents a sequence of valid blocks (in a manner analogous to, e.g. [141]). Of course, block production does not equate with transaction processing, but the SLA contract can also serve to enforce the latter. For example, in the legacy-compatible version of FSS in which transactions are fetched from the mem pool (see Section 5.2), transactions are eventually mined and placed on chain. A user can prove DON malfeasance by furnishing the SLA contract with a transaction that was mined but wasn’t transmitted by the DON for processing by the target contract within the appropriate interval of time.15 
It is also possible to prove the existence of and penalize more fine-grained SLA failures, including errors in computation using executables (via, e.g., the mechanisms for proving correct off-chain state transactions outlined in Section 6.3) or failure to run executables based on initiators visible on a DON, failure to relay data on the DON to MAINCHAIN in a timely way, and so forth. 
9 Economics and Cryptoeconomics 
For the Chainlink network to achieve strong security within a decentralized trust model, it is essential that nodes collectively exhibit correct behavior, meaning that they adhere a majority of the time exactly to DON protocols. In this section, we discuss approaches to helping enforce such behavior by means of economic incentives, a.k.a. cryptoeconomic incentives. These incentives fall into two categories: explicit and implicit, realized respectively through staking and future fee opportunity (FFO). 
Staking: Staking in Chainlink, as in other blockchain systems, involves network par ticipants, i.e., oracle nodes, depositing locked funds in the form of LINK tokens. These funds, which we also refer to as stake or explicit stake are an explicit incentive. They are subject to forfeiture upon node failure or malfeasance. In the blockchain context, this procedure is often called slashing. 
Staking by oracle nodes in Chainlink, however, differs fundamentally from staking by validators in permissionless blockchains. Validators can misbehave by equivocat ing or adversarially ordering transactions. The underlying consensus protocol in a 
15As users can replace transactions in the mempool, care is required to ensure a correct correspon dence between the mined and DON-submitted transactions. 
78
permissionless blockchain, though, uses hard-and-fast block-validation rules and cryp tographic primitives to prevent validators from generating invalid blocks. In contrast, programmatic protections cannot prevent a cheating oracle network from generating invalid reports. The reason is a key difference between the two types of system: transac tion validation in blockchains is a property of internal consistency, while the correctness of oracle reports on a blockchain is a property of external, i.e., off-chain data. 
We have designed a preliminary staking mechanism for the Chainlink network based on an interactive protocol among oracle nodes that may make use of external data. This mechanism creates financial incentives for correct behavior using explicit rewards and penalties (slashing). As the mechanism is economic, it is designed to prevent node corruption by an adversary that uses financial resources to corrupt nodes by means of bribery. (Such an adversary is very general, and extends, e.g., to nodes cooperating to extract value from their collective misbehavior.) 
The Chainlink staking mechanism we have designed has some powerful and novel features.16 The main such feature is super-linear staking impact (specifically, quadratic). An adversary must have resources considerably in excess of nodes’ deposited funds in order to subvert the mechanism. Our staking mechanism additionally provides protec tion against a stronger adversary than previously considered in similar systems, namely an adversary that can create bribes conditioning on nodes’ future behavior. Addition ally, we discuss how Chainlink tools such as DECO can help strengthen our staking mechanism by facilitating correct adjudication in the case of faulty node behavior. 
Future fee opportunity (FFO): Permissionless blockchains—of both the PoW and PoS variety—today rely critically on what we call implicit incentives. These are economic incentives for honest behavior that derive not from explicit rewards, but from platform participation itself. For example, the Bitcoin miner community is in centivized against mounting a 51% attack by the risk of undermining confidence in Bitcoin, depressing its value, and consequently eroding the value of their collective capital investments in mining infrastructure [150]. 
The Chainlink network benefits from a similar implicit incentive that we refer to as future fee opportunity (FFO). Oracle nodes with strong performance histories or reputations attract fees from users. Misbehavior by an oracle node jeopardizes future fee payments and thus penalizes the node with an opportunity cost in terms of potential revenue earned through participation in the network. By analogy with explicit stake, FFO may be viewed as a form of implicit stake, an incentive for honest behavior that derives from the shared benefit of maintaining confidence in the platform on which node operators’ business depends, i.e., the positive performance and reputation of the network. This incentive is inherent in but not explicitly expressed in Chainlink network protocols. In Bitcoin, maintaining the value of mining operations as mentioned above 
16The staking mechanism we describe here currently aims only to enforce delivery of correct reports by oracle networks. We expect in future work to extend it to ensure correct execution of the many other functionalities DONs will provide. 
79
may similarly be viewed as a form of implicit stake. 
We emphasize that FFO already exists in Chainlink and helps secure the network today. Our main contribution in the further development of Chainlink will be a princi pled, empirically driven approach to evaluating implicit incentives such as FFO through what we call the Implicit-Incentive Framework (IIF). To estimate quantities such as the future fee opportunity of nodes, the IIF will draw continuously on the comprehensive performance and payment data amassed by the Chainlink network. Such estimates will enable IIF-based parameterization of staking systems that reflects node incentives with greater accuracy than current heuristic and/or static models. 
To summarize, then, the two main economic incentives for correct oracle node behavior in the developing Chainlink network will be: 
• Staking (deposited stake) oExplicit incentive 
• Future fee opportunity (FFO) oImplicit incentive 
These two forms of incentive are complementary. Oracle nodes can simultaneously participate in the Chainlink staking protocol, enjoy an ongoing revenue stream from users, and collectively benefit from their continued good behavior. Thus both incentives contribute to the cryptoeconomic security provided by an oracle network. Additionally, the two incentives can reinforce and/or be traded off against one another. For example, a new oracle operator without a performance history and revenue stream can stake a large quantity of LINK as a guarantee of honest behavior, thereby attracting users and fees. Conversely, an established oracle operator with a long, relatively fault-free performance history can charge substantial fees from a large user base and thus rely more heavily on its FFO as a form of implicit incentive. 
In general, the approach we consider here aims for a given amount of oracle-network resource to create the greatest possible economic incentives in Chainlink for rational agents—i.e., nodes maximizing their financial utility—to behave honestly. Put another way, the goal is to maximize the financial resources required for an adversary to attack the network successfully. By formulating a staking protocol with mathematically well defined economic security and also using the IIF, we aim to measure the strength of Chainlink’s incentives as accurately as possible. The creators of relying contracts will then be able to determine with strong confidence whether an oracle network meets their required levels of cryptoeconomic security. 
The virtuous cycle of economic security: The incentives we discuss in this sec tion, staking and FFO, have an impact beyond their reinforcement of the security of DONs. They promise to induce what we call a virtuous cycle of economic security. Super-linear staking impact (and other economies of scale) result in lower operational cost as a DON’s security grows. Lower cost attracts additional users to the DON, 
80
